   1              		.syntax unified
   2              		.cpu cortex-m3
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 4
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.thumb
  14              		.file	"spi_arch.c"
  15              		.text
  16              	.Ltext0:
  17              		.cfi_sections	.debug_frame
  18              		.section	.text.spi_configure_dma,"ax",%progbits
  19              		.align	1
  20              		.thumb
  21              		.thumb_func
  23              	spi_configure_dma:
  24              	.LFB14:
  25              		.file 1 "arch/stm32/mcu_periph/spi_arch.c"
   1:arch/stm32/mcu_periph/spi_arch.c **** /*
   2:arch/stm32/mcu_periph/spi_arch.c ****  * Copyright (C) 2005-2013 The Paparazzi Team
   3:arch/stm32/mcu_periph/spi_arch.c ****  *
   4:arch/stm32/mcu_periph/spi_arch.c ****  * This file is part of paparazzi.
   5:arch/stm32/mcu_periph/spi_arch.c ****  *
   6:arch/stm32/mcu_periph/spi_arch.c ****  * paparazzi is free software; you can redistribute it and/or modify
   7:arch/stm32/mcu_periph/spi_arch.c ****  * it under the terms of the GNU General Public License as published by
   8:arch/stm32/mcu_periph/spi_arch.c ****  * the Free Software Foundation; either version 2, or (at your option)
   9:arch/stm32/mcu_periph/spi_arch.c ****  * any later version.
  10:arch/stm32/mcu_periph/spi_arch.c ****  *
  11:arch/stm32/mcu_periph/spi_arch.c ****  * paparazzi is distributed in the hope that it will be useful,
  12:arch/stm32/mcu_periph/spi_arch.c ****  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  13:arch/stm32/mcu_periph/spi_arch.c ****  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  14:arch/stm32/mcu_periph/spi_arch.c ****  * GNU General Public License for more details.
  15:arch/stm32/mcu_periph/spi_arch.c ****  *
  16:arch/stm32/mcu_periph/spi_arch.c ****  * You should have received a copy of the GNU General Public License
  17:arch/stm32/mcu_periph/spi_arch.c ****  * along with paparazzi; see the file COPYING.  If not, write to
  18:arch/stm32/mcu_periph/spi_arch.c ****  * the Free Software Foundation, 59 Temple Place - Suite 330,
  19:arch/stm32/mcu_periph/spi_arch.c ****  * Boston, MA 02111-1307, USA.
  20:arch/stm32/mcu_periph/spi_arch.c ****  *
  21:arch/stm32/mcu_periph/spi_arch.c ****  */
  22:arch/stm32/mcu_periph/spi_arch.c **** 
  23:arch/stm32/mcu_periph/spi_arch.c **** /**
  24:arch/stm32/mcu_periph/spi_arch.c ****  * @file arch/stm32/mcu_periph/spi_arch.c
  25:arch/stm32/mcu_periph/spi_arch.c ****  * @ingroup stm32_arch
  26:arch/stm32/mcu_periph/spi_arch.c ****  *
  27:arch/stm32/mcu_periph/spi_arch.c ****  * Handling of SPI hardware for STM32.
  28:arch/stm32/mcu_periph/spi_arch.c ****  * SPI Master code.
  29:arch/stm32/mcu_periph/spi_arch.c ****  *
  30:arch/stm32/mcu_periph/spi_arch.c ****  * When a transaction is submitted:
  31:arch/stm32/mcu_periph/spi_arch.c ****  * - The transaction is added to the queue if there is space,
  32:arch/stm32/mcu_periph/spi_arch.c ****  *   otherwise it returns false
  33:arch/stm32/mcu_periph/spi_arch.c ****  * - The pending state is set
  34:arch/stm32/mcu_periph/spi_arch.c ****  * - SPI Interrupts (in this case the DMA interrupts) are disabled
  35:arch/stm32/mcu_periph/spi_arch.c ****  *   to prevent race conditions
  36:arch/stm32/mcu_periph/spi_arch.c ****  * - The slave is selected if required, then the before_cb callback is run
  37:arch/stm32/mcu_periph/spi_arch.c ****  * - The spi and dma registers are set up for the specific transaction
  38:arch/stm32/mcu_periph/spi_arch.c ****  * - Spi, DMA and interrupts are enabled and the transaction starts
  39:arch/stm32/mcu_periph/spi_arch.c ****  *
  40:arch/stm32/mcu_periph/spi_arch.c ****  * Obviously output_length and input_length will never both be 0 at the same time.
  41:arch/stm32/mcu_periph/spi_arch.c ****  * In this case, spi_submit will just return false.
  42:arch/stm32/mcu_periph/spi_arch.c ****  *
  43:arch/stm32/mcu_periph/spi_arch.c ****  * For the DMA and interrupts:
  44:arch/stm32/mcu_periph/spi_arch.c ****  * - If the output_len != input_len, a dummy DMA transfer is triggered for
  45:arch/stm32/mcu_periph/spi_arch.c ****  *   the remainder so the same amount of data is moved in and out.
  46:arch/stm32/mcu_periph/spi_arch.c ****  *   This simplifies keeping the clock going if output_len is greater and allows
  47:arch/stm32/mcu_periph/spi_arch.c ****  *   the rx dma interrupt to represent that the transaction has fully completed.
  48:arch/stm32/mcu_periph/spi_arch.c ****  * - The dummy DMA transfer is initiated at the transaction setup if length is 0,
  49:arch/stm32/mcu_periph/spi_arch.c ****  *   otherwise after the first dma interrupt completes in the ISR directly.
  50:arch/stm32/mcu_periph/spi_arch.c ****  * - The rx DMA transfer completed interrupt marks the end of a complete transaction.
  51:arch/stm32/mcu_periph/spi_arch.c ****  * - The after_cb callback happens BEFORE the slave is unselected as configured.
  52:arch/stm32/mcu_periph/spi_arch.c ****  */
  53:arch/stm32/mcu_periph/spi_arch.c **** 
  54:arch/stm32/mcu_periph/spi_arch.c **** #include <libopencm3/cm3/nvic.h>
  55:arch/stm32/mcu_periph/spi_arch.c **** #include <libopencm3/stm32/gpio.h>
  56:arch/stm32/mcu_periph/spi_arch.c **** #include <libopencm3/stm32/rcc.h>
  57:arch/stm32/mcu_periph/spi_arch.c **** #include <libopencm3/stm32/exti.h>
  58:arch/stm32/mcu_periph/spi_arch.c **** #include <libopencm3/stm32/spi.h>
  59:arch/stm32/mcu_periph/spi_arch.c **** #include <libopencm3/stm32/dma.h>
  60:arch/stm32/mcu_periph/spi_arch.c **** 
  61:arch/stm32/mcu_periph/spi_arch.c **** #include "mcu_periph/spi.h"
  62:arch/stm32/mcu_periph/spi_arch.c **** #include "mcu_periph/gpio.h"
  63:arch/stm32/mcu_periph/spi_arch.c **** 
  64:arch/stm32/mcu_periph/spi_arch.c **** #include BOARD_CONFIG
  65:arch/stm32/mcu_periph/spi_arch.c **** 
  66:arch/stm32/mcu_periph/spi_arch.c **** #ifdef SPI_MASTER
  67:arch/stm32/mcu_periph/spi_arch.c **** 
  68:arch/stm32/mcu_periph/spi_arch.c **** /**
  69:arch/stm32/mcu_periph/spi_arch.c ****  * Libopencm3 specifc communication parameters for a SPI peripheral in master mode.
  70:arch/stm32/mcu_periph/spi_arch.c ****  */
  71:arch/stm32/mcu_periph/spi_arch.c **** struct locm3_spi_comm {
  72:arch/stm32/mcu_periph/spi_arch.c ****   u32 br;       ///< baudrate (clock divider)
  73:arch/stm32/mcu_periph/spi_arch.c ****   u32 cpol;     ///< clock polarity
  74:arch/stm32/mcu_periph/spi_arch.c ****   u32 cpha;     ///< clock phase
  75:arch/stm32/mcu_periph/spi_arch.c ****   u32 dff;      ///< data frame format 8/16 bits
  76:arch/stm32/mcu_periph/spi_arch.c ****   u32 lsbfirst; ///< frame format lsb/msb first
  77:arch/stm32/mcu_periph/spi_arch.c **** };
  78:arch/stm32/mcu_periph/spi_arch.c **** 
  79:arch/stm32/mcu_periph/spi_arch.c **** /**
  80:arch/stm32/mcu_periph/spi_arch.c ****  * This structure keeps track of specific config for each SPI bus,
  81:arch/stm32/mcu_periph/spi_arch.c ****  * which allows for more code reuse.
  82:arch/stm32/mcu_periph/spi_arch.c ****  */
  83:arch/stm32/mcu_periph/spi_arch.c **** struct spi_periph_dma {
  84:arch/stm32/mcu_periph/spi_arch.c ****   u32 spi;                    ///< SPI peripheral identifier
  85:arch/stm32/mcu_periph/spi_arch.c ****   u32 spidr;                  ///< SPI DataRegister address for DMA
  86:arch/stm32/mcu_periph/spi_arch.c ****   u32 dma;                    ///< DMA controller base address (DMA1 or DMA2)
  87:arch/stm32/mcu_periph/spi_arch.c ****   u8  rx_chan;                ///< receive DMA channel number
  88:arch/stm32/mcu_periph/spi_arch.c ****   u8  tx_chan;                ///< transmit DMA channel number
  89:arch/stm32/mcu_periph/spi_arch.c ****   u8  rx_nvic_irq;            ///< receive interrupt
  90:arch/stm32/mcu_periph/spi_arch.c ****   u8  tx_nvic_irq;            ///< transmit interrupt
  91:arch/stm32/mcu_periph/spi_arch.c ****   u16 tx_dummy_buf;           ///< dummy tx buffer for receive only cases
  92:arch/stm32/mcu_periph/spi_arch.c ****   bool_t tx_extra_dummy_dma;  ///< extra tx dummy dma flag for tx_len < rx_len
  93:arch/stm32/mcu_periph/spi_arch.c ****   u16 rx_dummy_buf;           ///< dummy rx buffer for receive only cases
  94:arch/stm32/mcu_periph/spi_arch.c ****   bool_t rx_extra_dummy_dma;  ///< extra rx dummy dma flag for tx_len > rx_len
  95:arch/stm32/mcu_periph/spi_arch.c ****   struct locm3_spi_comm comm; ///< current communication paramters
  96:arch/stm32/mcu_periph/spi_arch.c ****   u8  comm_sig;               ///< comm config signature used to check for changes
  97:arch/stm32/mcu_periph/spi_arch.c **** };
  98:arch/stm32/mcu_periph/spi_arch.c **** 
  99:arch/stm32/mcu_periph/spi_arch.c **** 
 100:arch/stm32/mcu_periph/spi_arch.c **** #if USE_SPI0
 101:arch/stm32/mcu_periph/spi_arch.c **** #error "The STM32 doesn't have SPI0"
 102:arch/stm32/mcu_periph/spi_arch.c **** #endif
 103:arch/stm32/mcu_periph/spi_arch.c **** #if USE_SPI1
 104:arch/stm32/mcu_periph/spi_arch.c **** static struct spi_periph_dma spi1_dma;
 105:arch/stm32/mcu_periph/spi_arch.c **** #endif
 106:arch/stm32/mcu_periph/spi_arch.c **** #if USE_SPI2
 107:arch/stm32/mcu_periph/spi_arch.c **** static struct spi_periph_dma spi2_dma;
 108:arch/stm32/mcu_periph/spi_arch.c **** #endif
 109:arch/stm32/mcu_periph/spi_arch.c **** #if USE_SPI3
 110:arch/stm32/mcu_periph/spi_arch.c **** static struct spi_periph_dma spi3_dma;
 111:arch/stm32/mcu_periph/spi_arch.c **** #endif
 112:arch/stm32/mcu_periph/spi_arch.c **** 
 113:arch/stm32/mcu_periph/spi_arch.c **** static void spi_start_dma_transaction(struct spi_periph* periph, struct spi_transaction* _trans);
 114:arch/stm32/mcu_periph/spi_arch.c **** static void spi_next_transaction(struct spi_periph* periph);
 115:arch/stm32/mcu_periph/spi_arch.c **** static void spi_configure_dma(u32 dma, u8 chan, u32 periph_addr, u32 buf_addr,
 116:arch/stm32/mcu_periph/spi_arch.c ****                               u16 len, enum SPIDataSizeSelect dss, bool_t increment);
 117:arch/stm32/mcu_periph/spi_arch.c **** static void process_rx_dma_interrupt(struct spi_periph* periph);
 118:arch/stm32/mcu_periph/spi_arch.c **** static void process_tx_dma_interrupt(struct spi_periph* periph);
 119:arch/stm32/mcu_periph/spi_arch.c **** static void spi_arch_int_enable(struct spi_periph *spi);
 120:arch/stm32/mcu_periph/spi_arch.c **** static void spi_arch_int_disable(struct spi_periph *spi);
 121:arch/stm32/mcu_periph/spi_arch.c **** 
 122:arch/stm32/mcu_periph/spi_arch.c **** 
 123:arch/stm32/mcu_periph/spi_arch.c **** /******************************************************************************
 124:arch/stm32/mcu_periph/spi_arch.c ****  *
 125:arch/stm32/mcu_periph/spi_arch.c ****  * Handling of Slave Select outputs
 126:arch/stm32/mcu_periph/spi_arch.c ****  *
 127:arch/stm32/mcu_periph/spi_arch.c ****  *****************************************************************************/
 128:arch/stm32/mcu_periph/spi_arch.c **** 
 129:arch/stm32/mcu_periph/spi_arch.c **** static inline void SpiSlaveUnselect(uint8_t slave) {
 130:arch/stm32/mcu_periph/spi_arch.c ****   switch(slave) {
 131:arch/stm32/mcu_periph/spi_arch.c **** #if USE_SPI_SLAVE0
 132:arch/stm32/mcu_periph/spi_arch.c ****     case 0:
 133:arch/stm32/mcu_periph/spi_arch.c ****       gpio_set(SPI_SELECT_SLAVE0_PORT, SPI_SELECT_SLAVE0_PIN);
 134:arch/stm32/mcu_periph/spi_arch.c ****       break;
 135:arch/stm32/mcu_periph/spi_arch.c **** #endif // USE_SPI_SLAVE0
 136:arch/stm32/mcu_periph/spi_arch.c **** #if USE_SPI_SLAVE1
 137:arch/stm32/mcu_periph/spi_arch.c ****     case 1:
 138:arch/stm32/mcu_periph/spi_arch.c ****       gpio_set(SPI_SELECT_SLAVE1_PORT, SPI_SELECT_SLAVE1_PIN);
 139:arch/stm32/mcu_periph/spi_arch.c ****       break;
 140:arch/stm32/mcu_periph/spi_arch.c **** #endif //USE_SPI_SLAVE1
 141:arch/stm32/mcu_periph/spi_arch.c **** #if USE_SPI_SLAVE2
 142:arch/stm32/mcu_periph/spi_arch.c ****     case 2:
 143:arch/stm32/mcu_periph/spi_arch.c ****       gpio_set(SPI_SELECT_SLAVE2_PORT, SPI_SELECT_SLAVE2_PIN);
 144:arch/stm32/mcu_periph/spi_arch.c ****       break;
 145:arch/stm32/mcu_periph/spi_arch.c **** #endif //USE_SPI_SLAVE2
 146:arch/stm32/mcu_periph/spi_arch.c **** #if USE_SPI_SLAVE3
 147:arch/stm32/mcu_periph/spi_arch.c ****     case 3:
 148:arch/stm32/mcu_periph/spi_arch.c ****       gpio_set(SPI_SELECT_SLAVE3_PORT, SPI_SELECT_SLAVE3_PIN);
 149:arch/stm32/mcu_periph/spi_arch.c ****       break;
 150:arch/stm32/mcu_periph/spi_arch.c **** #endif //USE_SPI_SLAVE3
 151:arch/stm32/mcu_periph/spi_arch.c **** #if USE_SPI_SLAVE4
 152:arch/stm32/mcu_periph/spi_arch.c ****     case 4:
 153:arch/stm32/mcu_periph/spi_arch.c ****       gpio_set(SPI_SELECT_SLAVE4_PORT, SPI_SELECT_SLAVE4_PIN);
 154:arch/stm32/mcu_periph/spi_arch.c ****       break;
 155:arch/stm32/mcu_periph/spi_arch.c **** #endif //USE_SPI_SLAVE4
 156:arch/stm32/mcu_periph/spi_arch.c **** #if USE_SPI_SLAVE5
 157:arch/stm32/mcu_periph/spi_arch.c ****     case 5:
 158:arch/stm32/mcu_periph/spi_arch.c ****       gpio_set(SPI_SELECT_SLAVE5_PORT, SPI_SELECT_SLAVE5_PIN);
 159:arch/stm32/mcu_periph/spi_arch.c ****       break;
 160:arch/stm32/mcu_periph/spi_arch.c **** #endif //USE_SPI_SLAVE5
 161:arch/stm32/mcu_periph/spi_arch.c ****     default:
 162:arch/stm32/mcu_periph/spi_arch.c ****       break;
 163:arch/stm32/mcu_periph/spi_arch.c ****   }
 164:arch/stm32/mcu_periph/spi_arch.c **** }
 165:arch/stm32/mcu_periph/spi_arch.c **** 
 166:arch/stm32/mcu_periph/spi_arch.c **** static inline void SpiSlaveSelect(uint8_t slave) {
 167:arch/stm32/mcu_periph/spi_arch.c ****   switch(slave) {
 168:arch/stm32/mcu_periph/spi_arch.c **** #if USE_SPI_SLAVE0
 169:arch/stm32/mcu_periph/spi_arch.c ****     case 0:
 170:arch/stm32/mcu_periph/spi_arch.c ****       gpio_clear(SPI_SELECT_SLAVE0_PORT, SPI_SELECT_SLAVE0_PIN);
 171:arch/stm32/mcu_periph/spi_arch.c ****       break;
 172:arch/stm32/mcu_periph/spi_arch.c **** #endif // USE_SPI_SLAVE0
 173:arch/stm32/mcu_periph/spi_arch.c **** #if USE_SPI_SLAVE1
 174:arch/stm32/mcu_periph/spi_arch.c ****     case 1:
 175:arch/stm32/mcu_periph/spi_arch.c ****       gpio_clear(SPI_SELECT_SLAVE1_PORT, SPI_SELECT_SLAVE1_PIN);
 176:arch/stm32/mcu_periph/spi_arch.c ****       break;
 177:arch/stm32/mcu_periph/spi_arch.c **** #endif //USE_SPI_SLAVE1
 178:arch/stm32/mcu_periph/spi_arch.c **** #if USE_SPI_SLAVE2
 179:arch/stm32/mcu_periph/spi_arch.c ****     case 2:
 180:arch/stm32/mcu_periph/spi_arch.c ****       gpio_clear(SPI_SELECT_SLAVE2_PORT, SPI_SELECT_SLAVE2_PIN);
 181:arch/stm32/mcu_periph/spi_arch.c ****       break;
 182:arch/stm32/mcu_periph/spi_arch.c **** #endif //USE_SPI_SLAVE2
 183:arch/stm32/mcu_periph/spi_arch.c **** #if USE_SPI_SLAVE3
 184:arch/stm32/mcu_periph/spi_arch.c ****     case 3:
 185:arch/stm32/mcu_periph/spi_arch.c ****       gpio_clear(SPI_SELECT_SLAVE3_PORT, SPI_SELECT_SLAVE3_PIN);
 186:arch/stm32/mcu_periph/spi_arch.c ****       break;
 187:arch/stm32/mcu_periph/spi_arch.c **** #endif //USE_SPI_SLAVE3
 188:arch/stm32/mcu_periph/spi_arch.c **** #if USE_SPI_SLAVE4
 189:arch/stm32/mcu_periph/spi_arch.c ****     case 4:
 190:arch/stm32/mcu_periph/spi_arch.c ****       gpio_clear(SPI_SELECT_SLAVE4_PORT, SPI_SELECT_SLAVE4_PIN);
 191:arch/stm32/mcu_periph/spi_arch.c ****       break;
 192:arch/stm32/mcu_periph/spi_arch.c **** #endif //USE_SPI_SLAVE4
 193:arch/stm32/mcu_periph/spi_arch.c **** #if USE_SPI_SLAVE5
 194:arch/stm32/mcu_periph/spi_arch.c ****     case 5:
 195:arch/stm32/mcu_periph/spi_arch.c ****       gpio_clear(SPI_SELECT_SLAVE5_PORT, SPI_SELECT_SLAVE5_PIN);
 196:arch/stm32/mcu_periph/spi_arch.c ****       break;
 197:arch/stm32/mcu_periph/spi_arch.c **** #endif //USE_SPI_SLAVE5
 198:arch/stm32/mcu_periph/spi_arch.c ****     default:
 199:arch/stm32/mcu_periph/spi_arch.c ****       break;
 200:arch/stm32/mcu_periph/spi_arch.c ****   }
 201:arch/stm32/mcu_periph/spi_arch.c **** }
 202:arch/stm32/mcu_periph/spi_arch.c **** 
 203:arch/stm32/mcu_periph/spi_arch.c **** void spi_slave_select(uint8_t slave) {
 204:arch/stm32/mcu_periph/spi_arch.c ****   SpiSlaveSelect(slave);
 205:arch/stm32/mcu_periph/spi_arch.c **** }
 206:arch/stm32/mcu_periph/spi_arch.c **** 
 207:arch/stm32/mcu_periph/spi_arch.c **** void spi_slave_unselect(uint8_t slave) {
 208:arch/stm32/mcu_periph/spi_arch.c ****   SpiSlaveUnselect(slave);
 209:arch/stm32/mcu_periph/spi_arch.c **** }
 210:arch/stm32/mcu_periph/spi_arch.c **** 
 211:arch/stm32/mcu_periph/spi_arch.c **** void spi_init_slaves(void) {
 212:arch/stm32/mcu_periph/spi_arch.c **** 
 213:arch/stm32/mcu_periph/spi_arch.c **** #if USE_SPI_SLAVE0
 214:arch/stm32/mcu_periph/spi_arch.c ****   gpio_setup_output(SPI_SELECT_SLAVE0_PORT, SPI_SELECT_SLAVE0_PIN);
 215:arch/stm32/mcu_periph/spi_arch.c ****   SpiSlaveUnselect(0);
 216:arch/stm32/mcu_periph/spi_arch.c **** #endif
 217:arch/stm32/mcu_periph/spi_arch.c **** 
 218:arch/stm32/mcu_periph/spi_arch.c **** #if USE_SPI_SLAVE1
 219:arch/stm32/mcu_periph/spi_arch.c ****   gpio_setup_output(SPI_SELECT_SLAVE1_PORT, SPI_SELECT_SLAVE1_PIN);
 220:arch/stm32/mcu_periph/spi_arch.c ****   SpiSlaveUnselect(1);
 221:arch/stm32/mcu_periph/spi_arch.c **** #endif
 222:arch/stm32/mcu_periph/spi_arch.c **** 
 223:arch/stm32/mcu_periph/spi_arch.c **** #if USE_SPI_SLAVE2
 224:arch/stm32/mcu_periph/spi_arch.c ****   gpio_setup_output(SPI_SELECT_SLAVE2_PORT, SPI_SELECT_SLAVE2_PIN);
 225:arch/stm32/mcu_periph/spi_arch.c ****   SpiSlaveUnselect(2);
 226:arch/stm32/mcu_periph/spi_arch.c **** #endif
 227:arch/stm32/mcu_periph/spi_arch.c **** 
 228:arch/stm32/mcu_periph/spi_arch.c **** #if USE_SPI_SLAVE3
 229:arch/stm32/mcu_periph/spi_arch.c ****   gpio_setup_output(SPI_SELECT_SLAVE3_PORT, SPI_SELECT_SLAVE3_PIN);
 230:arch/stm32/mcu_periph/spi_arch.c ****   SpiSlaveUnselect(3);
 231:arch/stm32/mcu_periph/spi_arch.c **** #endif
 232:arch/stm32/mcu_periph/spi_arch.c **** 
 233:arch/stm32/mcu_periph/spi_arch.c **** #if USE_SPI_SLAVE4
 234:arch/stm32/mcu_periph/spi_arch.c ****   gpio_setup_output(SPI_SELECT_SLAVE4_PORT, SPI_SELECT_SLAVE4_PIN);
 235:arch/stm32/mcu_periph/spi_arch.c ****   SpiSlaveUnselect(4);
 236:arch/stm32/mcu_periph/spi_arch.c **** #endif
 237:arch/stm32/mcu_periph/spi_arch.c **** 
 238:arch/stm32/mcu_periph/spi_arch.c **** #if USE_SPI_SLAVE5
 239:arch/stm32/mcu_periph/spi_arch.c ****   gpio_setup_output(SPI_SELECT_SLAVE5_PORT, SPI_SELECT_SLAVE5_PIN);
 240:arch/stm32/mcu_periph/spi_arch.c ****   SpiSlaveUnselect(5);
 241:arch/stm32/mcu_periph/spi_arch.c **** #endif
 242:arch/stm32/mcu_periph/spi_arch.c **** }
 243:arch/stm32/mcu_periph/spi_arch.c **** 
 244:arch/stm32/mcu_periph/spi_arch.c **** 
 245:arch/stm32/mcu_periph/spi_arch.c **** /******************************************************************************
 246:arch/stm32/mcu_periph/spi_arch.c ****  *
 247:arch/stm32/mcu_periph/spi_arch.c ****  * Implementation of the generic SPI functions
 248:arch/stm32/mcu_periph/spi_arch.c ****  *
 249:arch/stm32/mcu_periph/spi_arch.c ****  *****************************************************************************/
 250:arch/stm32/mcu_periph/spi_arch.c **** bool_t spi_submit(struct spi_periph* p, struct spi_transaction* t)
 251:arch/stm32/mcu_periph/spi_arch.c **** {
 252:arch/stm32/mcu_periph/spi_arch.c ****   uint8_t idx;
 253:arch/stm32/mcu_periph/spi_arch.c ****   idx = p->trans_insert_idx + 1;
 254:arch/stm32/mcu_periph/spi_arch.c ****   if (idx >= SPI_TRANSACTION_QUEUE_LEN) idx = 0;
 255:arch/stm32/mcu_periph/spi_arch.c ****   if ((idx == p->trans_extract_idx) || ((t->input_length == 0) && (t->output_length == 0))) {
 256:arch/stm32/mcu_periph/spi_arch.c ****     t->status = SPITransFailed;
 257:arch/stm32/mcu_periph/spi_arch.c ****     return FALSE; /* queue full or input_length and output_length both 0 */
 258:arch/stm32/mcu_periph/spi_arch.c ****     // TODO can't tell why it failed here if it does
 259:arch/stm32/mcu_periph/spi_arch.c ****   }
 260:arch/stm32/mcu_periph/spi_arch.c **** 
 261:arch/stm32/mcu_periph/spi_arch.c ****   t->status = SPITransPending;
 262:arch/stm32/mcu_periph/spi_arch.c **** 
 263:arch/stm32/mcu_periph/spi_arch.c ****   //Disable interrupts to avoid race conflict with end of DMA transfer interrupt
 264:arch/stm32/mcu_periph/spi_arch.c ****   //FIXME
 265:arch/stm32/mcu_periph/spi_arch.c ****   spi_arch_int_disable(p);
 266:arch/stm32/mcu_periph/spi_arch.c **** 
 267:arch/stm32/mcu_periph/spi_arch.c ****   // GT: no copy?  There's a queue implying a copy here...
 268:arch/stm32/mcu_periph/spi_arch.c ****   p->trans[p->trans_insert_idx] = t;
 269:arch/stm32/mcu_periph/spi_arch.c ****   p->trans_insert_idx = idx;
 270:arch/stm32/mcu_periph/spi_arch.c **** 
 271:arch/stm32/mcu_periph/spi_arch.c ****   /* if peripheral is idle, start the transaction */
 272:arch/stm32/mcu_periph/spi_arch.c ****   if (p->status == SPIIdle && !p->suspend) {
 273:arch/stm32/mcu_periph/spi_arch.c ****     spi_start_dma_transaction(p, p->trans[p->trans_extract_idx]);
 274:arch/stm32/mcu_periph/spi_arch.c ****   }
 275:arch/stm32/mcu_periph/spi_arch.c ****   //FIXME
 276:arch/stm32/mcu_periph/spi_arch.c ****   spi_arch_int_enable(p);
 277:arch/stm32/mcu_periph/spi_arch.c ****   return TRUE;
 278:arch/stm32/mcu_periph/spi_arch.c **** }
 279:arch/stm32/mcu_periph/spi_arch.c **** 
 280:arch/stm32/mcu_periph/spi_arch.c **** bool_t spi_lock(struct spi_periph* p, uint8_t slave) {
 281:arch/stm32/mcu_periph/spi_arch.c ****   spi_arch_int_disable(p);
 282:arch/stm32/mcu_periph/spi_arch.c ****   if (slave < 254 && p->suspend == 0) {
 283:arch/stm32/mcu_periph/spi_arch.c ****     p->suspend = slave + 1; // 0 is reserved for unlock state
 284:arch/stm32/mcu_periph/spi_arch.c ****     spi_arch_int_enable(p);
 285:arch/stm32/mcu_periph/spi_arch.c ****     return TRUE;
 286:arch/stm32/mcu_periph/spi_arch.c ****   }
 287:arch/stm32/mcu_periph/spi_arch.c ****   spi_arch_int_enable(p);
 288:arch/stm32/mcu_periph/spi_arch.c ****   return FALSE;
 289:arch/stm32/mcu_periph/spi_arch.c **** }
 290:arch/stm32/mcu_periph/spi_arch.c **** 
 291:arch/stm32/mcu_periph/spi_arch.c **** bool_t spi_resume(struct spi_periph* p, uint8_t slave) {
 292:arch/stm32/mcu_periph/spi_arch.c ****   spi_arch_int_disable( p );
 293:arch/stm32/mcu_periph/spi_arch.c ****   if (p->suspend == slave + 1) {
 294:arch/stm32/mcu_periph/spi_arch.c ****     // restart fifo
 295:arch/stm32/mcu_periph/spi_arch.c ****     p->suspend = 0;
 296:arch/stm32/mcu_periph/spi_arch.c ****     if (p->trans_extract_idx != p->trans_insert_idx && p->status == SPIIdle) {
 297:arch/stm32/mcu_periph/spi_arch.c ****       spi_start_dma_transaction(p, p->trans[p->trans_extract_idx]);
 298:arch/stm32/mcu_periph/spi_arch.c ****     }
 299:arch/stm32/mcu_periph/spi_arch.c ****     spi_arch_int_enable(p);
 300:arch/stm32/mcu_periph/spi_arch.c ****     return TRUE;
 301:arch/stm32/mcu_periph/spi_arch.c ****   }
 302:arch/stm32/mcu_periph/spi_arch.c ****   spi_arch_int_enable(p);
 303:arch/stm32/mcu_periph/spi_arch.c ****   return FALSE;
 304:arch/stm32/mcu_periph/spi_arch.c **** }
 305:arch/stm32/mcu_periph/spi_arch.c **** 
 306:arch/stm32/mcu_periph/spi_arch.c **** 
 307:arch/stm32/mcu_periph/spi_arch.c **** /******************************************************************************
 308:arch/stm32/mcu_periph/spi_arch.c ****  *
 309:arch/stm32/mcu_periph/spi_arch.c ****  * Transaction configuration helper functions
 310:arch/stm32/mcu_periph/spi_arch.c ****  *
 311:arch/stm32/mcu_periph/spi_arch.c ****  *****************************************************************************/
 312:arch/stm32/mcu_periph/spi_arch.c **** static void set_default_comm_config(struct locm3_spi_comm* c) {
 313:arch/stm32/mcu_periph/spi_arch.c ****   c->br = SPI_CR1_BAUDRATE_FPCLK_DIV_64;
 314:arch/stm32/mcu_periph/spi_arch.c ****   c->cpol = SPI_CR1_CPOL_CLK_TO_1_WHEN_IDLE;
 315:arch/stm32/mcu_periph/spi_arch.c ****   c->cpha = SPI_CR1_CPHA_CLK_TRANSITION_2;
 316:arch/stm32/mcu_periph/spi_arch.c ****   c->dff = SPI_CR1_DFF_8BIT;
 317:arch/stm32/mcu_periph/spi_arch.c ****   c->lsbfirst = SPI_CR1_MSBFIRST;
 318:arch/stm32/mcu_periph/spi_arch.c **** }
 319:arch/stm32/mcu_periph/spi_arch.c **** 
 320:arch/stm32/mcu_periph/spi_arch.c **** static inline uint8_t get_transaction_signature(struct spi_transaction* t) {
 321:arch/stm32/mcu_periph/spi_arch.c ****   return ((t->dss << 6) | (t->cdiv << 3) | (t->bitorder << 2) |
 322:arch/stm32/mcu_periph/spi_arch.c ****           (t->cpha << 1) | (t->cpol));
 323:arch/stm32/mcu_periph/spi_arch.c **** }
 324:arch/stm32/mcu_periph/spi_arch.c **** 
 325:arch/stm32/mcu_periph/spi_arch.c **** static uint8_t get_comm_signature(struct locm3_spi_comm* c) {
 326:arch/stm32/mcu_periph/spi_arch.c ****   uint8_t sig = 0;
 327:arch/stm32/mcu_periph/spi_arch.c ****   if (c->cpol == SPI_CR1_CPOL_CLK_TO_0_WHEN_IDLE) {
 328:arch/stm32/mcu_periph/spi_arch.c ****     sig |= SPICpolIdleLow;
 329:arch/stm32/mcu_periph/spi_arch.c ****   } else {
 330:arch/stm32/mcu_periph/spi_arch.c ****     sig |= SPICpolIdleHigh;
 331:arch/stm32/mcu_periph/spi_arch.c ****   }
 332:arch/stm32/mcu_periph/spi_arch.c ****   if (c->cpha == SPI_CR1_CPHA_CLK_TRANSITION_1) {
 333:arch/stm32/mcu_periph/spi_arch.c ****     sig |= (SPICphaEdge1 << 1);
 334:arch/stm32/mcu_periph/spi_arch.c ****   } else {
 335:arch/stm32/mcu_periph/spi_arch.c ****     sig |= (SPICphaEdge2 << 1);
 336:arch/stm32/mcu_periph/spi_arch.c ****   }
 337:arch/stm32/mcu_periph/spi_arch.c ****   if (c->lsbfirst == SPI_CR1_MSBFIRST) {
 338:arch/stm32/mcu_periph/spi_arch.c ****     sig |= (SPIMSBFirst << 2);
 339:arch/stm32/mcu_periph/spi_arch.c ****   } else {
 340:arch/stm32/mcu_periph/spi_arch.c ****     sig |= (SPILSBFirst << 2);
 341:arch/stm32/mcu_periph/spi_arch.c ****   }
 342:arch/stm32/mcu_periph/spi_arch.c ****   uint8_t cdiv = SPIDiv256;
 343:arch/stm32/mcu_periph/spi_arch.c ****   switch (c->br) {
 344:arch/stm32/mcu_periph/spi_arch.c ****     case SPI_CR1_BAUDRATE_FPCLK_DIV_2:
 345:arch/stm32/mcu_periph/spi_arch.c ****       cdiv = SPIDiv2;
 346:arch/stm32/mcu_periph/spi_arch.c ****       break;
 347:arch/stm32/mcu_periph/spi_arch.c ****     case SPI_CR1_BAUDRATE_FPCLK_DIV_4:
 348:arch/stm32/mcu_periph/spi_arch.c ****       cdiv = SPIDiv4;
 349:arch/stm32/mcu_periph/spi_arch.c ****       break;
 350:arch/stm32/mcu_periph/spi_arch.c ****     case SPI_CR1_BAUDRATE_FPCLK_DIV_8:
 351:arch/stm32/mcu_periph/spi_arch.c ****       cdiv = SPIDiv8;
 352:arch/stm32/mcu_periph/spi_arch.c ****       break;
 353:arch/stm32/mcu_periph/spi_arch.c ****     case SPI_CR1_BAUDRATE_FPCLK_DIV_16:
 354:arch/stm32/mcu_periph/spi_arch.c ****       cdiv = SPIDiv16;
 355:arch/stm32/mcu_periph/spi_arch.c ****       break;
 356:arch/stm32/mcu_periph/spi_arch.c ****     case SPI_CR1_BAUDRATE_FPCLK_DIV_32:
 357:arch/stm32/mcu_periph/spi_arch.c ****       cdiv = SPIDiv32;
 358:arch/stm32/mcu_periph/spi_arch.c ****       break;
 359:arch/stm32/mcu_periph/spi_arch.c ****     case SPI_CR1_BAUDRATE_FPCLK_DIV_64:
 360:arch/stm32/mcu_periph/spi_arch.c ****       cdiv = SPIDiv64;
 361:arch/stm32/mcu_periph/spi_arch.c ****       break;
 362:arch/stm32/mcu_periph/spi_arch.c ****     case SPI_CR1_BAUDRATE_FPCLK_DIV_128:
 363:arch/stm32/mcu_periph/spi_arch.c ****       cdiv = SPIDiv128;
 364:arch/stm32/mcu_periph/spi_arch.c ****       break;
 365:arch/stm32/mcu_periph/spi_arch.c ****     case SPI_CR1_BAUDRATE_FPCLK_DIV_256:
 366:arch/stm32/mcu_periph/spi_arch.c ****       cdiv = SPIDiv256;
 367:arch/stm32/mcu_periph/spi_arch.c ****       break;
 368:arch/stm32/mcu_periph/spi_arch.c ****     default:
 369:arch/stm32/mcu_periph/spi_arch.c ****       break;
 370:arch/stm32/mcu_periph/spi_arch.c ****   }
 371:arch/stm32/mcu_periph/spi_arch.c ****   sig |= (cdiv << 3);
 372:arch/stm32/mcu_periph/spi_arch.c ****   if (c->dff == SPI_CR1_DFF_8BIT) {
 373:arch/stm32/mcu_periph/spi_arch.c ****     sig |= (SPIDss8bit << 6);
 374:arch/stm32/mcu_periph/spi_arch.c ****   } else {
 375:arch/stm32/mcu_periph/spi_arch.c ****     sig |= (SPIDss16bit << 6);
 376:arch/stm32/mcu_periph/spi_arch.c ****   }
 377:arch/stm32/mcu_periph/spi_arch.c ****   return sig;
 378:arch/stm32/mcu_periph/spi_arch.c **** }
 379:arch/stm32/mcu_periph/spi_arch.c **** 
 380:arch/stm32/mcu_periph/spi_arch.c **** /** Update SPI communication conf from generic paparazzi SPI transaction */
 381:arch/stm32/mcu_periph/spi_arch.c **** static void set_comm_from_transaction(struct locm3_spi_comm* c, struct spi_transaction* t) {
 382:arch/stm32/mcu_periph/spi_arch.c ****   if (t->dss == SPIDss8bit) {
 383:arch/stm32/mcu_periph/spi_arch.c ****     c->dff = SPI_CR1_DFF_8BIT;
 384:arch/stm32/mcu_periph/spi_arch.c ****   } else {
 385:arch/stm32/mcu_periph/spi_arch.c ****     c->dff = SPI_CR1_DFF_16BIT;
 386:arch/stm32/mcu_periph/spi_arch.c ****   }
 387:arch/stm32/mcu_periph/spi_arch.c ****   if (t->bitorder == SPIMSBFirst) {
 388:arch/stm32/mcu_periph/spi_arch.c ****     c->lsbfirst = SPI_CR1_MSBFIRST;
 389:arch/stm32/mcu_periph/spi_arch.c ****   } else {
 390:arch/stm32/mcu_periph/spi_arch.c ****     c->lsbfirst = SPI_CR1_LSBFIRST;
 391:arch/stm32/mcu_periph/spi_arch.c ****   }
 392:arch/stm32/mcu_periph/spi_arch.c ****   if (t->cpha == SPICphaEdge1) {
 393:arch/stm32/mcu_periph/spi_arch.c ****     c->cpha = SPI_CR1_CPHA_CLK_TRANSITION_1;
 394:arch/stm32/mcu_periph/spi_arch.c ****   } else {
 395:arch/stm32/mcu_periph/spi_arch.c ****     c->cpha = SPI_CR1_CPHA_CLK_TRANSITION_2;
 396:arch/stm32/mcu_periph/spi_arch.c ****   }
 397:arch/stm32/mcu_periph/spi_arch.c ****   if (t->cpol == SPICpolIdleLow) {
 398:arch/stm32/mcu_periph/spi_arch.c ****     c->cpol = SPI_CR1_CPOL_CLK_TO_0_WHEN_IDLE;
 399:arch/stm32/mcu_periph/spi_arch.c ****   } else {
 400:arch/stm32/mcu_periph/spi_arch.c ****     c->cpol = SPI_CR1_CPOL_CLK_TO_1_WHEN_IDLE;
 401:arch/stm32/mcu_periph/spi_arch.c ****   }
 402:arch/stm32/mcu_periph/spi_arch.c **** 
 403:arch/stm32/mcu_periph/spi_arch.c ****   switch (t->cdiv) {
 404:arch/stm32/mcu_periph/spi_arch.c ****     case SPIDiv2:
 405:arch/stm32/mcu_periph/spi_arch.c ****       c->br = SPI_CR1_BAUDRATE_FPCLK_DIV_2;
 406:arch/stm32/mcu_periph/spi_arch.c ****       break;
 407:arch/stm32/mcu_periph/spi_arch.c ****     case SPIDiv4:
 408:arch/stm32/mcu_periph/spi_arch.c ****       c->br = SPI_CR1_BAUDRATE_FPCLK_DIV_4;
 409:arch/stm32/mcu_periph/spi_arch.c ****       break;
 410:arch/stm32/mcu_periph/spi_arch.c ****     case SPIDiv8:
 411:arch/stm32/mcu_periph/spi_arch.c ****       c->br = SPI_CR1_BAUDRATE_FPCLK_DIV_8;
 412:arch/stm32/mcu_periph/spi_arch.c ****       break;
 413:arch/stm32/mcu_periph/spi_arch.c ****     case SPIDiv16:
 414:arch/stm32/mcu_periph/spi_arch.c ****       c->br = SPI_CR1_BAUDRATE_FPCLK_DIV_16;
 415:arch/stm32/mcu_periph/spi_arch.c ****       break;
 416:arch/stm32/mcu_periph/spi_arch.c ****     case SPIDiv32:
 417:arch/stm32/mcu_periph/spi_arch.c ****       c->br = SPI_CR1_BAUDRATE_FPCLK_DIV_32;
 418:arch/stm32/mcu_periph/spi_arch.c ****       break;
 419:arch/stm32/mcu_periph/spi_arch.c ****     case SPIDiv64:
 420:arch/stm32/mcu_periph/spi_arch.c ****       c->br = SPI_CR1_BAUDRATE_FPCLK_DIV_64;
 421:arch/stm32/mcu_periph/spi_arch.c ****       break;
 422:arch/stm32/mcu_periph/spi_arch.c ****     case SPIDiv128:
 423:arch/stm32/mcu_periph/spi_arch.c ****       c->br = SPI_CR1_BAUDRATE_FPCLK_DIV_128;
 424:arch/stm32/mcu_periph/spi_arch.c ****       break;
 425:arch/stm32/mcu_periph/spi_arch.c ****     case SPIDiv256:
 426:arch/stm32/mcu_periph/spi_arch.c ****       c->br = SPI_CR1_BAUDRATE_FPCLK_DIV_256;
 427:arch/stm32/mcu_periph/spi_arch.c ****       break;
 428:arch/stm32/mcu_periph/spi_arch.c ****     default:
 429:arch/stm32/mcu_periph/spi_arch.c ****       break;
 430:arch/stm32/mcu_periph/spi_arch.c ****   }
 431:arch/stm32/mcu_periph/spi_arch.c **** }
 432:arch/stm32/mcu_periph/spi_arch.c **** 
 433:arch/stm32/mcu_periph/spi_arch.c **** 
 434:arch/stm32/mcu_periph/spi_arch.c **** /******************************************************************************
 435:arch/stm32/mcu_periph/spi_arch.c ****  *
 436:arch/stm32/mcu_periph/spi_arch.c ****  * Helpers for SPI transactions with DMA
 437:arch/stm32/mcu_periph/spi_arch.c ****  *
 438:arch/stm32/mcu_periph/spi_arch.c ****  *****************************************************************************/
 439:arch/stm32/mcu_periph/spi_arch.c **** static void spi_configure_dma(u32 dma, u8 chan, u32 periph_addr, u32 buf_addr,
 440:arch/stm32/mcu_periph/spi_arch.c ****                               u16 len, enum SPIDataSizeSelect dss, bool_t increment)
 441:arch/stm32/mcu_periph/spi_arch.c **** {
  26              		.loc 1 441 0
  27              		.cfi_startproc
  28              		@ args = 12, pretend = 0, frame = 0
  29              		@ frame_needed = 0, uses_anonymous_args = 0
  30              	.LVL0:
  31 0000 2DE9F047 		push	{r4, r5, r6, r7, r8, r9, sl, lr}
  32              	.LCFI0:
  33              		.cfi_def_cfa_offset 32
  34              		.cfi_offset 4, -32
  35              		.cfi_offset 5, -28
  36              		.cfi_offset 6, -24
  37              		.cfi_offset 7, -20
  38              		.cfi_offset 8, -16
  39              		.cfi_offset 9, -12
  40              		.cfi_offset 10, -8
  41              		.cfi_offset 14, -4
  42              		.loc 1 441 0
  43 0004 0546     		mov	r5, r0
  44 0006 0C46     		mov	r4, r1
  45 0008 9246     		mov	sl, r2
  46 000a 9946     		mov	r9, r3
  47 000c BDF82080 		ldrh	r8, [sp, #32]
  48 0010 9DF82460 		ldrb	r6, [sp, #36]	@ zero_extendqisi2
  49 0014 9DF82870 		ldrb	r7, [sp, #40]	@ zero_extendqisi2
 442:arch/stm32/mcu_periph/spi_arch.c ****   dma_channel_reset(dma, chan);
  50              		.loc 1 442 0
  51 0018 FFF7FEFF 		bl	dma_channel_reset
  52              	.LVL1:
 443:arch/stm32/mcu_periph/spi_arch.c ****   dma_set_peripheral_address(dma, chan, periph_addr);
  53              		.loc 1 443 0
  54 001c 2846     		mov	r0, r5
  55 001e 2146     		mov	r1, r4
  56 0020 5246     		mov	r2, sl
  57 0022 FFF7FEFF 		bl	dma_set_peripheral_address
  58              	.LVL2:
 444:arch/stm32/mcu_periph/spi_arch.c ****   dma_set_memory_address(dma, chan, buf_addr);
  59              		.loc 1 444 0
  60 0026 2846     		mov	r0, r5
  61 0028 2146     		mov	r1, r4
  62 002a 4A46     		mov	r2, r9
  63 002c FFF7FEFF 		bl	dma_set_memory_address
  64              	.LVL3:
 445:arch/stm32/mcu_periph/spi_arch.c ****   dma_set_number_of_data(dma, chan, len);
  65              		.loc 1 445 0
  66 0030 2846     		mov	r0, r5
  67 0032 2146     		mov	r1, r4
  68 0034 4246     		mov	r2, r8
  69 0036 FFF7FEFF 		bl	dma_set_number_of_data
  70              	.LVL4:
 446:arch/stm32/mcu_periph/spi_arch.c **** 
 447:arch/stm32/mcu_periph/spi_arch.c ****   /* Set the dma transfer size based on SPI transaction DSS */
 448:arch/stm32/mcu_periph/spi_arch.c ****   if (dss == SPIDss8bit) {
 449:arch/stm32/mcu_periph/spi_arch.c ****     dma_set_peripheral_size(dma, chan, DMA_CCR_PSIZE_8BIT);
  71              		.loc 1 449 0
  72 003a 2846     		mov	r0, r5
  73 003c 2146     		mov	r1, r4
 448:arch/stm32/mcu_periph/spi_arch.c ****   if (dss == SPIDss8bit) {
  74              		.loc 1 448 0
  75 003e 36B9     		cbnz	r6, .L2
  76              		.loc 1 449 0
  77 0040 3246     		mov	r2, r6
  78 0042 FFF7FEFF 		bl	dma_set_peripheral_size
  79              	.LVL5:
 450:arch/stm32/mcu_periph/spi_arch.c ****     dma_set_memory_size(dma, chan, DMA_CCR_MSIZE_8BIT);
  80              		.loc 1 450 0
  81 0046 2846     		mov	r0, r5
  82 0048 2146     		mov	r1, r4
  83 004a 3246     		mov	r2, r6
  84 004c 07E0     		b	.L5
  85              	.L2:
 451:arch/stm32/mcu_periph/spi_arch.c ****   } else {
 452:arch/stm32/mcu_periph/spi_arch.c ****     dma_set_peripheral_size(dma, chan, DMA_CCR_PSIZE_16BIT);
  86              		.loc 1 452 0
  87 004e 4FF48072 		mov	r2, #256
  88 0052 FFF7FEFF 		bl	dma_set_peripheral_size
  89              	.LVL6:
 453:arch/stm32/mcu_periph/spi_arch.c ****     dma_set_memory_size(dma, chan, DMA_CCR_MSIZE_16BIT);
  90              		.loc 1 453 0
  91 0056 2846     		mov	r0, r5
  92 0058 2146     		mov	r1, r4
  93 005a 4FF48062 		mov	r2, #1024
  94              	.LVL7:
  95              	.L5:
  96 005e FFF7FEFF 		bl	dma_set_memory_size
  97              	.LVL8:
 454:arch/stm32/mcu_periph/spi_arch.c ****   }
 455:arch/stm32/mcu_periph/spi_arch.c **** 
 456:arch/stm32/mcu_periph/spi_arch.c ****   if (increment)
 457:arch/stm32/mcu_periph/spi_arch.c ****     dma_enable_memory_increment_mode(dma, chan);
  98              		.loc 1 457 0
  99 0062 2846     		mov	r0, r5
 100 0064 2146     		mov	r1, r4
 456:arch/stm32/mcu_periph/spi_arch.c ****   if (increment)
 101              		.loc 1 456 0
 102 0066 1FB1     		cbz	r7, .L4
 103              	.LVL9:
 458:arch/stm32/mcu_periph/spi_arch.c ****   else
 459:arch/stm32/mcu_periph/spi_arch.c ****     dma_disable_memory_increment_mode(dma, chan);
 460:arch/stm32/mcu_periph/spi_arch.c **** }
 104              		.loc 1 460 0
 105 0068 BDE8F047 		pop	{r4, r5, r6, r7, r8, r9, sl, lr}
 457:arch/stm32/mcu_periph/spi_arch.c ****     dma_enable_memory_increment_mode(dma, chan);
 106              		.loc 1 457 0
 107 006c FFF7FEBF 		b	dma_enable_memory_increment_mode
 108              	.LVL10:
 109              	.L4:
 110              		.loc 1 460 0
 111 0070 BDE8F047 		pop	{r4, r5, r6, r7, r8, r9, sl, lr}
 459:arch/stm32/mcu_periph/spi_arch.c ****     dma_disable_memory_increment_mode(dma, chan);
 112              		.loc 1 459 0
 113 0074 FFF7FEBF 		b	dma_disable_memory_increment_mode
 114              	.LVL11:
 115              		.cfi_endproc
 116              	.LFE14:
 118              		.section	.text.spi_arch_int_enable,"ax",%progbits
 119              		.align	1
 120              		.thumb
 121              		.thumb_func
 123              	spi_arch_int_enable:
 124              	.LFB15:
 461:arch/stm32/mcu_periph/spi_arch.c **** 
 462:arch/stm32/mcu_periph/spi_arch.c **** /// Enable DMA channel interrupts
 463:arch/stm32/mcu_periph/spi_arch.c **** static void spi_arch_int_enable(struct spi_periph *spi) {
 125              		.loc 1 463 0
 126              		.cfi_startproc
 127              		@ args = 0, pretend = 0, frame = 0
 128              		@ frame_needed = 0, uses_anonymous_args = 0
 129              	.LVL12:
 130 0000 10B5     		push	{r4, lr}
 131              	.LCFI1:
 132              		.cfi_def_cfa_offset 8
 133              		.cfi_offset 4, -8
 134              		.cfi_offset 14, -4
 464:arch/stm32/mcu_periph/spi_arch.c ****   /// @todo fix priority levels if necessary
 465:arch/stm32/mcu_periph/spi_arch.c ****   // enable receive interrupt
 466:arch/stm32/mcu_periph/spi_arch.c ****   nvic_set_priority( ((struct spi_periph_dma *)spi->init_struct)->rx_nvic_irq, 0);
 135              		.loc 1 466 0
 136 0002 C36A     		ldr	r3, [r0, #44]
 463:arch/stm32/mcu_periph/spi_arch.c **** static void spi_arch_int_enable(struct spi_periph *spi) {
 137              		.loc 1 463 0
 138 0004 0446     		mov	r4, r0
 139              		.loc 1 466 0
 140 0006 0021     		movs	r1, #0
 141 0008 987B     		ldrb	r0, [r3, #14]	@ zero_extendqisi2
 142              	.LVL13:
 143 000a FFF7FEFF 		bl	nvic_set_priority
 144              	.LVL14:
 467:arch/stm32/mcu_periph/spi_arch.c ****   nvic_enable_irq( ((struct spi_periph_dma *)spi->init_struct)->rx_nvic_irq );
 145              		.loc 1 467 0
 146 000e E06A     		ldr	r0, [r4, #44]
 147 0010 807B     		ldrb	r0, [r0, #14]	@ zero_extendqisi2
 148 0012 FFF7FEFF 		bl	nvic_enable_irq
 149              	.LVL15:
 468:arch/stm32/mcu_periph/spi_arch.c ****   // enable transmit interrupt
 469:arch/stm32/mcu_periph/spi_arch.c ****   nvic_set_priority( ((struct spi_periph_dma *)spi->init_struct)->tx_nvic_irq, 0);
 150              		.loc 1 469 0
 151 0016 E16A     		ldr	r1, [r4, #44]
 152 0018 C87B     		ldrb	r0, [r1, #15]	@ zero_extendqisi2
 153 001a 0021     		movs	r1, #0
 154 001c FFF7FEFF 		bl	nvic_set_priority
 155              	.LVL16:
 470:arch/stm32/mcu_periph/spi_arch.c ****   nvic_enable_irq( ((struct spi_periph_dma *)spi->init_struct)->tx_nvic_irq );
 156              		.loc 1 470 0
 157 0020 E26A     		ldr	r2, [r4, #44]
 158 0022 D07B     		ldrb	r0, [r2, #15]	@ zero_extendqisi2
 471:arch/stm32/mcu_periph/spi_arch.c **** }
 159              		.loc 1 471 0
 160 0024 BDE81040 		pop	{r4, lr}
 470:arch/stm32/mcu_periph/spi_arch.c ****   nvic_enable_irq( ((struct spi_periph_dma *)spi->init_struct)->tx_nvic_irq );
 161              		.loc 1 470 0
 162 0028 FFF7FEBF 		b	nvic_enable_irq
 163              	.LVL17:
 164              		.cfi_endproc
 165              	.LFE15:
 167              		.section	.text.spi_arch_int_disable,"ax",%progbits
 168              		.align	1
 169              		.thumb
 170              		.thumb_func
 172              	spi_arch_int_disable:
 173              	.LFB16:
 472:arch/stm32/mcu_periph/spi_arch.c **** 
 473:arch/stm32/mcu_periph/spi_arch.c **** /// Disable DMA channel interrupts
 474:arch/stm32/mcu_periph/spi_arch.c **** static void spi_arch_int_disable(struct spi_periph *spi) {
 174              		.loc 1 474 0
 175              		.cfi_startproc
 176              		@ args = 0, pretend = 0, frame = 0
 177              		@ frame_needed = 0, uses_anonymous_args = 0
 178              	.LVL18:
 179 0000 10B5     		push	{r4, lr}
 180              	.LCFI2:
 181              		.cfi_def_cfa_offset 8
 182              		.cfi_offset 4, -8
 183              		.cfi_offset 14, -4
 475:arch/stm32/mcu_periph/spi_arch.c ****   nvic_disable_irq( ((struct spi_periph_dma *)spi->init_struct)->rx_nvic_irq );
 184              		.loc 1 475 0
 185 0002 C36A     		ldr	r3, [r0, #44]
 474:arch/stm32/mcu_periph/spi_arch.c **** static void spi_arch_int_disable(struct spi_periph *spi) {
 186              		.loc 1 474 0
 187 0004 0446     		mov	r4, r0
 188              		.loc 1 475 0
 189 0006 987B     		ldrb	r0, [r3, #14]	@ zero_extendqisi2
 190              	.LVL19:
 191 0008 FFF7FEFF 		bl	nvic_disable_irq
 192              	.LVL20:
 476:arch/stm32/mcu_periph/spi_arch.c ****   nvic_disable_irq( ((struct spi_periph_dma *)spi->init_struct)->tx_nvic_irq );
 193              		.loc 1 476 0
 194 000c E06A     		ldr	r0, [r4, #44]
 195 000e C07B     		ldrb	r0, [r0, #15]	@ zero_extendqisi2
 477:arch/stm32/mcu_periph/spi_arch.c **** }
 196              		.loc 1 477 0
 197 0010 BDE81040 		pop	{r4, lr}
 476:arch/stm32/mcu_periph/spi_arch.c ****   nvic_disable_irq( ((struct spi_periph_dma *)spi->init_struct)->tx_nvic_irq );
 198              		.loc 1 476 0
 199 0014 FFF7FEBF 		b	nvic_disable_irq
 200              	.LVL21:
 201              		.cfi_endproc
 202              	.LFE16:
 204              		.section	.text.spi_start_dma_transaction,"ax",%progbits
 205              		.align	1
 206              		.thumb
 207              		.thumb_func
 209              	spi_start_dma_transaction:
 210              	.LFB18:
 478:arch/stm32/mcu_periph/spi_arch.c **** 
 479:arch/stm32/mcu_periph/spi_arch.c **** /// start next transaction if there is one in the queue
 480:arch/stm32/mcu_periph/spi_arch.c **** static void spi_next_transaction(struct spi_periph* periph) {
 481:arch/stm32/mcu_periph/spi_arch.c ****   /* Increment the transaction to handle */
 482:arch/stm32/mcu_periph/spi_arch.c ****   periph->trans_extract_idx++;
 483:arch/stm32/mcu_periph/spi_arch.c **** 
 484:arch/stm32/mcu_periph/spi_arch.c ****   /* wrap read index of circular buffer */
 485:arch/stm32/mcu_periph/spi_arch.c ****   if (periph->trans_extract_idx >= SPI_TRANSACTION_QUEUE_LEN)
 486:arch/stm32/mcu_periph/spi_arch.c ****     periph->trans_extract_idx = 0;
 487:arch/stm32/mcu_periph/spi_arch.c **** 
 488:arch/stm32/mcu_periph/spi_arch.c ****   /* Check if there is another pending SPI transaction */
 489:arch/stm32/mcu_periph/spi_arch.c ****   if ((periph->trans_extract_idx == periph->trans_insert_idx) || periph->suspend)
 490:arch/stm32/mcu_periph/spi_arch.c ****     periph->status = SPIIdle;
 491:arch/stm32/mcu_periph/spi_arch.c ****   else
 492:arch/stm32/mcu_periph/spi_arch.c ****     spi_start_dma_transaction(periph, periph->trans[periph->trans_extract_idx]);
 493:arch/stm32/mcu_periph/spi_arch.c **** }
 494:arch/stm32/mcu_periph/spi_arch.c **** 
 495:arch/stm32/mcu_periph/spi_arch.c **** 
 496:arch/stm32/mcu_periph/spi_arch.c **** /**
 497:arch/stm32/mcu_periph/spi_arch.c ****  * Start a new transaction with DMA.
 498:arch/stm32/mcu_periph/spi_arch.c ****  */
 499:arch/stm32/mcu_periph/spi_arch.c **** static void spi_start_dma_transaction(struct spi_periph* periph, struct spi_transaction* trans)
 500:arch/stm32/mcu_periph/spi_arch.c **** {
 211              		.loc 1 500 0
 212              		.cfi_startproc
 213              		@ args = 0, pretend = 0, frame = 0
 214              		@ frame_needed = 0, uses_anonymous_args = 0
 215              	.LVL22:
 501:arch/stm32/mcu_periph/spi_arch.c ****   struct spi_periph_dma *dma;
 502:arch/stm32/mcu_periph/spi_arch.c ****   uint8_t sig = 0x00;
 503:arch/stm32/mcu_periph/spi_arch.c **** 
 504:arch/stm32/mcu_periph/spi_arch.c ****   /* Store local copy to notify of the results */
 505:arch/stm32/mcu_periph/spi_arch.c ****   trans->status = SPITransRunning;
 216              		.loc 1 505 0
 217 0000 0123     		movs	r3, #1
 500:arch/stm32/mcu_periph/spi_arch.c **** {
 218              		.loc 1 500 0
 219 0002 F0B5     		push	{r4, r5, r6, r7, lr}
 220              	.LCFI3:
 221              		.cfi_def_cfa_offset 20
 222              		.cfi_offset 4, -20
 223              		.cfi_offset 5, -16
 224              		.cfi_offset 6, -12
 225              		.cfi_offset 7, -8
 226              		.cfi_offset 14, -4
 227              		.loc 1 505 0
 228 0004 0B77     		strb	r3, [r1, #28]
 506:arch/stm32/mcu_periph/spi_arch.c ****   periph->status = SPIRunning;
 229              		.loc 1 506 0
 230 0006 80F82230 		strb	r3, [r0, #34]
 231              	.LBB12:
 232              	.LBB13:
 321:arch/stm32/mcu_periph/spi_arch.c ****   return ((t->dss << 6) | (t->cdiv << 3) | (t->bitorder << 2) |
 233              		.loc 1 321 0
 234 000a 0B7C     		ldrb	r3, [r1, #16]	@ zero_extendqisi2
 235              	.LBE13:
 236              	.LBE12:
 500:arch/stm32/mcu_periph/spi_arch.c **** {
 237              		.loc 1 500 0
 238 000c 0D46     		mov	r5, r1
 239              	.LBB18:
 240              	.LBB14:
 321:arch/stm32/mcu_periph/spi_arch.c ****   return ((t->dss << 6) | (t->cdiv << 3) | (t->bitorder << 2) |
 241              		.loc 1 321 0
 242 000e 8F7B     		ldrb	r7, [r1, #14]	@ zero_extendqisi2
 243 0010 4FEAC30E 		lsl	lr, r3, #3
 322:arch/stm32/mcu_periph/spi_arch.c ****           (t->cpha << 1) | (t->cpol));
 244              		.loc 1 322 0
 245 0014 2A7B     		ldrb	r2, [r5, #12]	@ zero_extendqisi2
 246              	.LBE14:
 247              	.LBE18:
 507:arch/stm32/mcu_periph/spi_arch.c **** 
 508:arch/stm32/mcu_periph/spi_arch.c ****   dma = periph->init_struct;
 248              		.loc 1 508 0
 249 0016 C46A     		ldr	r4, [r0, #44]
 250              	.LVL23:
 251              	.LBB19:
 252              	.LBB15:
 321:arch/stm32/mcu_periph/spi_arch.c ****   return ((t->dss << 6) | (t->cdiv << 3) | (t->bitorder << 2) |
 253              		.loc 1 321 0
 254 0018 4EEA871C 		orr	ip, lr, r7, lsl #6
 255              	.LBE15:
 256              	.LBE19:
 500:arch/stm32/mcu_periph/spi_arch.c **** {
 257              		.loc 1 500 0
 258 001c 0646     		mov	r6, r0
 259              	.LBB20:
 260              	.LBB16:
 321:arch/stm32/mcu_periph/spi_arch.c ****   return ((t->dss << 6) | (t->cdiv << 3) | (t->bitorder << 2) |
 261              		.loc 1 321 0
 262 001e C87B     		ldrb	r0, [r1, #15]	@ zero_extendqisi2
 263              	.LVL24:
 264 0020 4CEA020E 		orr	lr, ip, r2
 322:arch/stm32/mcu_periph/spi_arch.c ****           (t->cpha << 1) | (t->cpol));
 265              		.loc 1 322 0
 266 0024 497B     		ldrb	r1, [r1, #13]	@ zero_extendqisi2
 267              	.LVL25:
 321:arch/stm32/mcu_periph/spi_arch.c ****   return ((t->dss << 6) | (t->cdiv << 3) | (t->bitorder << 2) |
 268              		.loc 1 321 0
 269 0026 4EEA800C 		orr	ip, lr, r0, lsl #2
 270 002a 4CEA410E 		orr	lr, ip, r1, lsl #1
 271              	.LBE16:
 272              	.LBE20:
 509:arch/stm32/mcu_periph/spi_arch.c **** 
 510:arch/stm32/mcu_periph/spi_arch.c ****   /*
 511:arch/stm32/mcu_periph/spi_arch.c ****    * Check if we need to reconfigure the spi peripheral for this transaction
 512:arch/stm32/mcu_periph/spi_arch.c ****    */
 513:arch/stm32/mcu_periph/spi_arch.c ****   sig = get_transaction_signature(trans);
 514:arch/stm32/mcu_periph/spi_arch.c ****   if (sig != dma->comm_sig) {
 273              		.loc 1 514 0
 274 002e 94F82CC0 		ldrb	ip, [r4, #44]	@ zero_extendqisi2
 275              	.LBB21:
 276              	.LBB17:
 321:arch/stm32/mcu_periph/spi_arch.c ****   return ((t->dss << 6) | (t->cdiv << 3) | (t->bitorder << 2) |
 277              		.loc 1 321 0
 278 0032 5FFA8EFE 		uxtb	lr, lr
 279              	.LVL26:
 280              	.LBE17:
 281              	.LBE21:
 282              		.loc 1 514 0
 283 0036 F445     		cmp	ip, lr
 500:arch/stm32/mcu_periph/spi_arch.c **** {
 284              		.loc 1 500 0
 285 0038 85B0     		sub	sp, sp, #20
 286              	.LCFI4:
 287              		.cfi_def_cfa_offset 40
 288              		.loc 1 514 0
 289 003a 3CD0     		beq	.L10
 290              	.LVL27:
 291              	.LBB22:
 292              	.LBB23:
 382:arch/stm32/mcu_periph/spi_arch.c ****   if (t->dss == SPIDss8bit) {
 293              		.loc 1 382 0
 294 003c 0FB1     		cbz	r7, .L39
 295              	.L11:
 385:arch/stm32/mcu_periph/spi_arch.c ****     c->dff = SPI_CR1_DFF_16BIT;
 296              		.loc 1 385 0
 297 003e 4FF40067 		mov	r7, #2048
 298              	.L39:
 299 0042 6762     		str	r7, [r4, #36]
 387:arch/stm32/mcu_periph/spi_arch.c ****   if (t->bitorder == SPIMSBFirst) {
 300              		.loc 1 387 0
 301 0044 00B1     		cbz	r0, .L40
 302              	.L13:
 390:arch/stm32/mcu_periph/spi_arch.c ****     c->lsbfirst = SPI_CR1_LSBFIRST;
 303              		.loc 1 390 0
 304 0046 8020     		movs	r0, #128
 305              	.L40:
 306 0048 A062     		str	r0, [r4, #40]
 392:arch/stm32/mcu_periph/spi_arch.c ****   if (t->cpha == SPICphaEdge1) {
 307              		.loc 1 392 0
 308 004a 01B1     		cbz	r1, .L41
 309              	.L15:
 395:arch/stm32/mcu_periph/spi_arch.c ****     c->cpha = SPI_CR1_CPHA_CLK_TRANSITION_2;
 310              		.loc 1 395 0
 311 004c 0121     		movs	r1, #1
 312              	.L41:
 313 004e 2162     		str	r1, [r4, #32]
 397:arch/stm32/mcu_periph/spi_arch.c ****   if (t->cpol == SPICpolIdleLow) {
 314              		.loc 1 397 0
 315 0050 02B1     		cbz	r2, .L42
 316              	.L17:
 400:arch/stm32/mcu_periph/spi_arch.c ****     c->cpol = SPI_CR1_CPOL_CLK_TO_1_WHEN_IDLE;
 317              		.loc 1 400 0
 318 0052 0222     		movs	r2, #2
 319              	.L42:
 320 0054 E261     		str	r2, [r4, #28]
 403:arch/stm32/mcu_periph/spi_arch.c ****   switch (t->cdiv) {
 321              		.loc 1 403 0
 322 0056 072B     		cmp	r3, #7
 323 0058 15D8     		bhi	.L19
 324 005a DFE803F0 		tbb	[pc, r3]
 325              	.L28:
 326 005e 04       		.byte	(.L20-.L28)/2
 327 005f 06       		.byte	(.L21-.L28)/2
 328 0060 08       		.byte	(.L22-.L28)/2
 329 0061 0A       		.byte	(.L23-.L28)/2
 330 0062 0C       		.byte	(.L24-.L28)/2
 331 0063 0E       		.byte	(.L25-.L28)/2
 332 0064 10       		.byte	(.L26-.L28)/2
 333 0065 12       		.byte	(.L27-.L28)/2
 334              		.align	1
 335              	.L20:
 405:arch/stm32/mcu_periph/spi_arch.c ****       c->br = SPI_CR1_BAUDRATE_FPCLK_DIV_2;
 336              		.loc 1 405 0
 337 0066 0023     		movs	r3, #0
 338 0068 0CE0     		b	.L43
 339              	.L21:
 408:arch/stm32/mcu_periph/spi_arch.c ****       c->br = SPI_CR1_BAUDRATE_FPCLK_DIV_4;
 340              		.loc 1 408 0
 341 006a 0823     		movs	r3, #8
 342 006c 0AE0     		b	.L43
 343              	.L22:
 411:arch/stm32/mcu_periph/spi_arch.c ****       c->br = SPI_CR1_BAUDRATE_FPCLK_DIV_8;
 344              		.loc 1 411 0
 345 006e 1023     		movs	r3, #16
 346 0070 08E0     		b	.L43
 347              	.L23:
 414:arch/stm32/mcu_periph/spi_arch.c ****       c->br = SPI_CR1_BAUDRATE_FPCLK_DIV_16;
 348              		.loc 1 414 0
 349 0072 1823     		movs	r3, #24
 350 0074 06E0     		b	.L43
 351              	.L24:
 417:arch/stm32/mcu_periph/spi_arch.c ****       c->br = SPI_CR1_BAUDRATE_FPCLK_DIV_32;
 352              		.loc 1 417 0
 353 0076 2023     		movs	r3, #32
 354 0078 04E0     		b	.L43
 355              	.L25:
 420:arch/stm32/mcu_periph/spi_arch.c ****       c->br = SPI_CR1_BAUDRATE_FPCLK_DIV_64;
 356              		.loc 1 420 0
 357 007a 2823     		movs	r3, #40
 358 007c 02E0     		b	.L43
 359              	.L26:
 423:arch/stm32/mcu_periph/spi_arch.c ****       c->br = SPI_CR1_BAUDRATE_FPCLK_DIV_128;
 360              		.loc 1 423 0
 361 007e 3023     		movs	r3, #48
 362 0080 00E0     		b	.L43
 363              	.L27:
 426:arch/stm32/mcu_periph/spi_arch.c ****       c->br = SPI_CR1_BAUDRATE_FPCLK_DIV_256;
 364              		.loc 1 426 0
 365 0082 3823     		movs	r3, #56
 366              	.L43:
 367 0084 A361     		str	r3, [r4, #24]
 368              	.L19:
 369              	.LBE23:
 370              	.LBE22:
 515:arch/stm32/mcu_periph/spi_arch.c ****     /* A different config is required in this transaction... */
 516:arch/stm32/mcu_periph/spi_arch.c ****     set_comm_from_transaction(&(dma->comm), trans);
 517:arch/stm32/mcu_periph/spi_arch.c **** 
 518:arch/stm32/mcu_periph/spi_arch.c ****     /* remember the new conf signature */
 519:arch/stm32/mcu_periph/spi_arch.c ****     dma->comm_sig = sig;
 371              		.loc 1 519 0
 372 0086 84F82CE0 		strb	lr, [r4, #44]
 520:arch/stm32/mcu_periph/spi_arch.c **** 
 521:arch/stm32/mcu_periph/spi_arch.c ****     /* apply the new configuration */
 522:arch/stm32/mcu_periph/spi_arch.c ****     spi_disable((u32)periph->reg_addr);
 373              		.loc 1 522 0
 374 008a B06A     		ldr	r0, [r6, #40]
 375 008c FFF7FEFF 		bl	spi_disable
 376              	.LVL28:
 523:arch/stm32/mcu_periph/spi_arch.c ****     spi_init_master((u32)periph->reg_addr, dma->comm.br, dma->comm.cpol,
 377              		.loc 1 523 0
 378 0090 606A     		ldr	r0, [r4, #36]
 379 0092 04F11802 		add	r2, r4, #24
 380 0096 0090     		str	r0, [sp, #0]
 381 0098 A16A     		ldr	r1, [r4, #40]
 382 009a B06A     		ldr	r0, [r6, #40]
 383 009c 0191     		str	r1, [sp, #4]
 384 009e 0ECA     		ldmia	r2, {r1, r2, r3}
 385 00a0 FFF7FEFF 		bl	spi_init_master
 386              	.LVL29:
 524:arch/stm32/mcu_periph/spi_arch.c ****                     dma->comm.cpha, dma->comm.dff, dma->comm.lsbfirst);
 525:arch/stm32/mcu_periph/spi_arch.c ****     spi_enable_software_slave_management((u32)periph->reg_addr);
 387              		.loc 1 525 0
 388 00a4 B06A     		ldr	r0, [r6, #40]
 389 00a6 FFF7FEFF 		bl	spi_enable_software_slave_management
 390              	.LVL30:
 526:arch/stm32/mcu_periph/spi_arch.c ****     spi_set_nss_high((u32)periph->reg_addr);
 391              		.loc 1 526 0
 392 00aa B06A     		ldr	r0, [r6, #40]
 393 00ac FFF7FEFF 		bl	spi_set_nss_high
 394              	.LVL31:
 527:arch/stm32/mcu_periph/spi_arch.c ****     spi_enable((u32)periph->reg_addr);
 395              		.loc 1 527 0
 396 00b0 B06A     		ldr	r0, [r6, #40]
 397 00b2 FFF7FEFF 		bl	spi_enable
 398              	.LVL32:
 399              	.L10:
 528:arch/stm32/mcu_periph/spi_arch.c ****   }
 529:arch/stm32/mcu_periph/spi_arch.c **** 
 530:arch/stm32/mcu_periph/spi_arch.c ****   /*
 531:arch/stm32/mcu_periph/spi_arch.c ****    * Select the slave after reconfiguration of the peripheral
 532:arch/stm32/mcu_periph/spi_arch.c ****    */
 533:arch/stm32/mcu_periph/spi_arch.c ****   if (trans->select == SPISelectUnselect || trans->select == SPISelect) {
 400              		.loc 1 533 0
 401 00b6 EB7A     		ldrb	r3, [r5, #11]	@ zero_extendqisi2
 402 00b8 012B     		cmp	r3, #1
 403 00ba 07D8     		bhi	.L29
 404              	.LVL33:
 405              	.LBB24:
 406              	.LBB25:
 167:arch/stm32/mcu_periph/spi_arch.c ****   switch(slave) {
 407              		.loc 1 167 0
 408 00bc A87A     		ldrb	r0, [r5, #10]	@ zero_extendqisi2
 409 00be 0228     		cmp	r0, #2
 410 00c0 04D1     		bne	.L29
 411              	.LBB26:
 412              	.LBB27:
 180:arch/stm32/mcu_periph/spi_arch.c ****       gpio_clear(SPI_SELECT_SLAVE2_PORT, SPI_SELECT_SLAVE2_PIN);
 413              		.loc 1 180 0
 414 00c2 3948     		ldr	r0, .L44
 415 00c4 4FF48051 		mov	r1, #4096
 416 00c8 FFF7FEFF 		bl	gpio_clear
 417              	.LVL34:
 418              	.L29:
 419              	.LBE27:
 420              	.LBE26:
 421              	.LBE25:
 422              	.LBE24:
 534:arch/stm32/mcu_periph/spi_arch.c ****     SpiSlaveSelect(trans->slave_idx);
 535:arch/stm32/mcu_periph/spi_arch.c ****   }
 536:arch/stm32/mcu_periph/spi_arch.c **** 
 537:arch/stm32/mcu_periph/spi_arch.c ****   /* Run the callback AFTER selecting the slave */
 538:arch/stm32/mcu_periph/spi_arch.c ****   if (trans->before_cb != 0) {
 423              		.loc 1 538 0
 424 00cc 6969     		ldr	r1, [r5, #20]
 425 00ce 09B1     		cbz	r1, .L31
 539:arch/stm32/mcu_periph/spi_arch.c ****     trans->before_cb(trans);
 426              		.loc 1 539 0
 427 00d0 2846     		mov	r0, r5
 428 00d2 8847     		blx	r1
 429              	.LVL35:
 430              	.L31:
 540:arch/stm32/mcu_periph/spi_arch.c ****   }
 541:arch/stm32/mcu_periph/spi_arch.c **** 
 542:arch/stm32/mcu_periph/spi_arch.c ****   /*
 543:arch/stm32/mcu_periph/spi_arch.c ****    * Receive DMA channel configuration ----------------------------------------
 544:arch/stm32/mcu_periph/spi_arch.c ****    *
 545:arch/stm32/mcu_periph/spi_arch.c ****    * We always run the receive DMA until the very end!
 546:arch/stm32/mcu_periph/spi_arch.c ****    * This is done so we can use the transfer complete interrupt
 547:arch/stm32/mcu_periph/spi_arch.c ****    * of the RX DMA to signal the end of the transaction.
 548:arch/stm32/mcu_periph/spi_arch.c ****    *
 549:arch/stm32/mcu_periph/spi_arch.c ****    * If we want to receive less than we transmit, a dummy buffer
 550:arch/stm32/mcu_periph/spi_arch.c ****    * for the rx DMA is used after for the remaining data.
 551:arch/stm32/mcu_periph/spi_arch.c ****    *
 552:arch/stm32/mcu_periph/spi_arch.c ****    * In the transmit only case (input_length == 0),
 553:arch/stm32/mcu_periph/spi_arch.c ****    * the dummy is used right from the start.
 554:arch/stm32/mcu_periph/spi_arch.c ****    */
 555:arch/stm32/mcu_periph/spi_arch.c ****   if (trans->input_length == 0) {
 431              		.loc 1 555 0
 432 00d4 2B7A     		ldrb	r3, [r5, #8]	@ zero_extendqisi2
 433 00d6 217B     		ldrb	r1, [r4, #12]	@ zero_extendqisi2
 434 00d8 5BB9     		cbnz	r3, .L32
 556:arch/stm32/mcu_periph/spi_arch.c ****     /* run the dummy rx dma for the complete transaction length */
 557:arch/stm32/mcu_periph/spi_arch.c ****     spi_configure_dma(dma->dma, dma->rx_chan, (u32)dma->spidr,
 435              		.loc 1 557 0
 436 00da 6A7A     		ldrb	r2, [r5, #9]	@ zero_extendqisi2
 437 00dc A87B     		ldrb	r0, [r5, #14]	@ zero_extendqisi2
 438 00de 0293     		str	r3, [sp, #8]
 439 00e0 0092     		str	r2, [sp, #0]
 440 00e2 0190     		str	r0, [sp, #4]
 441 00e4 A068     		ldr	r0, [r4, #8]
 442 00e6 6268     		ldr	r2, [r4, #4]
 443 00e8 04F11403 		add	r3, r4, #20
 444 00ec FFF7FEFF 		bl	spi_configure_dma
 445              	.LVL36:
 446 00f0 0EE0     		b	.L33
 447              	.L32:
 558:arch/stm32/mcu_periph/spi_arch.c ****                       (u32)&(dma->rx_dummy_buf), trans->output_length, trans->dss, FALSE);
 559:arch/stm32/mcu_periph/spi_arch.c ****   } else {
 560:arch/stm32/mcu_periph/spi_arch.c ****     /* run the real rx dma for input_length */
 561:arch/stm32/mcu_periph/spi_arch.c ****     spi_configure_dma(dma->dma, dma->rx_chan, (u32)dma->spidr,
 448              		.loc 1 561 0
 449 00f2 AF7B     		ldrb	r7, [r5, #14]	@ zero_extendqisi2
 450 00f4 0093     		str	r3, [sp, #0]
 451 00f6 0197     		str	r7, [sp, #4]
 452 00f8 0127     		movs	r7, #1
 453 00fa 0297     		str	r7, [sp, #8]
 454 00fc A068     		ldr	r0, [r4, #8]
 455 00fe 6268     		ldr	r2, [r4, #4]
 456 0100 2B68     		ldr	r3, [r5, #0]
 457 0102 FFF7FEFF 		bl	spi_configure_dma
 458              	.LVL37:
 562:arch/stm32/mcu_periph/spi_arch.c ****                       (u32)trans->input_buf, trans->input_length, trans->dss, TRUE);
 563:arch/stm32/mcu_periph/spi_arch.c ****     /* use dummy rx dma for the rest */
 564:arch/stm32/mcu_periph/spi_arch.c ****     if (trans->output_length > trans->input_length) {
 459              		.loc 1 564 0
 460 0106 6A7A     		ldrb	r2, [r5, #9]	@ zero_extendqisi2
 461 0108 287A     		ldrb	r0, [r5, #8]	@ zero_extendqisi2
 462 010a 8242     		cmp	r2, r0
 565:arch/stm32/mcu_periph/spi_arch.c ****       /* Enable use of second dma transfer with dummy buffer (cleared in ISR) */
 566:arch/stm32/mcu_periph/spi_arch.c ****       dma->rx_extra_dummy_dma = TRUE;
 463              		.loc 1 566 0
 464 010c 88BF     		it	hi
 465 010e A775     		strbhi	r7, [r4, #22]
 466              	.L33:
 567:arch/stm32/mcu_periph/spi_arch.c ****     }
 568:arch/stm32/mcu_periph/spi_arch.c ****   }
 569:arch/stm32/mcu_periph/spi_arch.c ****   dma_set_read_from_peripheral(dma->dma, dma->rx_chan);
 467              		.loc 1 569 0
 468 0110 A068     		ldr	r0, [r4, #8]
 469 0112 217B     		ldrb	r1, [r4, #12]	@ zero_extendqisi2
 470 0114 FFF7FEFF 		bl	dma_set_read_from_peripheral
 471              	.LVL38:
 570:arch/stm32/mcu_periph/spi_arch.c ****   dma_set_priority(dma->dma, dma->rx_chan, DMA_CCR_PL_VERY_HIGH);
 472              		.loc 1 570 0
 473 0118 217B     		ldrb	r1, [r4, #12]	@ zero_extendqisi2
 474 011a A068     		ldr	r0, [r4, #8]
 475 011c 4FF44052 		mov	r2, #12288
 476 0120 FFF7FEFF 		bl	dma_set_priority
 477              	.LVL39:
 571:arch/stm32/mcu_periph/spi_arch.c **** 
 572:arch/stm32/mcu_periph/spi_arch.c **** 
 573:arch/stm32/mcu_periph/spi_arch.c ****   /*
 574:arch/stm32/mcu_periph/spi_arch.c ****    * Transmit DMA channel configuration ---------------------------------------
 575:arch/stm32/mcu_periph/spi_arch.c ****    *
 576:arch/stm32/mcu_periph/spi_arch.c ****    * We always run the transmit DMA!
 577:arch/stm32/mcu_periph/spi_arch.c ****    * To receive data, the clock must run, so something has to be transmitted.
 578:arch/stm32/mcu_periph/spi_arch.c ****    * If needed, use a dummy DMA transmitting zeros for the remaining length.
 579:arch/stm32/mcu_periph/spi_arch.c ****    *
 580:arch/stm32/mcu_periph/spi_arch.c ****    * In the reveive only case (output_length == 0),
 581:arch/stm32/mcu_periph/spi_arch.c ****    * the dummy is used right from the start.
 582:arch/stm32/mcu_periph/spi_arch.c ****    */
 583:arch/stm32/mcu_periph/spi_arch.c ****   if (trans->output_length == 0) {
 478              		.loc 1 583 0
 479 0124 6B7A     		ldrb	r3, [r5, #9]	@ zero_extendqisi2
 480 0126 617B     		ldrb	r1, [r4, #13]	@ zero_extendqisi2
 481 0128 5BB9     		cbnz	r3, .L34
 584:arch/stm32/mcu_periph/spi_arch.c ****     spi_configure_dma(dma->dma, dma->tx_chan, (u32)dma->spidr,
 482              		.loc 1 584 0
 483 012a 287A     		ldrb	r0, [r5, #8]	@ zero_extendqisi2
 484 012c AA7B     		ldrb	r2, [r5, #14]	@ zero_extendqisi2
 485 012e 0293     		str	r3, [sp, #8]
 486 0130 0090     		str	r0, [sp, #0]
 487 0132 0192     		str	r2, [sp, #4]
 488 0134 A068     		ldr	r0, [r4, #8]
 489 0136 6268     		ldr	r2, [r4, #4]
 490 0138 04F11003 		add	r3, r4, #16
 491 013c FFF7FEFF 		bl	spi_configure_dma
 492              	.LVL40:
 493 0140 0EE0     		b	.L35
 494              	.L34:
 585:arch/stm32/mcu_periph/spi_arch.c ****                       (u32)&(dma->tx_dummy_buf), trans->input_length, trans->dss, FALSE);
 586:arch/stm32/mcu_periph/spi_arch.c ****   } else {
 587:arch/stm32/mcu_periph/spi_arch.c ****     spi_configure_dma(dma->dma, dma->tx_chan, (u32)dma->spidr,
 495              		.loc 1 587 0
 496 0142 AF7B     		ldrb	r7, [r5, #14]	@ zero_extendqisi2
 497 0144 0093     		str	r3, [sp, #0]
 498 0146 0197     		str	r7, [sp, #4]
 499 0148 0127     		movs	r7, #1
 500 014a 0297     		str	r7, [sp, #8]
 501 014c 6268     		ldr	r2, [r4, #4]
 502 014e A068     		ldr	r0, [r4, #8]
 503 0150 6B68     		ldr	r3, [r5, #4]
 504 0152 FFF7FEFF 		bl	spi_configure_dma
 505              	.LVL41:
 588:arch/stm32/mcu_periph/spi_arch.c ****                       (u32)trans->output_buf, trans->output_length, trans->dss, TRUE);
 589:arch/stm32/mcu_periph/spi_arch.c ****     if (trans->input_length > trans->output_length) {
 506              		.loc 1 589 0
 507 0156 297A     		ldrb	r1, [r5, #8]	@ zero_extendqisi2
 508 0158 6A7A     		ldrb	r2, [r5, #9]	@ zero_extendqisi2
 509 015a 9142     		cmp	r1, r2
 590:arch/stm32/mcu_periph/spi_arch.c ****       /* Enable use of second dma transfer with dummy buffer (cleared in ISR) */
 591:arch/stm32/mcu_periph/spi_arch.c ****       dma->tx_extra_dummy_dma = TRUE;
 510              		.loc 1 591 0
 511 015c 88BF     		it	hi
 512 015e A774     		strbhi	r7, [r4, #18]
 513              	.L35:
 592:arch/stm32/mcu_periph/spi_arch.c ****     }
 593:arch/stm32/mcu_periph/spi_arch.c ****   }
 594:arch/stm32/mcu_periph/spi_arch.c ****   dma_set_read_from_memory(dma->dma, dma->tx_chan);
 514              		.loc 1 594 0
 515 0160 A068     		ldr	r0, [r4, #8]
 516 0162 617B     		ldrb	r1, [r4, #13]	@ zero_extendqisi2
 517 0164 FFF7FEFF 		bl	dma_set_read_from_memory
 518              	.LVL42:
 595:arch/stm32/mcu_periph/spi_arch.c ****   dma_set_priority(dma->dma, dma->tx_chan, DMA_CCR_PL_MEDIUM);
 519              		.loc 1 595 0
 520 0168 4FF48052 		mov	r2, #4096
 521 016c A068     		ldr	r0, [r4, #8]
 522 016e 617B     		ldrb	r1, [r4, #13]	@ zero_extendqisi2
 523 0170 FFF7FEFF 		bl	dma_set_priority
 524              	.LVL43:
 596:arch/stm32/mcu_periph/spi_arch.c **** 
 597:arch/stm32/mcu_periph/spi_arch.c **** 
 598:arch/stm32/mcu_periph/spi_arch.c ****   /* Enable DMA transfer complete interrupts. */
 599:arch/stm32/mcu_periph/spi_arch.c ****   dma_enable_transfer_complete_interrupt(dma->dma, dma->rx_chan);
 525              		.loc 1 599 0
 526 0174 A068     		ldr	r0, [r4, #8]
 527 0176 217B     		ldrb	r1, [r4, #12]	@ zero_extendqisi2
 528 0178 FFF7FEFF 		bl	dma_enable_transfer_complete_interrupt
 529              	.LVL44:
 600:arch/stm32/mcu_periph/spi_arch.c ****   dma_enable_transfer_complete_interrupt(dma->dma, dma->tx_chan);
 530              		.loc 1 600 0
 531 017c A068     		ldr	r0, [r4, #8]
 532 017e 617B     		ldrb	r1, [r4, #13]	@ zero_extendqisi2
 533 0180 FFF7FEFF 		bl	dma_enable_transfer_complete_interrupt
 534              	.LVL45:
 601:arch/stm32/mcu_periph/spi_arch.c **** 
 602:arch/stm32/mcu_periph/spi_arch.c ****   /* Enable DMA channels */
 603:arch/stm32/mcu_periph/spi_arch.c ****   dma_enable_channel(dma->dma, dma->rx_chan);
 535              		.loc 1 603 0
 536 0184 A068     		ldr	r0, [r4, #8]
 537 0186 217B     		ldrb	r1, [r4, #12]	@ zero_extendqisi2
 538 0188 FFF7FEFF 		bl	dma_enable_channel
 539              	.LVL46:
 604:arch/stm32/mcu_periph/spi_arch.c ****   dma_enable_channel(dma->dma, dma->tx_chan);
 540              		.loc 1 604 0
 541 018c A068     		ldr	r0, [r4, #8]
 542 018e 617B     		ldrb	r1, [r4, #13]	@ zero_extendqisi2
 543 0190 FFF7FEFF 		bl	dma_enable_channel
 544              	.LVL47:
 605:arch/stm32/mcu_periph/spi_arch.c **** 
 606:arch/stm32/mcu_periph/spi_arch.c ****   /* Enable SPI transfers via DMA */
 607:arch/stm32/mcu_periph/spi_arch.c ****   spi_enable_rx_dma((u32)periph->reg_addr);
 545              		.loc 1 607 0
 546 0194 B06A     		ldr	r0, [r6, #40]
 547 0196 FFF7FEFF 		bl	spi_enable_rx_dma
 548              	.LVL48:
 608:arch/stm32/mcu_periph/spi_arch.c ****   spi_enable_tx_dma((u32)periph->reg_addr);
 549              		.loc 1 608 0
 550 019a B06A     		ldr	r0, [r6, #40]
 609:arch/stm32/mcu_periph/spi_arch.c **** }
 551              		.loc 1 609 0
 552 019c 05B0     		add	sp, sp, #20
 553 019e BDE8F040 		pop	{r4, r5, r6, r7, lr}
 608:arch/stm32/mcu_periph/spi_arch.c ****   spi_enable_tx_dma((u32)periph->reg_addr);
 554              		.loc 1 608 0
 555 01a2 FFF7FEBF 		b	spi_enable_tx_dma
 556              	.LVL49:
 557              	.L45:
 558 01a6 00BF     		.align	2
 559              	.L44:
 560 01a8 000C0140 		.word	1073810432
 561              		.cfi_endproc
 562              	.LFE18:
 564              		.section	.text.spi_slave_select,"ax",%progbits
 565              		.align	1
 566              		.global	spi_slave_select
 567              		.thumb
 568              		.thumb_func
 570              	spi_slave_select:
 571              	.LFB4:
 203:arch/stm32/mcu_periph/spi_arch.c **** void spi_slave_select(uint8_t slave) {
 572              		.loc 1 203 0
 573              		.cfi_startproc
 574              		@ args = 0, pretend = 0, frame = 0
 575              		@ frame_needed = 0, uses_anonymous_args = 0
 576              		@ link register save eliminated.
 577              	.LVL50:
 578              	.LBB32:
 579              	.LBB33:
 167:arch/stm32/mcu_periph/spi_arch.c ****   switch(slave) {
 580              		.loc 1 167 0
 581 0000 0228     		cmp	r0, #2
 582 0002 04D1     		bne	.L49
 583              	.LBB34:
 584              	.LBB35:
 180:arch/stm32/mcu_periph/spi_arch.c ****       gpio_clear(SPI_SELECT_SLAVE2_PORT, SPI_SELECT_SLAVE2_PIN);
 585              		.loc 1 180 0
 586 0004 0248     		ldr	r0, .L50
 587              	.LVL51:
 588 0006 4FF48051 		mov	r1, #4096
 589              	.LBE35:
 590              	.LBE34:
 591              	.LBE33:
 592              	.LBE32:
 205:arch/stm32/mcu_periph/spi_arch.c **** }
 593              		.loc 1 205 0
 594              	.LBB39:
 595              	.LBB38:
 596              	.LBB37:
 597              	.LBB36:
 180:arch/stm32/mcu_periph/spi_arch.c ****       gpio_clear(SPI_SELECT_SLAVE2_PORT, SPI_SELECT_SLAVE2_PIN);
 598              		.loc 1 180 0
 599 000a FFF7FEBF 		b	gpio_clear
 600              	.LVL52:
 601              	.L49:
 602 000e 7047     		bx	lr
 603              	.L51:
 604              		.align	2
 605              	.L50:
 606 0010 000C0140 		.word	1073810432
 607              	.LBE36:
 608              	.LBE37:
 609              	.LBE38:
 610              	.LBE39:
 611              		.cfi_endproc
 612              	.LFE4:
 614              		.section	.text.spi_slave_unselect,"ax",%progbits
 615              		.align	1
 616              		.global	spi_slave_unselect
 617              		.thumb
 618              		.thumb_func
 620              	spi_slave_unselect:
 621              	.LFB5:
 207:arch/stm32/mcu_periph/spi_arch.c **** void spi_slave_unselect(uint8_t slave) {
 622              		.loc 1 207 0
 623              		.cfi_startproc
 624              		@ args = 0, pretend = 0, frame = 0
 625              		@ frame_needed = 0, uses_anonymous_args = 0
 626              		@ link register save eliminated.
 627              	.LVL53:
 628              	.LBB44:
 629              	.LBB45:
 130:arch/stm32/mcu_periph/spi_arch.c ****   switch(slave) {
 630              		.loc 1 130 0
 631 0000 0228     		cmp	r0, #2
 632 0002 04D1     		bne	.L55
 633              	.LBB46:
 634              	.LBB47:
 143:arch/stm32/mcu_periph/spi_arch.c ****       gpio_set(SPI_SELECT_SLAVE2_PORT, SPI_SELECT_SLAVE2_PIN);
 635              		.loc 1 143 0
 636 0004 0248     		ldr	r0, .L56
 637              	.LVL54:
 638 0006 4FF48051 		mov	r1, #4096
 639              	.LBE47:
 640              	.LBE46:
 641              	.LBE45:
 642              	.LBE44:
 209:arch/stm32/mcu_periph/spi_arch.c **** }
 643              		.loc 1 209 0
 644              	.LBB51:
 645              	.LBB50:
 646              	.LBB49:
 647              	.LBB48:
 143:arch/stm32/mcu_periph/spi_arch.c ****       gpio_set(SPI_SELECT_SLAVE2_PORT, SPI_SELECT_SLAVE2_PIN);
 648              		.loc 1 143 0
 649 000a FFF7FEBF 		b	gpio_set
 650              	.LVL55:
 651              	.L55:
 652 000e 7047     		bx	lr
 653              	.L57:
 654              		.align	2
 655              	.L56:
 656 0010 000C0140 		.word	1073810432
 657              	.LBE48:
 658              	.LBE49:
 659              	.LBE50:
 660              	.LBE51:
 661              		.cfi_endproc
 662              	.LFE5:
 664              		.section	.text.spi_init_slaves,"ax",%progbits
 665              		.align	1
 666              		.global	spi_init_slaves
 667              		.thumb
 668              		.thumb_func
 670              	spi_init_slaves:
 671              	.LFB6:
 211:arch/stm32/mcu_periph/spi_arch.c **** void spi_init_slaves(void) {
 672              		.loc 1 211 0
 673              		.cfi_startproc
 674              		@ args = 0, pretend = 0, frame = 0
 675              		@ frame_needed = 0, uses_anonymous_args = 0
 676 0000 10B5     		push	{r4, lr}
 677              	.LCFI5:
 678              		.cfi_def_cfa_offset 8
 679              		.cfi_offset 4, -8
 680              		.cfi_offset 14, -4
 224:arch/stm32/mcu_periph/spi_arch.c ****   gpio_setup_output(SPI_SELECT_SLAVE2_PORT, SPI_SELECT_SLAVE2_PIN);
 681              		.loc 1 224 0
 682 0002 064C     		ldr	r4, .L59
 683 0004 4FF48051 		mov	r1, #4096
 684 0008 2046     		mov	r0, r4
 685 000a FFF7FEFF 		bl	gpio_setup_output
 686              	.LVL56:
 687              	.LBB56:
 688              	.LBB57:
 689              	.LBB58:
 143:arch/stm32/mcu_periph/spi_arch.c ****       gpio_set(SPI_SELECT_SLAVE2_PORT, SPI_SELECT_SLAVE2_PIN);
 690              		.loc 1 143 0
 691 000e 2046     		mov	r0, r4
 692 0010 4FF48051 		mov	r1, #4096
 693              	.LBE58:
 694              	.LBE57:
 695              	.LBE56:
 242:arch/stm32/mcu_periph/spi_arch.c **** }
 696              		.loc 1 242 0
 697 0014 BDE81040 		pop	{r4, lr}
 698              	.LBB61:
 699              	.LBB60:
 700              	.LBB59:
 143:arch/stm32/mcu_periph/spi_arch.c ****       gpio_set(SPI_SELECT_SLAVE2_PORT, SPI_SELECT_SLAVE2_PIN);
 701              		.loc 1 143 0
 702 0018 FFF7FEBF 		b	gpio_set
 703              	.LVL57:
 704              	.L60:
 705              		.align	2
 706              	.L59:
 707 001c 000C0140 		.word	1073810432
 708              	.LBE59:
 709              	.LBE60:
 710              	.LBE61:
 711              		.cfi_endproc
 712              	.LFE6:
 714              		.section	.text.spi_submit,"ax",%progbits
 715              		.align	1
 716              		.global	spi_submit
 717              		.thumb
 718              		.thumb_func
 720              	spi_submit:
 721              	.LFB7:
 251:arch/stm32/mcu_periph/spi_arch.c **** {
 722              		.loc 1 251 0
 723              		.cfi_startproc
 724              		@ args = 0, pretend = 0, frame = 0
 725              		@ frame_needed = 0, uses_anonymous_args = 0
 726              	.LVL58:
 727 0000 70B5     		push	{r4, r5, r6, lr}
 728              	.LCFI6:
 729              		.cfi_def_cfa_offset 16
 730              		.cfi_offset 4, -16
 731              		.cfi_offset 5, -12
 732              		.cfi_offset 6, -8
 733              		.cfi_offset 14, -4
 253:arch/stm32/mcu_periph/spi_arch.c ****   idx = p->trans_insert_idx + 1;
 734              		.loc 1 253 0
 735 0002 90F82060 		ldrb	r6, [r0, #32]	@ zero_extendqisi2
 251:arch/stm32/mcu_periph/spi_arch.c **** {
 736              		.loc 1 251 0
 737 0006 0D46     		mov	r5, r1
 253:arch/stm32/mcu_periph/spi_arch.c ****   idx = p->trans_insert_idx + 1;
 738              		.loc 1 253 0
 739 0008 711C     		adds	r1, r6, #1
 740              	.LVL59:
 741 000a CEB2     		uxtb	r6, r1
 742              	.LVL60:
 255:arch/stm32/mcu_periph/spi_arch.c ****   if ((idx == p->trans_extract_idx) || ((t->input_length == 0) && (t->output_length == 0))) {
 743              		.loc 1 255 0
 744 000c 90F82130 		ldrb	r3, [r0, #33]	@ zero_extendqisi2
 254:arch/stm32/mcu_periph/spi_arch.c ****   if (idx >= SPI_TRANSACTION_QUEUE_LEN) idx = 0;
 745              		.loc 1 254 0
 746 0010 072E     		cmp	r6, #7
 747 0012 88BF     		it	hi
 748 0014 0026     		movhi	r6, #0
 255:arch/stm32/mcu_periph/spi_arch.c ****   if ((idx == p->trans_extract_idx) || ((t->input_length == 0) && (t->output_length == 0))) {
 749              		.loc 1 255 0
 750 0016 B342     		cmp	r3, r6
 251:arch/stm32/mcu_periph/spi_arch.c **** {
 751              		.loc 1 251 0
 752 0018 0446     		mov	r4, r0
 255:arch/stm32/mcu_periph/spi_arch.c ****   if ((idx == p->trans_extract_idx) || ((t->input_length == 0) && (t->output_length == 0))) {
 753              		.loc 1 255 0
 754 001a 01D0     		beq	.L63
 255:arch/stm32/mcu_periph/spi_arch.c ****   if ((idx == p->trans_extract_idx) || ((t->input_length == 0) && (t->output_length == 0))) {
 755              		.loc 1 255 0 is_stmt 0 discriminator 1
 756 001c 2A89     		ldrh	r2, [r5, #8]
 757 001e 1AB9     		cbnz	r2, .L64
 758              	.L63:
 256:arch/stm32/mcu_periph/spi_arch.c ****     t->status = SPITransFailed;
 759              		.loc 1 256 0 is_stmt 1
 760 0020 0320     		movs	r0, #3
 761              	.LVL61:
 762 0022 2877     		strb	r0, [r5, #28]
 257:arch/stm32/mcu_periph/spi_arch.c ****     return FALSE; /* queue full or input_length and output_length both 0 */
 763              		.loc 1 257 0
 764 0024 0020     		movs	r0, #0
 765 0026 70BD     		pop	{r4, r5, r6, pc}
 766              	.LVL62:
 767              	.L64:
 261:arch/stm32/mcu_periph/spi_arch.c ****   t->status = SPITransPending;
 768              		.loc 1 261 0
 769 0028 0021     		movs	r1, #0
 770              	.LVL63:
 771 002a 2977     		strb	r1, [r5, #28]
 265:arch/stm32/mcu_periph/spi_arch.c ****   spi_arch_int_disable(p);
 772              		.loc 1 265 0
 773 002c FFF7FEFF 		bl	spi_arch_int_disable
 774              	.LVL64:
 268:arch/stm32/mcu_periph/spi_arch.c ****   p->trans[p->trans_insert_idx] = t;
 775              		.loc 1 268 0
 776 0030 94F82000 		ldrb	r0, [r4, #32]	@ zero_extendqisi2
 272:arch/stm32/mcu_periph/spi_arch.c ****   if (p->status == SPIIdle && !p->suspend) {
 777              		.loc 1 272 0
 778 0034 94F82230 		ldrb	r3, [r4, #34]	@ zero_extendqisi2
 268:arch/stm32/mcu_periph/spi_arch.c ****   p->trans[p->trans_insert_idx] = t;
 779              		.loc 1 268 0
 780 0038 44F82050 		str	r5, [r4, r0, lsl #2]
 269:arch/stm32/mcu_periph/spi_arch.c ****   p->trans_insert_idx = idx;
 781              		.loc 1 269 0
 782 003c 84F82060 		strb	r6, [r4, #32]
 272:arch/stm32/mcu_periph/spi_arch.c ****   if (p->status == SPIIdle && !p->suspend) {
 783              		.loc 1 272 0
 784 0040 4BB9     		cbnz	r3, .L66
 272:arch/stm32/mcu_periph/spi_arch.c ****   if (p->status == SPIIdle && !p->suspend) {
 785              		.loc 1 272 0 is_stmt 0 discriminator 1
 786 0042 94F83120 		ldrb	r2, [r4, #49]	@ zero_extendqisi2
 787 0046 32B9     		cbnz	r2, .L66
 273:arch/stm32/mcu_periph/spi_arch.c ****     spi_start_dma_transaction(p, p->trans[p->trans_extract_idx]);
 788              		.loc 1 273 0 is_stmt 1
 789 0048 94F82110 		ldrb	r1, [r4, #33]	@ zero_extendqisi2
 790 004c 2046     		mov	r0, r4
 791 004e 54F82110 		ldr	r1, [r4, r1, lsl #2]
 792 0052 FFF7FEFF 		bl	spi_start_dma_transaction
 793              	.LVL65:
 794              	.L66:
 276:arch/stm32/mcu_periph/spi_arch.c ****   spi_arch_int_enable(p);
 795              		.loc 1 276 0
 796 0056 2046     		mov	r0, r4
 797 0058 FFF7FEFF 		bl	spi_arch_int_enable
 798              	.LVL66:
 277:arch/stm32/mcu_periph/spi_arch.c ****   return TRUE;
 799              		.loc 1 277 0
 800 005c 0120     		movs	r0, #1
 278:arch/stm32/mcu_periph/spi_arch.c **** }
 801              		.loc 1 278 0
 802 005e 70BD     		pop	{r4, r5, r6, pc}
 803              		.cfi_endproc
 804              	.LFE7:
 806              		.section	.text.spi_lock,"ax",%progbits
 807              		.align	1
 808              		.global	spi_lock
 809              		.thumb
 810              		.thumb_func
 812              	spi_lock:
 813              	.LFB8:
 280:arch/stm32/mcu_periph/spi_arch.c **** bool_t spi_lock(struct spi_periph* p, uint8_t slave) {
 814              		.loc 1 280 0
 815              		.cfi_startproc
 816              		@ args = 0, pretend = 0, frame = 0
 817              		@ frame_needed = 0, uses_anonymous_args = 0
 818              	.LVL67:
 819 0000 38B5     		push	{r3, r4, r5, lr}
 820              	.LCFI7:
 821              		.cfi_def_cfa_offset 16
 822              		.cfi_offset 3, -16
 823              		.cfi_offset 4, -12
 824              		.cfi_offset 5, -8
 825              		.cfi_offset 14, -4
 280:arch/stm32/mcu_periph/spi_arch.c **** bool_t spi_lock(struct spi_periph* p, uint8_t slave) {
 826              		.loc 1 280 0
 827 0002 0D46     		mov	r5, r1
 828 0004 0446     		mov	r4, r0
 281:arch/stm32/mcu_periph/spi_arch.c ****   spi_arch_int_disable(p);
 829              		.loc 1 281 0
 830 0006 FFF7FEFF 		bl	spi_arch_int_disable
 831              	.LVL68:
 282:arch/stm32/mcu_periph/spi_arch.c ****   if (slave < 254 && p->suspend == 0) {
 832              		.loc 1 282 0
 833 000a FD2D     		cmp	r5, #253
 834 000c 0BD8     		bhi	.L69
 282:arch/stm32/mcu_periph/spi_arch.c ****   if (slave < 254 && p->suspend == 0) {
 835              		.loc 1 282 0 is_stmt 0 discriminator 1
 836 000e 94F83130 		ldrb	r3, [r4, #49]	@ zero_extendqisi2
 837 0012 43B9     		cbnz	r3, .L69
 283:arch/stm32/mcu_periph/spi_arch.c ****     p->suspend = slave + 1; // 0 is reserved for unlock state
 838              		.loc 1 283 0 is_stmt 1
 839 0014 0135     		adds	r5, r5, #1
 840 0016 EDB2     		uxtb	r5, r5
 284:arch/stm32/mcu_periph/spi_arch.c ****     spi_arch_int_enable(p);
 841              		.loc 1 284 0
 842 0018 2046     		mov	r0, r4
 283:arch/stm32/mcu_periph/spi_arch.c ****     p->suspend = slave + 1; // 0 is reserved for unlock state
 843              		.loc 1 283 0
 844 001a 84F83150 		strb	r5, [r4, #49]
 284:arch/stm32/mcu_periph/spi_arch.c ****     spi_arch_int_enable(p);
 845              		.loc 1 284 0
 846 001e FFF7FEFF 		bl	spi_arch_int_enable
 847              	.LVL69:
 285:arch/stm32/mcu_periph/spi_arch.c ****     return TRUE;
 848              		.loc 1 285 0
 849 0022 0120     		movs	r0, #1
 850 0024 38BD     		pop	{r3, r4, r5, pc}
 851              	.L69:
 287:arch/stm32/mcu_periph/spi_arch.c ****   spi_arch_int_enable(p);
 852              		.loc 1 287 0
 853 0026 2046     		mov	r0, r4
 854 0028 FFF7FEFF 		bl	spi_arch_int_enable
 855              	.LVL70:
 288:arch/stm32/mcu_periph/spi_arch.c ****   return FALSE;
 856              		.loc 1 288 0
 857 002c 0020     		movs	r0, #0
 289:arch/stm32/mcu_periph/spi_arch.c **** }
 858              		.loc 1 289 0
 859 002e 38BD     		pop	{r3, r4, r5, pc}
 860              		.cfi_endproc
 861              	.LFE8:
 863              		.section	.text.spi_resume,"ax",%progbits
 864              		.align	1
 865              		.global	spi_resume
 866              		.thumb
 867              		.thumb_func
 869              	spi_resume:
 870              	.LFB9:
 291:arch/stm32/mcu_periph/spi_arch.c **** bool_t spi_resume(struct spi_periph* p, uint8_t slave) {
 871              		.loc 1 291 0
 872              		.cfi_startproc
 873              		@ args = 0, pretend = 0, frame = 0
 874              		@ frame_needed = 0, uses_anonymous_args = 0
 875              	.LVL71:
 876 0000 38B5     		push	{r3, r4, r5, lr}
 877              	.LCFI8:
 878              		.cfi_def_cfa_offset 16
 879              		.cfi_offset 3, -16
 880              		.cfi_offset 4, -12
 881              		.cfi_offset 5, -8
 882              		.cfi_offset 14, -4
 291:arch/stm32/mcu_periph/spi_arch.c **** bool_t spi_resume(struct spi_periph* p, uint8_t slave) {
 883              		.loc 1 291 0
 884 0002 0446     		mov	r4, r0
 885 0004 0D46     		mov	r5, r1
 292:arch/stm32/mcu_periph/spi_arch.c ****   spi_arch_int_disable( p );
 886              		.loc 1 292 0
 887 0006 FFF7FEFF 		bl	spi_arch_int_disable
 888              	.LVL72:
 293:arch/stm32/mcu_periph/spi_arch.c ****   if (p->suspend == slave + 1) {
 889              		.loc 1 293 0
 890 000a 94F83130 		ldrb	r3, [r4, #49]	@ zero_extendqisi2
 891 000e 681C     		adds	r0, r5, #1
 892 0010 8342     		cmp	r3, r0
 893 0012 4FF00005 		mov	r5, #0
 894 0016 14D1     		bne	.L72
 296:arch/stm32/mcu_periph/spi_arch.c ****     if (p->trans_extract_idx != p->trans_insert_idx && p->status == SPIIdle) {
 895              		.loc 1 296 0
 896 0018 94F82110 		ldrb	r1, [r4, #33]	@ zero_extendqisi2
 897 001c 94F82020 		ldrb	r2, [r4, #32]	@ zero_extendqisi2
 295:arch/stm32/mcu_periph/spi_arch.c ****     p->suspend = 0;
 898              		.loc 1 295 0
 899 0020 84F83150 		strb	r5, [r4, #49]
 296:arch/stm32/mcu_periph/spi_arch.c ****     if (p->trans_extract_idx != p->trans_insert_idx && p->status == SPIIdle) {
 900              		.loc 1 296 0
 901 0024 8A42     		cmp	r2, r1
 902 0026 07D0     		beq	.L73
 296:arch/stm32/mcu_periph/spi_arch.c ****     if (p->trans_extract_idx != p->trans_insert_idx && p->status == SPIIdle) {
 903              		.loc 1 296 0 is_stmt 0 discriminator 1
 904 0028 94F82230 		ldrb	r3, [r4, #34]	@ zero_extendqisi2
 905 002c 23B9     		cbnz	r3, .L73
 297:arch/stm32/mcu_periph/spi_arch.c ****       spi_start_dma_transaction(p, p->trans[p->trans_extract_idx]);
 906              		.loc 1 297 0 is_stmt 1
 907 002e 2046     		mov	r0, r4
 908 0030 54F82110 		ldr	r1, [r4, r1, lsl #2]
 909 0034 FFF7FEFF 		bl	spi_start_dma_transaction
 910              	.LVL73:
 911              	.L73:
 299:arch/stm32/mcu_periph/spi_arch.c ****     spi_arch_int_enable(p);
 912              		.loc 1 299 0
 913 0038 2046     		mov	r0, r4
 914 003a FFF7FEFF 		bl	spi_arch_int_enable
 915              	.LVL74:
 300:arch/stm32/mcu_periph/spi_arch.c ****     return TRUE;
 916              		.loc 1 300 0
 917 003e 0120     		movs	r0, #1
 918 0040 38BD     		pop	{r3, r4, r5, pc}
 919              	.L72:
 302:arch/stm32/mcu_periph/spi_arch.c ****   spi_arch_int_enable(p);
 920              		.loc 1 302 0
 921 0042 2046     		mov	r0, r4
 922 0044 FFF7FEFF 		bl	spi_arch_int_enable
 923              	.LVL75:
 303:arch/stm32/mcu_periph/spi_arch.c ****   return FALSE;
 924              		.loc 1 303 0
 925 0048 2846     		mov	r0, r5
 304:arch/stm32/mcu_periph/spi_arch.c **** }
 926              		.loc 1 304 0
 927 004a 38BD     		pop	{r3, r4, r5, pc}
 928              		.cfi_endproc
 929              	.LFE9:
 931              		.section	.text.spi2_arch_init,"ax",%progbits
 932              		.align	1
 933              		.global	spi2_arch_init
 934              		.thumb
 935              		.thumb_func
 937              	spi2_arch_init:
 938              	.LFB19:
 610:arch/stm32/mcu_periph/spi_arch.c **** 
 611:arch/stm32/mcu_periph/spi_arch.c **** 
 612:arch/stm32/mcu_periph/spi_arch.c **** 
 613:arch/stm32/mcu_periph/spi_arch.c **** /******************************************************************************
 614:arch/stm32/mcu_periph/spi_arch.c ****  *
 615:arch/stm32/mcu_periph/spi_arch.c ****  * Initialization of each SPI peripheral
 616:arch/stm32/mcu_periph/spi_arch.c ****  *
 617:arch/stm32/mcu_periph/spi_arch.c ****  *****************************************************************************/
 618:arch/stm32/mcu_periph/spi_arch.c **** #if USE_SPI1
 619:arch/stm32/mcu_periph/spi_arch.c **** void spi1_arch_init(void) {
 620:arch/stm32/mcu_periph/spi_arch.c **** 
 621:arch/stm32/mcu_periph/spi_arch.c ****   // set dma options
 622:arch/stm32/mcu_periph/spi_arch.c ****   spi1_dma.spidr = (u32)&SPI1_DR;
 623:arch/stm32/mcu_periph/spi_arch.c ****   spi1_dma.dma = DMA1;
 624:arch/stm32/mcu_periph/spi_arch.c ****   spi1_dma.rx_chan = DMA_CHANNEL2;
 625:arch/stm32/mcu_periph/spi_arch.c ****   spi1_dma.tx_chan = DMA_CHANNEL3;
 626:arch/stm32/mcu_periph/spi_arch.c ****   spi1_dma.rx_nvic_irq = NVIC_DMA1_CHANNEL2_IRQ;
 627:arch/stm32/mcu_periph/spi_arch.c ****   spi1_dma.tx_nvic_irq = NVIC_DMA1_CHANNEL3_IRQ;
 628:arch/stm32/mcu_periph/spi_arch.c ****   spi1_dma.tx_dummy_buf = 0;
 629:arch/stm32/mcu_periph/spi_arch.c ****   spi1_dma.tx_extra_dummy_dma = FALSE;
 630:arch/stm32/mcu_periph/spi_arch.c ****   spi1_dma.rx_dummy_buf = 0;
 631:arch/stm32/mcu_periph/spi_arch.c ****   spi1_dma.rx_extra_dummy_dma = FALSE;
 632:arch/stm32/mcu_periph/spi_arch.c **** 
 633:arch/stm32/mcu_periph/spi_arch.c ****   // set the default configuration
 634:arch/stm32/mcu_periph/spi_arch.c ****   set_default_comm_config(&spi1_dma.comm);
 635:arch/stm32/mcu_periph/spi_arch.c ****   spi1_dma.comm_sig = get_comm_signature(&spi1_dma.comm);
 636:arch/stm32/mcu_periph/spi_arch.c **** 
 637:arch/stm32/mcu_periph/spi_arch.c ****   // set init struct, indices and status
 638:arch/stm32/mcu_periph/spi_arch.c ****   spi1.reg_addr = (void *)SPI1;
 639:arch/stm32/mcu_periph/spi_arch.c ****   spi1.init_struct = &spi1_dma;
 640:arch/stm32/mcu_periph/spi_arch.c ****   spi1.trans_insert_idx = 0;
 641:arch/stm32/mcu_periph/spi_arch.c ****   spi1.trans_extract_idx = 0;
 642:arch/stm32/mcu_periph/spi_arch.c ****   spi1.status = SPIIdle;
 643:arch/stm32/mcu_periph/spi_arch.c **** 
 644:arch/stm32/mcu_periph/spi_arch.c **** 
 645:arch/stm32/mcu_periph/spi_arch.c ****   // Enable SPI1 Periph and gpio clocks
 646:arch/stm32/mcu_periph/spi_arch.c ****   rcc_peripheral_enable_clock(&RCC_APB2ENR, RCC_APB2ENR_SPI1EN);
 647:arch/stm32/mcu_periph/spi_arch.c **** 
 648:arch/stm32/mcu_periph/spi_arch.c ****   // Configure GPIOs: SCK, MISO and MOSI
 649:arch/stm32/mcu_periph/spi_arch.c ****   gpio_set_mode(GPIO_BANK_SPI1_SCK, GPIO_MODE_OUTPUT_50_MHZ,
 650:arch/stm32/mcu_periph/spi_arch.c ****                 GPIO_CNF_OUTPUT_ALTFN_PUSHPULL,
 651:arch/stm32/mcu_periph/spi_arch.c ****                 GPIO_SPI1_SCK | GPIO_SPI1_MOSI);
 652:arch/stm32/mcu_periph/spi_arch.c **** 
 653:arch/stm32/mcu_periph/spi_arch.c ****   gpio_set_mode(GPIO_BANK_SPI1_MISO, GPIO_MODE_INPUT, GPIO_CNF_INPUT_FLOAT,
 654:arch/stm32/mcu_periph/spi_arch.c ****                 GPIO_SPI1_MISO);
 655:arch/stm32/mcu_periph/spi_arch.c **** 
 656:arch/stm32/mcu_periph/spi_arch.c ****   // reset SPI
 657:arch/stm32/mcu_periph/spi_arch.c ****   spi_reset(SPI1);
 658:arch/stm32/mcu_periph/spi_arch.c **** 
 659:arch/stm32/mcu_periph/spi_arch.c ****   // Disable SPI peripheral
 660:arch/stm32/mcu_periph/spi_arch.c ****   spi_disable(SPI1);
 661:arch/stm32/mcu_periph/spi_arch.c **** 
 662:arch/stm32/mcu_periph/spi_arch.c ****   // Force SPI mode over I2S.
 663:arch/stm32/mcu_periph/spi_arch.c ****   SPI1_I2SCFGR = 0;
 664:arch/stm32/mcu_periph/spi_arch.c **** 
 665:arch/stm32/mcu_periph/spi_arch.c ****   // configure master SPI.
 666:arch/stm32/mcu_periph/spi_arch.c ****   spi_init_master(SPI1, spi1_dma.comm.br, spi1_dma.comm.cpol, spi1_dma.comm.cpha,
 667:arch/stm32/mcu_periph/spi_arch.c ****                   spi1_dma.comm.dff, spi1_dma.comm.lsbfirst);
 668:arch/stm32/mcu_periph/spi_arch.c ****   /*
 669:arch/stm32/mcu_periph/spi_arch.c ****    * Set NSS management to software.
 670:arch/stm32/mcu_periph/spi_arch.c ****    *
 671:arch/stm32/mcu_periph/spi_arch.c ****    * Note:
 672:arch/stm32/mcu_periph/spi_arch.c ****    * Setting nss high is very important, even if we are controlling the GPIO
 673:arch/stm32/mcu_periph/spi_arch.c ****    * ourselves this bit needs to be at least set to 1, otherwise the spi
 674:arch/stm32/mcu_periph/spi_arch.c ****    * peripheral will not send any data out.
 675:arch/stm32/mcu_periph/spi_arch.c ****    */
 676:arch/stm32/mcu_periph/spi_arch.c ****   spi_enable_software_slave_management(SPI1);
 677:arch/stm32/mcu_periph/spi_arch.c ****   spi_set_nss_high(SPI1);
 678:arch/stm32/mcu_periph/spi_arch.c **** 
 679:arch/stm32/mcu_periph/spi_arch.c ****   // Enable SPI_1 DMA clock
 680:arch/stm32/mcu_periph/spi_arch.c ****   rcc_peripheral_enable_clock(&RCC_AHBENR, RCC_AHBENR_DMA1EN);
 681:arch/stm32/mcu_periph/spi_arch.c **** 
 682:arch/stm32/mcu_periph/spi_arch.c ****   // Enable SPI1 periph.
 683:arch/stm32/mcu_periph/spi_arch.c ****   spi_enable(SPI1);
 684:arch/stm32/mcu_periph/spi_arch.c **** 
 685:arch/stm32/mcu_periph/spi_arch.c ****   spi_arch_int_enable(&spi1);
 686:arch/stm32/mcu_periph/spi_arch.c **** }
 687:arch/stm32/mcu_periph/spi_arch.c **** #endif
 688:arch/stm32/mcu_periph/spi_arch.c **** 
 689:arch/stm32/mcu_periph/spi_arch.c **** #if USE_SPI2
 690:arch/stm32/mcu_periph/spi_arch.c **** void spi2_arch_init(void) {
 939              		.loc 1 690 0
 940              		.cfi_startproc
 941              		@ args = 0, pretend = 0, frame = 0
 942              		@ frame_needed = 0, uses_anonymous_args = 0
 943 0000 2DE9F347 		push	{r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
 944              	.LCFI9:
 945              		.cfi_def_cfa_offset 40
 946              		.cfi_offset 0, -40
 947              		.cfi_offset 1, -36
 948              		.cfi_offset 4, -32
 949              		.cfi_offset 5, -28
 950              		.cfi_offset 6, -24
 951              		.cfi_offset 7, -20
 952              		.cfi_offset 8, -16
 953              		.cfi_offset 9, -12
 954              		.cfi_offset 10, -8
 955              		.cfi_offset 14, -4
 691:arch/stm32/mcu_periph/spi_arch.c **** 
 692:arch/stm32/mcu_periph/spi_arch.c ****   // set dma options
 693:arch/stm32/mcu_periph/spi_arch.c ****   spi2_dma.spidr = (u32)&SPI2_DR;
 956              		.loc 1 693 0
 957 0004 324C     		ldr	r4, .L76
 694:arch/stm32/mcu_periph/spi_arch.c ****   spi2_dma.dma = DMA1;
 958              		.loc 1 694 0
 959 0006 3348     		ldr	r0, .L76+4
 695:arch/stm32/mcu_periph/spi_arch.c ****   spi2_dma.rx_chan = DMA_CHANNEL4;
 696:arch/stm32/mcu_periph/spi_arch.c ****   spi2_dma.tx_chan = DMA_CHANNEL5;
 697:arch/stm32/mcu_periph/spi_arch.c ****   spi2_dma.rx_nvic_irq = NVIC_DMA1_CHANNEL4_IRQ;
 960              		.loc 1 697 0
 961 0008 0E25     		movs	r5, #14
 962              	.LBB66:
 963              	.LBB67:
 313:arch/stm32/mcu_periph/spi_arch.c ****   c->br = SPI_CR1_BAUDRATE_FPCLK_DIV_64;
 964              		.loc 1 313 0
 965 000a 2827     		movs	r7, #40
 966              	.LBE67:
 967              	.LBE66:
 693:arch/stm32/mcu_periph/spi_arch.c ****   spi2_dma.spidr = (u32)&SPI2_DR;
 968              		.loc 1 693 0
 969 000c 324B     		ldr	r3, .L76+8
 694:arch/stm32/mcu_periph/spi_arch.c ****   spi2_dma.dma = DMA1;
 970              		.loc 1 694 0
 971 000e A060     		str	r0, [r4, #8]
 695:arch/stm32/mcu_periph/spi_arch.c ****   spi2_dma.rx_chan = DMA_CHANNEL4;
 972              		.loc 1 695 0
 973 0010 0421     		movs	r1, #4
 974              		.loc 1 697 0
 975 0012 A573     		strb	r5, [r4, #14]
 698:arch/stm32/mcu_periph/spi_arch.c ****   spi2_dma.tx_nvic_irq = NVIC_DMA1_CHANNEL5_IRQ;
 976              		.loc 1 698 0
 977 0014 0F26     		movs	r6, #15
 699:arch/stm32/mcu_periph/spi_arch.c ****   spi2_dma.tx_dummy_buf = 0;
 700:arch/stm32/mcu_periph/spi_arch.c ****   spi2_dma.tx_extra_dummy_dma = FALSE;
 701:arch/stm32/mcu_periph/spi_arch.c ****   spi2_dma.rx_dummy_buf = 0;
 702:arch/stm32/mcu_periph/spi_arch.c ****   spi2_dma.rx_extra_dummy_dma = FALSE;
 703:arch/stm32/mcu_periph/spi_arch.c **** 
 704:arch/stm32/mcu_periph/spi_arch.c ****   // set the default configuration
 705:arch/stm32/mcu_periph/spi_arch.c ****   set_default_comm_config(&spi2_dma.comm);
 706:arch/stm32/mcu_periph/spi_arch.c ****   spi2_dma.comm_sig = get_comm_signature(&spi2_dma.comm);
 707:arch/stm32/mcu_periph/spi_arch.c **** 
 708:arch/stm32/mcu_periph/spi_arch.c ****   // set init struct, indices and status
 709:arch/stm32/mcu_periph/spi_arch.c ****   spi2.reg_addr = (void *)SPI2;
 978              		.loc 1 709 0
 979 0016 314D     		ldr	r5, .L76+12
 980              	.LBB72:
 981              	.LBB68:
 313:arch/stm32/mcu_periph/spi_arch.c ****   c->br = SPI_CR1_BAUDRATE_FPCLK_DIV_64;
 982              		.loc 1 313 0
 983 0018 A761     		str	r7, [r4, #24]
 984              	.LBE68:
 985              	.LBE72:
 706:arch/stm32/mcu_periph/spi_arch.c ****   spi2_dma.comm_sig = get_comm_signature(&spi2_dma.comm);
 986              		.loc 1 706 0
 987 001a 2B20     		movs	r0, #43
 988              		.loc 1 709 0
 989 001c 304F     		ldr	r7, .L76+16
 710:arch/stm32/mcu_periph/spi_arch.c ****   spi2.init_struct = &spi2_dma;
 711:arch/stm32/mcu_periph/spi_arch.c ****   spi2.trans_insert_idx = 0;
 712:arch/stm32/mcu_periph/spi_arch.c ****   spi2.trans_extract_idx = 0;
 713:arch/stm32/mcu_periph/spi_arch.c ****   spi2.status = SPIIdle;
 714:arch/stm32/mcu_periph/spi_arch.c **** 
 715:arch/stm32/mcu_periph/spi_arch.c **** 
 716:arch/stm32/mcu_periph/spi_arch.c ****   // Enable SPI2 Periph and gpio clocks
 717:arch/stm32/mcu_periph/spi_arch.c ****   rcc_peripheral_enable_clock(&RCC_APB1ENR, RCC_APB1ENR_SPI2EN);
 718:arch/stm32/mcu_periph/spi_arch.c **** 
 719:arch/stm32/mcu_periph/spi_arch.c ****   // Configure GPIOs: SCK, MISO and MOSI
 720:arch/stm32/mcu_periph/spi_arch.c ****   gpio_set_mode(GPIO_BANK_SPI2_SCK, GPIO_MODE_OUTPUT_50_MHZ,
 990              		.loc 1 720 0
 991 001e DFF8D090 		ldr	r9, .L76+32
 696:arch/stm32/mcu_periph/spi_arch.c ****   spi2_dma.tx_chan = DMA_CHANNEL5;
 992              		.loc 1 696 0
 993 0022 0522     		movs	r2, #5
 994              	.LBB73:
 995              	.LBB69:
 315:arch/stm32/mcu_periph/spi_arch.c ****   c->cpha = SPI_CR1_CPHA_CLK_TRANSITION_2;
 996              		.loc 1 315 0
 997 0024 4FF00108 		mov	r8, #1
 998              	.LBE69:
 999              	.LBE73:
 695:arch/stm32/mcu_periph/spi_arch.c ****   spi2_dma.rx_chan = DMA_CHANNEL4;
 1000              		.loc 1 695 0
 1001 0028 2173     		strb	r1, [r4, #12]
 698:arch/stm32/mcu_periph/spi_arch.c ****   spi2_dma.tx_nvic_irq = NVIC_DMA1_CHANNEL5_IRQ;
 1002              		.loc 1 698 0
 1003 002a E673     		strb	r6, [r4, #15]
 1004              	.LBB74:
 1005              	.LBB70:
 314:arch/stm32/mcu_periph/spi_arch.c ****   c->cpol = SPI_CR1_CPOL_CLK_TO_1_WHEN_IDLE;
 1006              		.loc 1 314 0
 1007 002c 4FF0020A 		mov	sl, #2
 1008              	.LBE70:
 1009              	.LBE74:
 699:arch/stm32/mcu_periph/spi_arch.c ****   spi2_dma.tx_dummy_buf = 0;
 1010              		.loc 1 699 0
 1011 0030 0026     		movs	r6, #0
 706:arch/stm32/mcu_periph/spi_arch.c ****   spi2_dma.comm_sig = get_comm_signature(&spi2_dma.comm);
 1012              		.loc 1 706 0
 1013 0032 84F82C00 		strb	r0, [r4, #44]
 717:arch/stm32/mcu_periph/spi_arch.c ****   rcc_peripheral_enable_clock(&RCC_APB1ENR, RCC_APB1ENR_SPI2EN);
 1014              		.loc 1 717 0
 1015 0036 4FF48041 		mov	r1, #16384
 1016 003a 2A48     		ldr	r0, .L76+20
 693:arch/stm32/mcu_periph/spi_arch.c ****   spi2_dma.spidr = (u32)&SPI2_DR;
 1017              		.loc 1 693 0
 1018 003c 6360     		str	r3, [r4, #4]
 696:arch/stm32/mcu_periph/spi_arch.c ****   spi2_dma.tx_chan = DMA_CHANNEL5;
 1019              		.loc 1 696 0
 1020 003e 6273     		strb	r2, [r4, #13]
 699:arch/stm32/mcu_periph/spi_arch.c ****   spi2_dma.tx_dummy_buf = 0;
 1021              		.loc 1 699 0
 1022 0040 2682     		strh	r6, [r4, #16]	@ movhi
 700:arch/stm32/mcu_periph/spi_arch.c ****   spi2_dma.tx_extra_dummy_dma = FALSE;
 1023              		.loc 1 700 0
 1024 0042 A674     		strb	r6, [r4, #18]
 701:arch/stm32/mcu_periph/spi_arch.c ****   spi2_dma.rx_dummy_buf = 0;
 1025              		.loc 1 701 0
 1026 0044 A682     		strh	r6, [r4, #20]	@ movhi
 702:arch/stm32/mcu_periph/spi_arch.c ****   spi2_dma.rx_extra_dummy_dma = FALSE;
 1027              		.loc 1 702 0
 1028 0046 A675     		strb	r6, [r4, #22]
 1029              	.LVL76:
 1030              	.LBB75:
 1031              	.LBB71:
 314:arch/stm32/mcu_periph/spi_arch.c ****   c->cpol = SPI_CR1_CPOL_CLK_TO_1_WHEN_IDLE;
 1032              		.loc 1 314 0
 1033 0048 C4F81CA0 		str	sl, [r4, #28]
 315:arch/stm32/mcu_periph/spi_arch.c ****   c->cpha = SPI_CR1_CPHA_CLK_TRANSITION_2;
 1034              		.loc 1 315 0
 1035 004c C4F82080 		str	r8, [r4, #32]
 316:arch/stm32/mcu_periph/spi_arch.c ****   c->dff = SPI_CR1_DFF_8BIT;
 1036              		.loc 1 316 0
 1037 0050 6662     		str	r6, [r4, #36]
 317:arch/stm32/mcu_periph/spi_arch.c ****   c->lsbfirst = SPI_CR1_MSBFIRST;
 1038              		.loc 1 317 0
 1039 0052 A662     		str	r6, [r4, #40]
 1040              	.LVL77:
 1041              	.LBE71:
 1042              	.LBE75:
 709:arch/stm32/mcu_periph/spi_arch.c ****   spi2.reg_addr = (void *)SPI2;
 1043              		.loc 1 709 0
 1044 0054 BD62     		str	r5, [r7, #40]
 710:arch/stm32/mcu_periph/spi_arch.c ****   spi2.init_struct = &spi2_dma;
 1045              		.loc 1 710 0
 1046 0056 FC62     		str	r4, [r7, #44]
 711:arch/stm32/mcu_periph/spi_arch.c ****   spi2.trans_insert_idx = 0;
 1047              		.loc 1 711 0
 1048 0058 87F82060 		strb	r6, [r7, #32]
 712:arch/stm32/mcu_periph/spi_arch.c ****   spi2.trans_extract_idx = 0;
 1049              		.loc 1 712 0
 1050 005c 87F82160 		strb	r6, [r7, #33]
 713:arch/stm32/mcu_periph/spi_arch.c ****   spi2.status = SPIIdle;
 1051              		.loc 1 713 0
 1052 0060 87F82260 		strb	r6, [r7, #34]
 717:arch/stm32/mcu_periph/spi_arch.c ****   rcc_peripheral_enable_clock(&RCC_APB1ENR, RCC_APB1ENR_SPI2EN);
 1053              		.loc 1 717 0
 1054 0064 FFF7FEFF 		bl	rcc_peripheral_enable_clock
 1055              	.LVL78:
 1056              		.loc 1 720 0
 1057 0068 4846     		mov	r0, r9
 1058 006a 0321     		movs	r1, #3
 1059 006c 5246     		mov	r2, sl
 1060 006e 4FF42043 		mov	r3, #40960
 1061 0072 FFF7FEFF 		bl	gpio_set_mode
 1062              	.LVL79:
 721:arch/stm32/mcu_periph/spi_arch.c ****                 GPIO_CNF_OUTPUT_ALTFN_PUSHPULL,
 722:arch/stm32/mcu_periph/spi_arch.c ****                 GPIO_SPI2_SCK | GPIO_SPI2_MOSI);
 723:arch/stm32/mcu_periph/spi_arch.c **** 
 724:arch/stm32/mcu_periph/spi_arch.c ****   gpio_set_mode(GPIO_BANK_SPI2_MISO, GPIO_MODE_INPUT, GPIO_CNF_INPUT_FLOAT,
 1063              		.loc 1 724 0
 1064 0076 3146     		mov	r1, r6
 1065 0078 4246     		mov	r2, r8
 1066 007a 4FF48043 		mov	r3, #16384
 1067 007e 4846     		mov	r0, r9
 1068 0080 FFF7FEFF 		bl	gpio_set_mode
 1069              	.LVL80:
 725:arch/stm32/mcu_periph/spi_arch.c ****                 GPIO_SPI2_MISO);
 726:arch/stm32/mcu_periph/spi_arch.c **** 
 727:arch/stm32/mcu_periph/spi_arch.c ****   // reset SPI
 728:arch/stm32/mcu_periph/spi_arch.c ****   spi_reset(SPI2);
 1070              		.loc 1 728 0
 1071 0084 2846     		mov	r0, r5
 1072 0086 FFF7FEFF 		bl	spi_reset
 1073              	.LVL81:
 729:arch/stm32/mcu_periph/spi_arch.c **** 
 730:arch/stm32/mcu_periph/spi_arch.c ****   // Disable SPI peripheral
 731:arch/stm32/mcu_periph/spi_arch.c ****   spi_disable(SPI2);
 1074              		.loc 1 731 0
 1075 008a 2846     		mov	r0, r5
 1076 008c FFF7FEFF 		bl	spi_disable
 1077              	.LVL82:
 732:arch/stm32/mcu_periph/spi_arch.c **** 
 733:arch/stm32/mcu_periph/spi_arch.c ****   // Force SPI mode over I2S.
 734:arch/stm32/mcu_periph/spi_arch.c ****   SPI2_I2SCFGR = 0;
 1078              		.loc 1 734 0
 1079 0090 1549     		ldr	r1, .L76+24
 735:arch/stm32/mcu_periph/spi_arch.c **** 
 736:arch/stm32/mcu_periph/spi_arch.c ****   // configure master SPI.
 737:arch/stm32/mcu_periph/spi_arch.c ****   spi_init_master(SPI2, spi2_dma.comm.br, spi2_dma.comm.cpol, spi2_dma.comm.cpha,
 1080              		.loc 1 737 0
 1081 0092 2846     		mov	r0, r5
 734:arch/stm32/mcu_periph/spi_arch.c ****   SPI2_I2SCFGR = 0;
 1082              		.loc 1 734 0
 1083 0094 0E60     		str	r6, [r1, #0]
 1084              		.loc 1 737 0
 1085 0096 626A     		ldr	r2, [r4, #36]
 1086 0098 A36A     		ldr	r3, [r4, #40]
 1087 009a 0092     		str	r2, [sp, #0]
 1088 009c 0193     		str	r3, [sp, #4]
 1089 009e 04F11801 		add	r1, r4, #24
 1090 00a2 0EC9     		ldmia	r1, {r1, r2, r3}
 1091 00a4 FFF7FEFF 		bl	spi_init_master
 1092              	.LVL83:
 738:arch/stm32/mcu_periph/spi_arch.c ****                   spi2_dma.comm.dff, spi2_dma.comm.lsbfirst);
 739:arch/stm32/mcu_periph/spi_arch.c **** 
 740:arch/stm32/mcu_periph/spi_arch.c ****   /*
 741:arch/stm32/mcu_periph/spi_arch.c ****    * Set NSS management to software.
 742:arch/stm32/mcu_periph/spi_arch.c ****    * Setting nss high is very important, even if we are controlling the GPIO
 743:arch/stm32/mcu_periph/spi_arch.c ****    * ourselves this bit needs to be at least set to 1, otherwise the spi
 744:arch/stm32/mcu_periph/spi_arch.c ****    * peripheral will not send any data out.
 745:arch/stm32/mcu_periph/spi_arch.c ****    */
 746:arch/stm32/mcu_periph/spi_arch.c ****   spi_enable_software_slave_management(SPI2);
 1093              		.loc 1 746 0
 1094 00a8 2846     		mov	r0, r5
 1095 00aa FFF7FEFF 		bl	spi_enable_software_slave_management
 1096              	.LVL84:
 747:arch/stm32/mcu_periph/spi_arch.c ****   spi_set_nss_high(SPI2);
 1097              		.loc 1 747 0
 1098 00ae 2846     		mov	r0, r5
 1099 00b0 FFF7FEFF 		bl	spi_set_nss_high
 1100              	.LVL85:
 748:arch/stm32/mcu_periph/spi_arch.c **** 
 749:arch/stm32/mcu_periph/spi_arch.c ****   // Enable SPI_2 DMA clock
 750:arch/stm32/mcu_periph/spi_arch.c ****   rcc_peripheral_enable_clock(&RCC_AHBENR, RCC_AHBENR_DMA1EN);
 1101              		.loc 1 750 0
 1102 00b4 4146     		mov	r1, r8
 1103 00b6 0D48     		ldr	r0, .L76+28
 1104 00b8 FFF7FEFF 		bl	rcc_peripheral_enable_clock
 1105              	.LVL86:
 751:arch/stm32/mcu_periph/spi_arch.c **** 
 752:arch/stm32/mcu_periph/spi_arch.c ****   // Enable SPI2 periph.
 753:arch/stm32/mcu_periph/spi_arch.c ****   spi_enable(SPI2);
 1106              		.loc 1 753 0
 1107 00bc 2846     		mov	r0, r5
 1108 00be FFF7FEFF 		bl	spi_enable
 1109              	.LVL87:
 754:arch/stm32/mcu_periph/spi_arch.c **** 
 755:arch/stm32/mcu_periph/spi_arch.c ****   spi_arch_int_enable(&spi2);
 1110              		.loc 1 755 0
 1111 00c2 3846     		mov	r0, r7
 756:arch/stm32/mcu_periph/spi_arch.c **** }
 1112              		.loc 1 756 0
 1113 00c4 02B0     		add	sp, sp, #8
 1114 00c6 BDE8F047 		pop	{r4, r5, r6, r7, r8, r9, sl, lr}
 755:arch/stm32/mcu_periph/spi_arch.c ****   spi_arch_int_enable(&spi2);
 1115              		.loc 1 755 0
 1116 00ca FFF7FEBF 		b	spi_arch_int_enable
 1117              	.LVL88:
 1118              	.L77:
 1119 00ce 00BF     		.align	2
 1120              	.L76:
 1121 00d0 00000000 		.word	.LANCHOR0
 1122 00d4 00000240 		.word	1073872896
 1123 00d8 0C380040 		.word	1073756172
 1124 00dc 00380040 		.word	1073756160
 1125 00e0 00000000 		.word	spi2
 1126 00e4 1C100240 		.word	1073877020
 1127 00e8 1C380040 		.word	1073756188
 1128 00ec 14100240 		.word	1073877012
 1129 00f0 000C0140 		.word	1073810432
 1130              		.cfi_endproc
 1131              	.LFE19:
 1133              		.section	.text.dma1_channel4_isr,"ax",%progbits
 1134              		.align	1
 1135              		.weak	dma1_channel4_isr
 1136              		.thumb
 1137              		.thumb_func
 1139              	dma1_channel4_isr:
 1140              	.LFB20:
 757:arch/stm32/mcu_periph/spi_arch.c **** #endif
 758:arch/stm32/mcu_periph/spi_arch.c **** 
 759:arch/stm32/mcu_periph/spi_arch.c **** #if USE_SPI3
 760:arch/stm32/mcu_periph/spi_arch.c **** void spi3_arch_init(void) {
 761:arch/stm32/mcu_periph/spi_arch.c **** 
 762:arch/stm32/mcu_periph/spi_arch.c ****   // set the default configuration
 763:arch/stm32/mcu_periph/spi_arch.c ****   spi3_dma.spidr = (u32)&SPI3_DR;
 764:arch/stm32/mcu_periph/spi_arch.c ****   spi3_dma.dma = DMA2;
 765:arch/stm32/mcu_periph/spi_arch.c ****   spi3_dma.rx_chan = DMA_CHANNEL1;
 766:arch/stm32/mcu_periph/spi_arch.c ****   spi3_dma.tx_chan = DMA_CHANNEL2;
 767:arch/stm32/mcu_periph/spi_arch.c ****   spi3_dma.rx_nvic_irq = NVIC_DMA2_CHANNEL1_IRQ;
 768:arch/stm32/mcu_periph/spi_arch.c ****   spi3_dma.tx_nvic_irq = NVIC_DMA2_CHANNEL2_IRQ;
 769:arch/stm32/mcu_periph/spi_arch.c ****   spi3_dma.tx_dummy_buf = 0;
 770:arch/stm32/mcu_periph/spi_arch.c ****   spi3_dma.tx_extra_dummy_dma = FALSE;
 771:arch/stm32/mcu_periph/spi_arch.c ****   spi3_dma.rx_dummy_buf = 0;
 772:arch/stm32/mcu_periph/spi_arch.c ****   spi3_dma.rx_extra_dummy_dma = FALSE;
 773:arch/stm32/mcu_periph/spi_arch.c **** 
 774:arch/stm32/mcu_periph/spi_arch.c ****   // set the default configuration
 775:arch/stm32/mcu_periph/spi_arch.c ****   set_default_comm_config(&spi3_dma.comm);
 776:arch/stm32/mcu_periph/spi_arch.c ****   spi3_dma.comm_sig = get_comm_signature(&spi3_dma.comm);
 777:arch/stm32/mcu_periph/spi_arch.c **** 
 778:arch/stm32/mcu_periph/spi_arch.c ****   // set init struct, indices and status
 779:arch/stm32/mcu_periph/spi_arch.c ****   spi3.reg_addr = (void *)SPI3;
 780:arch/stm32/mcu_periph/spi_arch.c ****   spi3.init_struct = &spi3_dma;
 781:arch/stm32/mcu_periph/spi_arch.c ****   spi3.trans_insert_idx = 0;
 782:arch/stm32/mcu_periph/spi_arch.c ****   spi3.trans_extract_idx = 0;
 783:arch/stm32/mcu_periph/spi_arch.c ****   spi3.status = SPIIdle;
 784:arch/stm32/mcu_periph/spi_arch.c **** 
 785:arch/stm32/mcu_periph/spi_arch.c **** 
 786:arch/stm32/mcu_periph/spi_arch.c ****   // Enable SPI3 Periph and gpio clocks
 787:arch/stm32/mcu_periph/spi_arch.c ****   rcc_peripheral_enable_clock(&RCC_APB1ENR, RCC_APB1ENR_SPI3EN);
 788:arch/stm32/mcu_periph/spi_arch.c **** 
 789:arch/stm32/mcu_periph/spi_arch.c ****   // Configure GPIOs: SCK, MISO and MOSI
 790:arch/stm32/mcu_periph/spi_arch.c ****   gpio_set_mode(GPIO_BANK_SPI3_SCK, GPIO_MODE_OUTPUT_50_MHZ,
 791:arch/stm32/mcu_periph/spi_arch.c ****                 GPIO_CNF_OUTPUT_ALTFN_PUSHPULL,
 792:arch/stm32/mcu_periph/spi_arch.c ****                 GPIO_SPI3_SCK | GPIO_SPI3_MOSI);
 793:arch/stm32/mcu_periph/spi_arch.c **** 
 794:arch/stm32/mcu_periph/spi_arch.c ****   gpio_set_mode(GPIO_BANK_SPI3_MISO, GPIO_MODE_INPUT, GPIO_CNF_INPUT_FLOAT,
 795:arch/stm32/mcu_periph/spi_arch.c ****                 GPIO_SPI3_MISO);
 796:arch/stm32/mcu_periph/spi_arch.c **** 
 797:arch/stm32/mcu_periph/spi_arch.c ****   /// @todo disable JTAG so the pins can be used?
 798:arch/stm32/mcu_periph/spi_arch.c **** 
 799:arch/stm32/mcu_periph/spi_arch.c ****   // reset SPI
 800:arch/stm32/mcu_periph/spi_arch.c ****   spi_reset(SPI3);
 801:arch/stm32/mcu_periph/spi_arch.c **** 
 802:arch/stm32/mcu_periph/spi_arch.c ****   // Disable SPI peripheral
 803:arch/stm32/mcu_periph/spi_arch.c ****   spi_disable(SPI3);
 804:arch/stm32/mcu_periph/spi_arch.c **** 
 805:arch/stm32/mcu_periph/spi_arch.c ****   // Force SPI mode over I2S.
 806:arch/stm32/mcu_periph/spi_arch.c ****   SPI3_I2SCFGR = 0;
 807:arch/stm32/mcu_periph/spi_arch.c **** 
 808:arch/stm32/mcu_periph/spi_arch.c ****   // configure master SPI.
 809:arch/stm32/mcu_periph/spi_arch.c ****   spi_init_master(SPI3, spi3_dma.comm.br, spi3_dma.comm.cpol, spi3_dma.comm.cpha,
 810:arch/stm32/mcu_periph/spi_arch.c ****                   spi3_dma.comm.dff, spi3_dma.comm.lsbfirst);
 811:arch/stm32/mcu_periph/spi_arch.c **** 
 812:arch/stm32/mcu_periph/spi_arch.c ****   /*
 813:arch/stm32/mcu_periph/spi_arch.c ****    * Set NSS management to software.
 814:arch/stm32/mcu_periph/spi_arch.c ****    * Setting nss high is very important, even if we are controlling the GPIO
 815:arch/stm32/mcu_periph/spi_arch.c ****    * ourselves this bit needs to be at least set to 1, otherwise the spi
 816:arch/stm32/mcu_periph/spi_arch.c ****    * peripheral will not send any data out.
 817:arch/stm32/mcu_periph/spi_arch.c ****    */
 818:arch/stm32/mcu_periph/spi_arch.c ****   spi_enable_software_slave_management(SPI3);
 819:arch/stm32/mcu_periph/spi_arch.c ****   spi_set_nss_high(SPI3);
 820:arch/stm32/mcu_periph/spi_arch.c **** 
 821:arch/stm32/mcu_periph/spi_arch.c ****   // Enable SPI_3 DMA clock
 822:arch/stm32/mcu_periph/spi_arch.c ****   rcc_peripheral_enable_clock(&RCC_AHBENR, RCC_AHBENR_DMA2EN);
 823:arch/stm32/mcu_periph/spi_arch.c **** 
 824:arch/stm32/mcu_periph/spi_arch.c ****   // Enable SPI3 periph.
 825:arch/stm32/mcu_periph/spi_arch.c ****   spi_enable(SPI3);
 826:arch/stm32/mcu_periph/spi_arch.c **** 
 827:arch/stm32/mcu_periph/spi_arch.c ****   spi_arch_int_enable(&spi3);
 828:arch/stm32/mcu_periph/spi_arch.c **** }
 829:arch/stm32/mcu_periph/spi_arch.c **** #endif
 830:arch/stm32/mcu_periph/spi_arch.c **** 
 831:arch/stm32/mcu_periph/spi_arch.c **** 
 832:arch/stm32/mcu_periph/spi_arch.c **** 
 833:arch/stm32/mcu_periph/spi_arch.c **** 
 834:arch/stm32/mcu_periph/spi_arch.c **** /******************************************************************************
 835:arch/stm32/mcu_periph/spi_arch.c ****  *
 836:arch/stm32/mcu_periph/spi_arch.c ****  * DMA Interrupt service routines
 837:arch/stm32/mcu_periph/spi_arch.c ****  *
 838:arch/stm32/mcu_periph/spi_arch.c ****  *****************************************************************************/
 839:arch/stm32/mcu_periph/spi_arch.c **** #ifdef USE_SPI1
 840:arch/stm32/mcu_periph/spi_arch.c **** /// receive transferred over DMA
 841:arch/stm32/mcu_periph/spi_arch.c **** void dma1_channel2_isr(void)
 842:arch/stm32/mcu_periph/spi_arch.c **** {
 843:arch/stm32/mcu_periph/spi_arch.c ****   if ((DMA1_ISR & DMA_ISR_TCIF2) != 0) {
 844:arch/stm32/mcu_periph/spi_arch.c ****     // clear int pending bit
 845:arch/stm32/mcu_periph/spi_arch.c ****     DMA1_IFCR |= DMA_IFCR_CTCIF2;
 846:arch/stm32/mcu_periph/spi_arch.c ****   }
 847:arch/stm32/mcu_periph/spi_arch.c ****   process_rx_dma_interrupt(&spi1);
 848:arch/stm32/mcu_periph/spi_arch.c **** }
 849:arch/stm32/mcu_periph/spi_arch.c **** 
 850:arch/stm32/mcu_periph/spi_arch.c **** /// transmit transferred over DMA
 851:arch/stm32/mcu_periph/spi_arch.c **** void dma1_channel3_isr(void)
 852:arch/stm32/mcu_periph/spi_arch.c **** {
 853:arch/stm32/mcu_periph/spi_arch.c ****   if ((DMA1_ISR & DMA_ISR_TCIF3) != 0) {
 854:arch/stm32/mcu_periph/spi_arch.c ****     // clear int pending bit
 855:arch/stm32/mcu_periph/spi_arch.c ****     DMA1_IFCR |= DMA_IFCR_CTCIF3;
 856:arch/stm32/mcu_periph/spi_arch.c ****   }
 857:arch/stm32/mcu_periph/spi_arch.c ****   process_tx_dma_interrupt(&spi1);
 858:arch/stm32/mcu_periph/spi_arch.c **** }
 859:arch/stm32/mcu_periph/spi_arch.c **** 
 860:arch/stm32/mcu_periph/spi_arch.c **** #endif
 861:arch/stm32/mcu_periph/spi_arch.c **** 
 862:arch/stm32/mcu_periph/spi_arch.c **** #ifdef USE_SPI2
 863:arch/stm32/mcu_periph/spi_arch.c **** /// receive transferred over DMA
 864:arch/stm32/mcu_periph/spi_arch.c **** void dma1_channel4_isr(void)
 865:arch/stm32/mcu_periph/spi_arch.c **** {
 1141              		.loc 1 865 0
 1142              		.cfi_startproc
 1143              		@ args = 0, pretend = 0, frame = 0
 1144              		@ frame_needed = 0, uses_anonymous_args = 0
 1145 0000 7FB5     		push	{r0, r1, r2, r3, r4, r5, r6, lr}
 1146              	.LCFI10:
 1147              		.cfi_def_cfa_offset 32
 1148              		.cfi_offset 0, -32
 1149              		.cfi_offset 1, -28
 1150              		.cfi_offset 2, -24
 1151              		.cfi_offset 3, -20
 1152              		.cfi_offset 4, -16
 1153              		.cfi_offset 5, -12
 1154              		.cfi_offset 6, -8
 1155              		.cfi_offset 14, -4
 866:arch/stm32/mcu_periph/spi_arch.c ****   if ((DMA1_ISR & DMA_ISR_TCIF4) != 0) {
 1156              		.loc 1 866 0
 1157 0002 3C4B     		ldr	r3, .L101
 1158 0004 1868     		ldr	r0, [r3, #0]
 1159 0006 8304     		lsls	r3, r0, #18
 1160 0008 04D5     		bpl	.L79
 867:arch/stm32/mcu_periph/spi_arch.c ****     // clear int pending bit
 868:arch/stm32/mcu_periph/spi_arch.c ****     DMA1_IFCR |= DMA_IFCR_CTCIF4;
 1161              		.loc 1 868 0
 1162 000a 3B49     		ldr	r1, .L101+4
 1163 000c 0A68     		ldr	r2, [r1, #0]
 1164 000e 42F40054 		orr	r4, r2, #8192
 1165 0012 0C60     		str	r4, [r1, #0]
 1166              	.L79:
 1167              	.LVL89:
 1168              	.LBB85:
 1169              	.LBB86:
 869:arch/stm32/mcu_periph/spi_arch.c ****   }
 870:arch/stm32/mcu_periph/spi_arch.c ****   process_rx_dma_interrupt(&spi2);
 871:arch/stm32/mcu_periph/spi_arch.c **** }
 872:arch/stm32/mcu_periph/spi_arch.c **** 
 873:arch/stm32/mcu_periph/spi_arch.c **** /// transmit transferred over DMA
 874:arch/stm32/mcu_periph/spi_arch.c **** void dma1_channel5_isr(void)
 875:arch/stm32/mcu_periph/spi_arch.c **** {
 876:arch/stm32/mcu_periph/spi_arch.c ****   if ((DMA1_ISR & DMA_ISR_TCIF5) != 0) {
 877:arch/stm32/mcu_periph/spi_arch.c ****     // clear int pending bit
 878:arch/stm32/mcu_periph/spi_arch.c ****     DMA1_IFCR |= DMA_IFCR_CTCIF5;
 879:arch/stm32/mcu_periph/spi_arch.c ****   }
 880:arch/stm32/mcu_periph/spi_arch.c ****   process_tx_dma_interrupt(&spi2);
 881:arch/stm32/mcu_periph/spi_arch.c **** }
 882:arch/stm32/mcu_periph/spi_arch.c **** 
 883:arch/stm32/mcu_periph/spi_arch.c **** #endif
 884:arch/stm32/mcu_periph/spi_arch.c **** 
 885:arch/stm32/mcu_periph/spi_arch.c **** #if USE_SPI3
 886:arch/stm32/mcu_periph/spi_arch.c **** /// receive transferred over DMA
 887:arch/stm32/mcu_periph/spi_arch.c **** void dma2_channel1_isr(void)
 888:arch/stm32/mcu_periph/spi_arch.c **** {
 889:arch/stm32/mcu_periph/spi_arch.c ****   if ((DMA2_ISR & DMA_ISR_TCIF1) != 0) {
 890:arch/stm32/mcu_periph/spi_arch.c ****     // clear int pending bit
 891:arch/stm32/mcu_periph/spi_arch.c ****     DMA2_IFCR |= DMA_IFCR_CTCIF1;
 892:arch/stm32/mcu_periph/spi_arch.c ****   }
 893:arch/stm32/mcu_periph/spi_arch.c ****   process_rx_dma_interrupt(&spi3);
 894:arch/stm32/mcu_periph/spi_arch.c **** }
 895:arch/stm32/mcu_periph/spi_arch.c **** 
 896:arch/stm32/mcu_periph/spi_arch.c **** /// transmit transferred over DMA
 897:arch/stm32/mcu_periph/spi_arch.c **** void dma2_channel2_isr(void)
 898:arch/stm32/mcu_periph/spi_arch.c **** {
 899:arch/stm32/mcu_periph/spi_arch.c ****   if ((DMA2_ISR & DMA_ISR_TCIF2) != 0) {
 900:arch/stm32/mcu_periph/spi_arch.c ****     // clear int pending bit
 901:arch/stm32/mcu_periph/spi_arch.c ****     DMA2_IFCR |= DMA_IFCR_CTCIF2;
 902:arch/stm32/mcu_periph/spi_arch.c ****   }
 903:arch/stm32/mcu_periph/spi_arch.c ****   process_tx_dma_interrupt(&spi3);
 904:arch/stm32/mcu_periph/spi_arch.c **** }
 905:arch/stm32/mcu_periph/spi_arch.c **** 
 906:arch/stm32/mcu_periph/spi_arch.c **** #endif
 907:arch/stm32/mcu_periph/spi_arch.c **** 
 908:arch/stm32/mcu_periph/spi_arch.c **** /// Processing done after rx completes.
 909:arch/stm32/mcu_periph/spi_arch.c **** void process_rx_dma_interrupt(struct spi_periph *periph) {
 910:arch/stm32/mcu_periph/spi_arch.c ****   struct spi_periph_dma *dma = periph->init_struct;
 1170              		.loc 1 910 0
 1171 0014 394E     		ldr	r6, .L101+8
 1172 0016 F46A     		ldr	r4, [r6, #44]
 1173              	.LVL90:
 911:arch/stm32/mcu_periph/spi_arch.c ****   struct spi_transaction *trans = periph->trans[periph->trans_extract_idx];
 1174              		.loc 1 911 0
 1175 0018 96F82150 		ldrb	r5, [r6, #33]	@ zero_extendqisi2
 912:arch/stm32/mcu_periph/spi_arch.c **** 
 913:arch/stm32/mcu_periph/spi_arch.c ****   /* Disable DMA Channel */
 914:arch/stm32/mcu_periph/spi_arch.c ****   dma_disable_transfer_complete_interrupt(dma->dma, dma->rx_chan);
 1176              		.loc 1 914 0
 1177 001c 217B     		ldrb	r1, [r4, #12]	@ zero_extendqisi2
 1178 001e A068     		ldr	r0, [r4, #8]
 911:arch/stm32/mcu_periph/spi_arch.c ****   struct spi_transaction *trans = periph->trans[periph->trans_extract_idx];
 1179              		.loc 1 911 0
 1180 0020 56F82550 		ldr	r5, [r6, r5, lsl #2]
 1181              	.LVL91:
 1182              		.loc 1 914 0
 1183 0024 FFF7FEFF 		bl	dma_disable_transfer_complete_interrupt
 1184              	.LVL92:
 915:arch/stm32/mcu_periph/spi_arch.c **** 
 916:arch/stm32/mcu_periph/spi_arch.c ****   /* Disable SPI Rx request */
 917:arch/stm32/mcu_periph/spi_arch.c ****   spi_disable_rx_dma((u32)periph->reg_addr);
 1185              		.loc 1 917 0
 1186 0028 B06A     		ldr	r0, [r6, #40]
 1187 002a FFF7FEFF 		bl	spi_disable_rx_dma
 1188              	.LVL93:
 918:arch/stm32/mcu_periph/spi_arch.c **** 
 919:arch/stm32/mcu_periph/spi_arch.c ****   /* Disable DMA rx channel */
 920:arch/stm32/mcu_periph/spi_arch.c ****   dma_disable_channel(dma->dma, dma->rx_chan);
 1189              		.loc 1 920 0
 1190 002e A068     		ldr	r0, [r4, #8]
 1191 0030 217B     		ldrb	r1, [r4, #12]	@ zero_extendqisi2
 1192 0032 FFF7FEFF 		bl	dma_disable_channel
 1193              	.LVL94:
 921:arch/stm32/mcu_periph/spi_arch.c **** 
 922:arch/stm32/mcu_periph/spi_arch.c **** 
 923:arch/stm32/mcu_periph/spi_arch.c ****   if (dma->rx_extra_dummy_dma) {
 1194              		.loc 1 923 0
 1195 0036 A37D     		ldrb	r3, [r4, #22]	@ zero_extendqisi2
 1196 0038 002B     		cmp	r3, #0
 1197 003a 28D0     		beq	.L80
 1198              	.LBB87:
 924:arch/stm32/mcu_periph/spi_arch.c ****     /*
 925:arch/stm32/mcu_periph/spi_arch.c ****      * We are finished the first part of the receive with real data,
 926:arch/stm32/mcu_periph/spi_arch.c ****      * but still need to run the dummy to get a transfer complete interrupt
 927:arch/stm32/mcu_periph/spi_arch.c ****      * after the complete transaction is done.
 928:arch/stm32/mcu_periph/spi_arch.c ****      */
 929:arch/stm32/mcu_periph/spi_arch.c **** 
 930:arch/stm32/mcu_periph/spi_arch.c ****     /* Reset the flag so this only happens once in a transaction */
 931:arch/stm32/mcu_periph/spi_arch.c ****     dma->rx_extra_dummy_dma = FALSE;
 1199              		.loc 1 931 0
 1200 003c 0023     		movs	r3, #0
 1201 003e A375     		strb	r3, [r4, #22]
 1202              	.LVL95:
 932:arch/stm32/mcu_periph/spi_arch.c **** 
 933:arch/stm32/mcu_periph/spi_arch.c ****     /* Use the difference in length between rx and tx */
 934:arch/stm32/mcu_periph/spi_arch.c ****     u16 len_remaining = trans->output_length - trans->input_length;
 1203              		.loc 1 934 0
 1204 0040 2A7A     		ldrb	r2, [r5, #8]	@ zero_extendqisi2
 1205 0042 687A     		ldrb	r0, [r5, #9]	@ zero_extendqisi2
 935:arch/stm32/mcu_periph/spi_arch.c **** 
 936:arch/stm32/mcu_periph/spi_arch.c ****     spi_configure_dma(dma->dma, dma->rx_chan, (u32)dma->spidr,
 1206              		.loc 1 936 0
 1207 0044 217B     		ldrb	r1, [r4, #12]	@ zero_extendqisi2
 934:arch/stm32/mcu_periph/spi_arch.c ****     u16 len_remaining = trans->output_length - trans->input_length;
 1208              		.loc 1 934 0
 1209 0046 801A     		subs	r0, r0, r2
 1210              		.loc 1 936 0
 1211 0048 82B2     		uxth	r2, r0
 1212 004a 0092     		str	r2, [sp, #0]
 1213 004c A87B     		ldrb	r0, [r5, #14]	@ zero_extendqisi2
 1214 004e 0293     		str	r3, [sp, #8]
 1215 0050 0190     		str	r0, [sp, #4]
 1216 0052 04F11403 		add	r3, r4, #20
 1217 0056 6268     		ldr	r2, [r4, #4]
 1218 0058 A068     		ldr	r0, [r4, #8]
 1219 005a FFF7FEFF 		bl	spi_configure_dma
 1220              	.LVL96:
 937:arch/stm32/mcu_periph/spi_arch.c ****                       (u32)&(dma->rx_dummy_buf), len_remaining, trans->dss, FALSE);
 938:arch/stm32/mcu_periph/spi_arch.c ****     dma_set_read_from_peripheral(dma->dma, dma->rx_chan);
 1221              		.loc 1 938 0
 1222 005e A068     		ldr	r0, [r4, #8]
 1223 0060 217B     		ldrb	r1, [r4, #12]	@ zero_extendqisi2
 1224 0062 FFF7FEFF 		bl	dma_set_read_from_peripheral
 1225              	.LVL97:
 939:arch/stm32/mcu_periph/spi_arch.c ****     dma_set_priority(dma->dma, dma->rx_chan, DMA_CCR_PL_HIGH);
 1226              		.loc 1 939 0
 1227 0066 4FF40052 		mov	r2, #8192
 1228 006a A068     		ldr	r0, [r4, #8]
 1229 006c 217B     		ldrb	r1, [r4, #12]	@ zero_extendqisi2
 1230 006e FFF7FEFF 		bl	dma_set_priority
 1231              	.LVL98:
 940:arch/stm32/mcu_periph/spi_arch.c **** 
 941:arch/stm32/mcu_periph/spi_arch.c ****     /* Enable DMA transfer complete interrupts. */
 942:arch/stm32/mcu_periph/spi_arch.c ****     dma_enable_transfer_complete_interrupt(dma->dma, dma->rx_chan);
 1232              		.loc 1 942 0
 1233 0072 A068     		ldr	r0, [r4, #8]
 1234 0074 217B     		ldrb	r1, [r4, #12]	@ zero_extendqisi2
 1235 0076 FFF7FEFF 		bl	dma_enable_transfer_complete_interrupt
 1236              	.LVL99:
 943:arch/stm32/mcu_periph/spi_arch.c ****     /* Enable DMA channels */
 944:arch/stm32/mcu_periph/spi_arch.c ****     dma_enable_channel(dma->dma, dma->rx_chan);
 1237              		.loc 1 944 0
 1238 007a A068     		ldr	r0, [r4, #8]
 1239 007c 217B     		ldrb	r1, [r4, #12]	@ zero_extendqisi2
 1240 007e FFF7FEFF 		bl	dma_enable_channel
 1241              	.LVL100:
 945:arch/stm32/mcu_periph/spi_arch.c ****     /* Enable SPI transfers via DMA */
 946:arch/stm32/mcu_periph/spi_arch.c ****     spi_enable_rx_dma((u32)periph->reg_addr);
 1242              		.loc 1 946 0
 1243 0082 B06A     		ldr	r0, [r6, #40]
 1244              	.LBE87:
 1245              	.LBE86:
 1246              	.LBE85:
 871:arch/stm32/mcu_periph/spi_arch.c **** }
 1247              		.loc 1 871 0
 1248 0084 04B0     		add	sp, sp, #16
 1249 0086 BDE87040 		pop	{r4, r5, r6, lr}
 1250              	.LBB102:
 1251              	.LBB99:
 1252              	.LBB88:
 1253              		.loc 1 946 0
 1254 008a FFF7FEBF 		b	spi_enable_rx_dma
 1255              	.LVL101:
 1256              	.L80:
 1257              	.LBE88:
 947:arch/stm32/mcu_periph/spi_arch.c ****   }
 948:arch/stm32/mcu_periph/spi_arch.c ****   else {
 949:arch/stm32/mcu_periph/spi_arch.c ****     /*
 950:arch/stm32/mcu_periph/spi_arch.c ****      * Since the receive DMA is always run until the very end
 951:arch/stm32/mcu_periph/spi_arch.c ****      * and this interrupt is triggered after the last data word was read,
 952:arch/stm32/mcu_periph/spi_arch.c ****      * we now know that this transaction is finished.
 953:arch/stm32/mcu_periph/spi_arch.c ****      */
 954:arch/stm32/mcu_periph/spi_arch.c **** 
 955:arch/stm32/mcu_periph/spi_arch.c ****     /* Run the callback */
 956:arch/stm32/mcu_periph/spi_arch.c ****     trans->status = SPITransSuccess;
 957:arch/stm32/mcu_periph/spi_arch.c ****     if (trans->after_cb != 0) {
 1258              		.loc 1 957 0
 1259 008e A969     		ldr	r1, [r5, #24]
 956:arch/stm32/mcu_periph/spi_arch.c ****     trans->status = SPITransSuccess;
 1260              		.loc 1 956 0
 1261 0090 0220     		movs	r0, #2
 1262 0092 2877     		strb	r0, [r5, #28]
 1263              		.loc 1 957 0
 1264 0094 09B1     		cbz	r1, .L81
 958:arch/stm32/mcu_periph/spi_arch.c ****       trans->after_cb(trans);
 1265              		.loc 1 958 0
 1266 0096 2846     		mov	r0, r5
 1267 0098 8847     		blx	r1
 1268              	.LVL102:
 1269              	.L81:
 959:arch/stm32/mcu_periph/spi_arch.c ****     }
 960:arch/stm32/mcu_periph/spi_arch.c **** 
 961:arch/stm32/mcu_periph/spi_arch.c ****     /* AFTER the callback, then unselect the slave if required */
 962:arch/stm32/mcu_periph/spi_arch.c ****     if (trans->select == SPISelectUnselect || trans->select == SPIUnselect) {
 1270              		.loc 1 962 0
 1271 009a EA7A     		ldrb	r2, [r5, #11]	@ zero_extendqisi2
 1272 009c 0AB1     		cbz	r2, .L82
 1273 009e 022A     		cmp	r2, #2
 1274 00a0 07D1     		bne	.L83
 1275              	.L82:
 1276              	.LVL103:
 1277              	.LBB89:
 1278              	.LBB90:
 130:arch/stm32/mcu_periph/spi_arch.c ****   switch(slave) {
 1279              		.loc 1 130 0
 1280 00a2 AB7A     		ldrb	r3, [r5, #10]	@ zero_extendqisi2
 1281 00a4 022B     		cmp	r3, #2
 1282 00a6 04D1     		bne	.L83
 1283              	.LBB91:
 1284              	.LBB92:
 143:arch/stm32/mcu_periph/spi_arch.c ****       gpio_set(SPI_SELECT_SLAVE2_PORT, SPI_SELECT_SLAVE2_PIN);
 1285              		.loc 1 143 0
 1286 00a8 1548     		ldr	r0, .L101+12
 1287 00aa 4FF48051 		mov	r1, #4096
 1288 00ae FFF7FEFF 		bl	gpio_set
 1289              	.LVL104:
 1290              	.L83:
 1291              	.LBE92:
 1292              	.LBE91:
 1293              	.LBE90:
 1294              	.LBE89:
 1295              	.LBB93:
 1296              	.LBB94:
 482:arch/stm32/mcu_periph/spi_arch.c ****   periph->trans_extract_idx++;
 1297              		.loc 1 482 0
 1298 00b2 1249     		ldr	r1, .L101+8
 1299 00b4 91F82100 		ldrb	r0, [r1, #33]	@ zero_extendqisi2
 1300 00b8 421C     		adds	r2, r0, #1
 1301 00ba D3B2     		uxtb	r3, r2
 485:arch/stm32/mcu_periph/spi_arch.c ****   if (periph->trans_extract_idx >= SPI_TRANSACTION_QUEUE_LEN)
 1302              		.loc 1 485 0
 1303 00bc 072B     		cmp	r3, #7
 486:arch/stm32/mcu_periph/spi_arch.c ****     periph->trans_extract_idx = 0;
 1304              		.loc 1 486 0
 1305 00be 88BF     		it	hi
 1306 00c0 0023     		movhi	r3, #0
 1307 00c2 81F82130 		strb	r3, [r1, #33]
 489:arch/stm32/mcu_periph/spi_arch.c ****   if ((periph->trans_extract_idx == periph->trans_insert_idx) || periph->suspend)
 1308              		.loc 1 489 0
 1309 00c6 91F82120 		ldrb	r2, [r1, #33]	@ zero_extendqisi2
 1310 00ca 91F82010 		ldrb	r1, [r1, #32]	@ zero_extendqisi2
 1311 00ce 0B48     		ldr	r0, .L101+8
 1312 00d0 9142     		cmp	r1, r2
 1313 00d2 02D0     		beq	.L87
 1314 00d4 90F83130 		ldrb	r3, [r0, #49]	@ zero_extendqisi2
 1315 00d8 2BB1     		cbz	r3, .L88
 1316              	.L87:
 490:arch/stm32/mcu_periph/spi_arch.c ****     periph->status = SPIIdle;
 1317              		.loc 1 490 0
 1318 00da 084A     		ldr	r2, .L101+8
 1319 00dc 0020     		movs	r0, #0
 1320 00de 82F82200 		strb	r0, [r2, #34]
 1321              	.LBE94:
 1322              	.LBE93:
 1323              	.LBE99:
 1324              	.LBE102:
 871:arch/stm32/mcu_periph/spi_arch.c **** }
 1325              		.loc 1 871 0
 1326 00e2 04B0     		add	sp, sp, #16
 1327 00e4 70BD     		pop	{r4, r5, r6, pc}
 1328              	.L88:
 1329              	.LBB103:
 1330              	.LBB100:
 1331              	.LBB97:
 1332              	.LBB95:
 492:arch/stm32/mcu_periph/spi_arch.c ****     spi_start_dma_transaction(periph, periph->trans[periph->trans_extract_idx]);
 1333              		.loc 1 492 0
 1334 00e6 50F82210 		ldr	r1, [r0, r2, lsl #2]
 1335              	.LBE95:
 1336              	.LBE97:
 1337              	.LBE100:
 1338              	.LBE103:
 871:arch/stm32/mcu_periph/spi_arch.c **** }
 1339              		.loc 1 871 0
 1340 00ea 04B0     		add	sp, sp, #16
 1341 00ec BDE87040 		pop	{r4, r5, r6, lr}
 1342              	.LBB104:
 1343              	.LBB101:
 1344              	.LBB98:
 1345              	.LBB96:
 492:arch/stm32/mcu_periph/spi_arch.c ****     spi_start_dma_transaction(periph, periph->trans[periph->trans_extract_idx]);
 1346              		.loc 1 492 0
 1347 00f0 FFF7FEBF 		b	spi_start_dma_transaction
 1348              	.LVL105:
 1349              	.L102:
 1350              		.align	2
 1351              	.L101:
 1352 00f4 00000240 		.word	1073872896
 1353 00f8 04000240 		.word	1073872900
 1354 00fc 00000000 		.word	spi2
 1355 0100 000C0140 		.word	1073810432
 1356              	.LBE96:
 1357              	.LBE98:
 1358              	.LBE101:
 1359              	.LBE104:
 1360              		.cfi_endproc
 1361              	.LFE20:
 1363              		.section	.text.dma1_channel5_isr,"ax",%progbits
 1364              		.align	1
 1365              		.weak	dma1_channel5_isr
 1366              		.thumb
 1367              		.thumb_func
 1369              	dma1_channel5_isr:
 1370              	.LFB21:
 875:arch/stm32/mcu_periph/spi_arch.c **** {
 1371              		.loc 1 875 0
 1372              		.cfi_startproc
 1373              		@ args = 0, pretend = 0, frame = 0
 1374              		@ frame_needed = 0, uses_anonymous_args = 0
 1375 0000 7FB5     		push	{r0, r1, r2, r3, r4, r5, r6, lr}
 1376              	.LCFI11:
 1377              		.cfi_def_cfa_offset 32
 1378              		.cfi_offset 0, -32
 1379              		.cfi_offset 1, -28
 1380              		.cfi_offset 2, -24
 1381              		.cfi_offset 3, -20
 1382              		.cfi_offset 4, -16
 1383              		.cfi_offset 5, -12
 1384              		.cfi_offset 6, -8
 1385              		.cfi_offset 14, -4
 876:arch/stm32/mcu_periph/spi_arch.c ****   if ((DMA1_ISR & DMA_ISR_TCIF5) != 0) {
 1386              		.loc 1 876 0
 1387 0002 244B     		ldr	r3, .L109
 1388 0004 1868     		ldr	r0, [r3, #0]
 1389 0006 8203     		lsls	r2, r0, #14
 1390 0008 04D5     		bpl	.L104
 878:arch/stm32/mcu_periph/spi_arch.c ****     DMA1_IFCR |= DMA_IFCR_CTCIF5;
 1391              		.loc 1 878 0
 1392 000a 2349     		ldr	r1, .L109+4
 1393 000c 0A68     		ldr	r2, [r1, #0]
 1394 000e 42F40034 		orr	r4, r2, #131072
 1395 0012 0C60     		str	r4, [r1, #0]
 1396              	.L104:
 1397              	.LVL106:
 1398              	.LBB108:
 1399              	.LBB109:
 963:arch/stm32/mcu_periph/spi_arch.c ****       SpiSlaveUnselect(trans->slave_idx);
 964:arch/stm32/mcu_periph/spi_arch.c ****     }
 965:arch/stm32/mcu_periph/spi_arch.c **** 
 966:arch/stm32/mcu_periph/spi_arch.c ****     spi_next_transaction(periph);
 967:arch/stm32/mcu_periph/spi_arch.c ****   }
 968:arch/stm32/mcu_periph/spi_arch.c **** }
 969:arch/stm32/mcu_periph/spi_arch.c **** 
 970:arch/stm32/mcu_periph/spi_arch.c **** /// Processing done after tx completes
 971:arch/stm32/mcu_periph/spi_arch.c **** void process_tx_dma_interrupt(struct spi_periph *periph) {
 972:arch/stm32/mcu_periph/spi_arch.c ****   struct spi_periph_dma *dma = periph->init_struct;
 1400              		.loc 1 972 0
 1401 0014 214D     		ldr	r5, .L109+8
 1402 0016 EC6A     		ldr	r4, [r5, #44]
 1403              	.LVL107:
 973:arch/stm32/mcu_periph/spi_arch.c ****   struct spi_transaction *trans = periph->trans[periph->trans_extract_idx];
 1404              		.loc 1 973 0
 1405 0018 95F82160 		ldrb	r6, [r5, #33]	@ zero_extendqisi2
 974:arch/stm32/mcu_periph/spi_arch.c **** 
 975:arch/stm32/mcu_periph/spi_arch.c ****   /* Disable DMA Channel */
 976:arch/stm32/mcu_periph/spi_arch.c ****   dma_disable_transfer_complete_interrupt(dma->dma, dma->tx_chan);
 1406              		.loc 1 976 0
 1407 001c 617B     		ldrb	r1, [r4, #13]	@ zero_extendqisi2
 1408 001e A068     		ldr	r0, [r4, #8]
 973:arch/stm32/mcu_periph/spi_arch.c ****   struct spi_transaction *trans = periph->trans[periph->trans_extract_idx];
 1409              		.loc 1 973 0
 1410 0020 55F82660 		ldr	r6, [r5, r6, lsl #2]
 1411              	.LVL108:
 1412              		.loc 1 976 0
 1413 0024 FFF7FEFF 		bl	dma_disable_transfer_complete_interrupt
 1414              	.LVL109:
 977:arch/stm32/mcu_periph/spi_arch.c **** 
 978:arch/stm32/mcu_periph/spi_arch.c ****   /* Disable SPI TX request */
 979:arch/stm32/mcu_periph/spi_arch.c ****   spi_disable_tx_dma((u32)periph->reg_addr);
 1415              		.loc 1 979 0
 1416 0028 A86A     		ldr	r0, [r5, #40]
 1417 002a FFF7FEFF 		bl	spi_disable_tx_dma
 1418              	.LVL110:
 980:arch/stm32/mcu_periph/spi_arch.c **** 
 981:arch/stm32/mcu_periph/spi_arch.c ****   /* Disable DMA tx channel */
 982:arch/stm32/mcu_periph/spi_arch.c ****   dma_disable_channel(dma->dma, dma->tx_chan);
 1419              		.loc 1 982 0
 1420 002e A068     		ldr	r0, [r4, #8]
 1421 0030 617B     		ldrb	r1, [r4, #13]	@ zero_extendqisi2
 1422 0032 FFF7FEFF 		bl	dma_disable_channel
 1423              	.LVL111:
 983:arch/stm32/mcu_periph/spi_arch.c **** 
 984:arch/stm32/mcu_periph/spi_arch.c ****   if (dma->tx_extra_dummy_dma) {
 1424              		.loc 1 984 0
 1425 0036 A37C     		ldrb	r3, [r4, #18]	@ zero_extendqisi2
 1426 0038 002B     		cmp	r3, #0
 1427 003a 28D0     		beq	.L103
 1428              	.LBB110:
 985:arch/stm32/mcu_periph/spi_arch.c ****     /*
 986:arch/stm32/mcu_periph/spi_arch.c ****      * We are finished the first part of the transmit with real data,
 987:arch/stm32/mcu_periph/spi_arch.c ****      * but still need to clock in the rest of the receive data.
 988:arch/stm32/mcu_periph/spi_arch.c ****      * Set up a dummy dma transmit transfer to accomplish this.
 989:arch/stm32/mcu_periph/spi_arch.c ****      */
 990:arch/stm32/mcu_periph/spi_arch.c **** 
 991:arch/stm32/mcu_periph/spi_arch.c ****     /* Reset the flag so this only happens once in a transaction */
 992:arch/stm32/mcu_periph/spi_arch.c ****     dma->tx_extra_dummy_dma = FALSE;
 1429              		.loc 1 992 0
 1430 003c 0023     		movs	r3, #0
 1431 003e A374     		strb	r3, [r4, #18]
 1432              	.LVL112:
 993:arch/stm32/mcu_periph/spi_arch.c **** 
 994:arch/stm32/mcu_periph/spi_arch.c ****     /* Use the difference in length between tx and rx */
 995:arch/stm32/mcu_periph/spi_arch.c ****     u16 len_remaining = trans->input_length - trans->output_length;
 1433              		.loc 1 995 0
 1434 0040 727A     		ldrb	r2, [r6, #9]	@ zero_extendqisi2
 1435 0042 307A     		ldrb	r0, [r6, #8]	@ zero_extendqisi2
 996:arch/stm32/mcu_periph/spi_arch.c **** 
 997:arch/stm32/mcu_periph/spi_arch.c ****     spi_configure_dma(dma->dma, dma->tx_chan, (u32)dma->spidr,
 1436              		.loc 1 997 0
 1437 0044 617B     		ldrb	r1, [r4, #13]	@ zero_extendqisi2
 995:arch/stm32/mcu_periph/spi_arch.c ****     u16 len_remaining = trans->input_length - trans->output_length;
 1438              		.loc 1 995 0
 1439 0046 801A     		subs	r0, r0, r2
 1440              		.loc 1 997 0
 1441 0048 82B2     		uxth	r2, r0
 1442 004a 0092     		str	r2, [sp, #0]
 1443 004c B07B     		ldrb	r0, [r6, #14]	@ zero_extendqisi2
 1444 004e 0293     		str	r3, [sp, #8]
 1445 0050 0190     		str	r0, [sp, #4]
 1446 0052 04F11003 		add	r3, r4, #16
 1447 0056 6268     		ldr	r2, [r4, #4]
 1448 0058 A068     		ldr	r0, [r4, #8]
 1449 005a FFF7FEFF 		bl	spi_configure_dma
 1450              	.LVL113:
 998:arch/stm32/mcu_periph/spi_arch.c ****                       (u32)&(dma->tx_dummy_buf), len_remaining, trans->dss, FALSE);
 999:arch/stm32/mcu_periph/spi_arch.c ****     dma_set_read_from_memory(dma->dma, dma->tx_chan);
 1451              		.loc 1 999 0
 1452 005e A068     		ldr	r0, [r4, #8]
 1453 0060 617B     		ldrb	r1, [r4, #13]	@ zero_extendqisi2
 1454 0062 FFF7FEFF 		bl	dma_set_read_from_memory
 1455              	.LVL114:
1000:arch/stm32/mcu_periph/spi_arch.c ****     dma_set_priority(dma->dma, dma->tx_chan, DMA_CCR_PL_MEDIUM);
 1456              		.loc 1 1000 0
 1457 0066 4FF48052 		mov	r2, #4096
 1458 006a A068     		ldr	r0, [r4, #8]
 1459 006c 617B     		ldrb	r1, [r4, #13]	@ zero_extendqisi2
 1460 006e FFF7FEFF 		bl	dma_set_priority
 1461              	.LVL115:
1001:arch/stm32/mcu_periph/spi_arch.c **** 
1002:arch/stm32/mcu_periph/spi_arch.c ****     /* Enable DMA transfer complete interrupts. */
1003:arch/stm32/mcu_periph/spi_arch.c ****     dma_enable_transfer_complete_interrupt(dma->dma, dma->tx_chan);
 1462              		.loc 1 1003 0
 1463 0072 A068     		ldr	r0, [r4, #8]
 1464 0074 617B     		ldrb	r1, [r4, #13]	@ zero_extendqisi2
 1465 0076 FFF7FEFF 		bl	dma_enable_transfer_complete_interrupt
 1466              	.LVL116:
1004:arch/stm32/mcu_periph/spi_arch.c ****     /* Enable DMA channels */
1005:arch/stm32/mcu_periph/spi_arch.c ****     dma_enable_channel(dma->dma, dma->tx_chan);
 1467              		.loc 1 1005 0
 1468 007a A068     		ldr	r0, [r4, #8]
 1469 007c 617B     		ldrb	r1, [r4, #13]	@ zero_extendqisi2
 1470 007e FFF7FEFF 		bl	dma_enable_channel
 1471              	.LVL117:
1006:arch/stm32/mcu_periph/spi_arch.c ****     /* Enable SPI transfers via DMA */
1007:arch/stm32/mcu_periph/spi_arch.c ****     spi_enable_tx_dma((u32)periph->reg_addr);
 1472              		.loc 1 1007 0
 1473 0082 A86A     		ldr	r0, [r5, #40]
 1474              	.LBE110:
 1475              	.LBE109:
 1476              	.LBE108:
 881:arch/stm32/mcu_periph/spi_arch.c **** }
 1477              		.loc 1 881 0
 1478 0084 04B0     		add	sp, sp, #16
 1479 0086 BDE87040 		pop	{r4, r5, r6, lr}
 1480              	.LBB113:
 1481              	.LBB112:
 1482              	.LBB111:
 1483              		.loc 1 1007 0
 1484 008a FFF7FEBF 		b	spi_enable_tx_dma
 1485              	.LVL118:
 1486              	.L103:
 1487              	.LBE111:
 1488              	.LBE112:
 1489              	.LBE113:
 881:arch/stm32/mcu_periph/spi_arch.c **** }
 1490              		.loc 1 881 0
 1491 008e 04B0     		add	sp, sp, #16
 1492 0090 70BD     		pop	{r4, r5, r6, pc}
 1493              	.L110:
 1494 0092 00BF     		.align	2
 1495              	.L109:
 1496 0094 00000240 		.word	1073872896
 1497 0098 04000240 		.word	1073872900
 1498 009c 00000000 		.word	spi2
 1499              		.cfi_endproc
 1500              	.LFE21:
 1502              		.section	.bss.spi2_dma,"aw",%nobits
 1503              		.align	2
 1504              		.set	.LANCHOR0,. + 0
 1507              	spi2_dma:
 1508 0000 00000000 		.space	48
 1508      00000000 
 1508      00000000 
 1508      00000000 
 1508      00000000 
 1509              		.text
 1510              	.Letext0:
 1511              		.file 2 "/opt/local/bin/../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include/stdint.h"
 1512              		.file 3 "../ext/libopencm3/include/libopencm3/cm3/common.h"
 1513              		.file 4 "/Users/tony-yi/git/paparazzi_local/sw/include/std.h"
 1514              		.file 5 "./mcu_periph/spi.h"
 1515              		.file 6 "../ext/libopencm3/include/libopencm3/stm32/common/dma_common_f13.h"
 1516              		.file 7 "../ext/libopencm3/include/libopencm3/cm3/nvic.h"
 1517              		.file 8 "../ext/libopencm3/include/libopencm3/stm32/common/gpio_common_all.h"
 1518              		.file 9 "../ext/libopencm3/include/libopencm3/stm32/common/spi_common_all.h"
 1519              		.file 10 "./mcu_periph/gpio.h"
 1520              		.file 11 "../ext/libopencm3/include/libopencm3/stm32/f1/rcc.h"
 1521              		.file 12 "../ext/libopencm3/include/libopencm3/stm32/f1/gpio.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 spi_arch.c
/var/tmp//ccBtSxf2.s:19     .text.spi_configure_dma:0000000000000000 $t
/var/tmp//ccBtSxf2.s:23     .text.spi_configure_dma:0000000000000000 spi_configure_dma
/var/tmp//ccBtSxf2.s:119    .text.spi_arch_int_enable:0000000000000000 $t
/var/tmp//ccBtSxf2.s:123    .text.spi_arch_int_enable:0000000000000000 spi_arch_int_enable
/var/tmp//ccBtSxf2.s:168    .text.spi_arch_int_disable:0000000000000000 $t
/var/tmp//ccBtSxf2.s:172    .text.spi_arch_int_disable:0000000000000000 spi_arch_int_disable
/var/tmp//ccBtSxf2.s:205    .text.spi_start_dma_transaction:0000000000000000 $t
/var/tmp//ccBtSxf2.s:209    .text.spi_start_dma_transaction:0000000000000000 spi_start_dma_transaction
/var/tmp//ccBtSxf2.s:326    .text.spi_start_dma_transaction:000000000000005e $d
/var/tmp//ccBtSxf2.s:334    .text.spi_start_dma_transaction:0000000000000066 $t
/var/tmp//ccBtSxf2.s:560    .text.spi_start_dma_transaction:00000000000001a8 $d
/var/tmp//ccBtSxf2.s:565    .text.spi_slave_select:0000000000000000 $t
/var/tmp//ccBtSxf2.s:570    .text.spi_slave_select:0000000000000000 spi_slave_select
/var/tmp//ccBtSxf2.s:606    .text.spi_slave_select:0000000000000010 $d
/var/tmp//ccBtSxf2.s:615    .text.spi_slave_unselect:0000000000000000 $t
/var/tmp//ccBtSxf2.s:620    .text.spi_slave_unselect:0000000000000000 spi_slave_unselect
/var/tmp//ccBtSxf2.s:656    .text.spi_slave_unselect:0000000000000010 $d
/var/tmp//ccBtSxf2.s:665    .text.spi_init_slaves:0000000000000000 $t
/var/tmp//ccBtSxf2.s:670    .text.spi_init_slaves:0000000000000000 spi_init_slaves
/var/tmp//ccBtSxf2.s:707    .text.spi_init_slaves:000000000000001c $d
/var/tmp//ccBtSxf2.s:715    .text.spi_submit:0000000000000000 $t
/var/tmp//ccBtSxf2.s:720    .text.spi_submit:0000000000000000 spi_submit
/var/tmp//ccBtSxf2.s:807    .text.spi_lock:0000000000000000 $t
/var/tmp//ccBtSxf2.s:812    .text.spi_lock:0000000000000000 spi_lock
/var/tmp//ccBtSxf2.s:864    .text.spi_resume:0000000000000000 $t
/var/tmp//ccBtSxf2.s:869    .text.spi_resume:0000000000000000 spi_resume
/var/tmp//ccBtSxf2.s:932    .text.spi2_arch_init:0000000000000000 $t
/var/tmp//ccBtSxf2.s:937    .text.spi2_arch_init:0000000000000000 spi2_arch_init
/var/tmp//ccBtSxf2.s:1121   .text.spi2_arch_init:00000000000000d0 $d
/var/tmp//ccBtSxf2.s:1134   .text.dma1_channel4_isr:0000000000000000 $t
/var/tmp//ccBtSxf2.s:1139   .text.dma1_channel4_isr:0000000000000000 dma1_channel4_isr
/var/tmp//ccBtSxf2.s:1352   .text.dma1_channel4_isr:00000000000000f4 $d
/var/tmp//ccBtSxf2.s:1364   .text.dma1_channel5_isr:0000000000000000 $t
/var/tmp//ccBtSxf2.s:1369   .text.dma1_channel5_isr:0000000000000000 dma1_channel5_isr
/var/tmp//ccBtSxf2.s:1496   .text.dma1_channel5_isr:0000000000000094 $d
/var/tmp//ccBtSxf2.s:1503   .bss.spi2_dma:0000000000000000 $d
/var/tmp//ccBtSxf2.s:1507   .bss.spi2_dma:0000000000000000 spi2_dma
                     .debug_frame:0000000000000010 $d

UNDEFINED SYMBOLS
dma_channel_reset
dma_set_peripheral_address
dma_set_memory_address
dma_set_number_of_data
dma_set_peripheral_size
dma_set_memory_size
dma_enable_memory_increment_mode
dma_disable_memory_increment_mode
nvic_set_priority
nvic_enable_irq
nvic_disable_irq
spi_disable
spi_init_master
spi_enable_software_slave_management
spi_set_nss_high
spi_enable
gpio_clear
dma_set_read_from_peripheral
dma_set_priority
dma_set_read_from_memory
dma_enable_transfer_complete_interrupt
dma_enable_channel
spi_enable_rx_dma
spi_enable_tx_dma
gpio_set
gpio_setup_output
rcc_peripheral_enable_clock
gpio_set_mode
spi_reset
spi2
dma_disable_transfer_complete_interrupt
spi_disable_rx_dma
dma_disable_channel
spi_disable_tx_dma
