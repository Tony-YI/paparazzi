   1              		.syntax unified
   2              		.cpu cortex-m3
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 4
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.thumb
  14              		.file	"ins_int.c"
  15              		.text
  16              	.Ltext0:
  17              		.cfi_sections	.debug_frame
  18              		.section	.text.stateSetAccelNed_i.constprop.0,"ax",%progbits
  19              		.align	1
  20              		.thumb
  21              		.thumb_func
  23              	stateSetAccelNed_i.constprop.0:
  24              	.LFB135:
  25              		.file 1 "./state.h"
   1:./state.h     **** /*
   2:./state.h     ****  * Copyright (C) 2011-2012 Felix Ruess <felix.ruess@gmail.com>
   3:./state.h     ****  *
   4:./state.h     ****  * This file is part of paparazzi.
   5:./state.h     ****  *
   6:./state.h     ****  * paparazzi is free software; you can redistribute it and/or modify
   7:./state.h     ****  * it under the terms of the GNU General Public License as published by
   8:./state.h     ****  * the Free Software Foundation; either version 2, or (at your option)
   9:./state.h     ****  * any later version.
  10:./state.h     ****  *
  11:./state.h     ****  * paparazzi is distributed in the hope that it will be useful,
  12:./state.h     ****  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  13:./state.h     ****  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  14:./state.h     ****  * GNU General Public License for more details.
  15:./state.h     ****  *
  16:./state.h     ****  * You should have received a copy of the GNU General Public License
  17:./state.h     ****  * along with paparazzi; see the file COPYING.  If not, see
  18:./state.h     ****  * <http://www.gnu.org/licenses/>.
  19:./state.h     ****  */
  20:./state.h     **** 
  21:./state.h     **** /**
  22:./state.h     ****  * @file state.h
  23:./state.h     ****  *
  24:./state.h     ****  * API to get/set the generic vehicle states.
  25:./state.h     ****  *
  26:./state.h     ****  * Also see the @ref state_interface "State Interface" page.
  27:./state.h     ****  *
  28:./state.h     ****  * @author Felix Ruess <felix.ruess@gmail.com>
  29:./state.h     ****  */
  30:./state.h     **** 
  31:./state.h     **** #ifndef STATE_H
  32:./state.h     **** #define STATE_H
  33:./state.h     **** 
  34:./state.h     **** #include "math/pprz_algebra_int.h"
  35:./state.h     **** #include "math/pprz_algebra_float.h"
  36:./state.h     **** #include "math/pprz_geodetic_int.h"
  37:./state.h     **** #include "math/pprz_geodetic_float.h"
  38:./state.h     **** #include "math/pprz_orientation_conversion.h"
  39:./state.h     **** 
  40:./state.h     **** #include "std.h"
  41:./state.h     **** #include <string.h>
  42:./state.h     **** 
  43:./state.h     **** /**
  44:./state.h     ****  * This general state interface holds all the most important vehicle states like
  45:./state.h     ****  * position, velocity, attitude, etc. It handles coordinate system and
  46:./state.h     ****  * fixed-/floating-point conversion on the fly when needed.
  47:./state.h     ****  *
  48:./state.h     ****  * You can set e.g. the position in any coordinate system you wish:
  49:./state.h     ****  * stateSetPositionNed_i() to set the position in fixed-point NED coordinates.
  50:./state.h     ****  * If you need to read the position somewhere else in a different representation,
  51:./state.h     ****  * call: stateGetPositionLla_f() and only then the LLA float position representation
  52:./state.h     ****  * is calculated on the fly and returned. It's also only calculated once,
  53:./state.h     ****  * until a new position is set which invalidates all the other representations again.
  54:./state.h     ****  */
  55:./state.h     **** 
  56:./state.h     **** /**
  57:./state.h     ****  * @defgroup state_interface State interface
  58:./state.h     ****  * @{
  59:./state.h     ****  */
  60:./state.h     **** 
  61:./state.h     **** /**
  62:./state.h     ****  * @defgroup state_position Position representations
  63:./state.h     ****  * @{
  64:./state.h     ****  */
  65:./state.h     **** #define POS_ECEF_I 0
  66:./state.h     **** #define POS_NED_I  1
  67:./state.h     **** #define POS_ENU_I  2
  68:./state.h     **** #define POS_LLA_I  3
  69:./state.h     **** #define POS_UTM_I  4
  70:./state.h     **** #define POS_ECEF_F 5
  71:./state.h     **** #define POS_NED_F  6
  72:./state.h     **** #define POS_ENU_F  7
  73:./state.h     **** #define POS_LLA_F  8
  74:./state.h     **** #define POS_UTM_F  9
  75:./state.h     **** #define POS_LOCAL_COORD ((1<<POS_NED_I)|(1<<POS_NED_F)|(1<<POS_ENU_I)|(1<<POS_ENU_F))
  76:./state.h     **** #define POS_GLOBAL_COORD ((1<<POS_ECEF_I)|(1<<POS_ECEF_F)|(1<<POS_LLA_I)|(1<<POS_LLA_F)|(1<<POS_UTM
  77:./state.h     **** /**@}*/
  78:./state.h     **** 
  79:./state.h     **** /**
  80:./state.h     ****  * @defgroup state_velocity Speed representations
  81:./state.h     ****  * @{
  82:./state.h     ****  */
  83:./state.h     **** #define SPEED_ECEF_I  0
  84:./state.h     **** #define SPEED_NED_I   1
  85:./state.h     **** #define SPEED_ENU_I   2
  86:./state.h     **** #define SPEED_HNORM_I 3
  87:./state.h     **** #define SPEED_HDIR_I  4
  88:./state.h     **** #define SPEED_ECEF_F  5
  89:./state.h     **** #define SPEED_NED_F   6
  90:./state.h     **** #define SPEED_ENU_F   7
  91:./state.h     **** #define SPEED_HNORM_F 8
  92:./state.h     **** #define SPEED_HDIR_F  9
  93:./state.h     **** #define SPEED_LOCAL_COORD ((1<<SPEED_NED_I)|(1<<SPEED_ENU_I)|(1<<SPEED_NED_F)|(1<<SPEED_ENU_F))
  94:./state.h     **** /**@}*/
  95:./state.h     **** 
  96:./state.h     **** /**
  97:./state.h     ****  * @defgroup state_acceleration Acceleration representations
  98:./state.h     ****  * @{
  99:./state.h     ****  */
 100:./state.h     **** #define ACCEL_ECEF_I 0
 101:./state.h     **** #define ACCEL_NED_I  1
 102:./state.h     **** #define ACCEL_ECEF_F 2
 103:./state.h     **** #define ACCEL_NED_F  3
 104:./state.h     **** /**@}*/
 105:./state.h     **** 
 106:./state.h     **** /**
 107:./state.h     ****  * @defgroup state_rate Angular rate representations
 108:./state.h     ****  * @{
 109:./state.h     ****  */
 110:./state.h     **** #define RATE_I 0
 111:./state.h     **** #define RATE_F 1
 112:./state.h     **** /**@}*/
 113:./state.h     **** 
 114:./state.h     **** /**
 115:./state.h     ****  * @defgroup state_wind_airspeed Wind- and airspeed representations
 116:./state.h     ****  * @{
 117:./state.h     ****  */
 118:./state.h     **** #define WINDSPEED_I 0
 119:./state.h     **** #define AIRSPEED_I  1
 120:./state.h     **** #define WINDSPEED_F 2
 121:./state.h     **** #define AIRSPEED_F  3
 122:./state.h     **** #define AOA_F       4
 123:./state.h     **** #define SIDESLIP_F  5
 124:./state.h     **** /**@}*/
 125:./state.h     **** 
 126:./state.h     **** 
 127:./state.h     **** /**
 128:./state.h     ****  * Structure holding vehicle state data.
 129:./state.h     ****  */
 130:./state.h     **** struct State {
 131:./state.h     **** 
 132:./state.h     ****   /** @addtogroup state_position
 133:./state.h     ****    *  @{ */
 134:./state.h     **** 
 135:./state.h     ****   /**
 136:./state.h     ****    * Holds the status bits for all position representations.
 137:./state.h     ****    * When the corresponding bit is set the representation
 138:./state.h     ****    * is already computed.
 139:./state.h     ****    */
 140:./state.h     ****   uint16_t pos_status;
 141:./state.h     **** 
 142:./state.h     ****   /**
 143:./state.h     ****    * Position in EarthCenteredEarthFixed coordinates.
 144:./state.h     ****    * Units: centimeters
 145:./state.h     ****    */
 146:./state.h     ****   struct EcefCoor_i ecef_pos_i;
 147:./state.h     **** 
 148:./state.h     ****   /**
 149:./state.h     ****    * Position in Latitude, Longitude and Altitude.
 150:./state.h     ****    * Units lat,lon: radians*1e7
 151:./state.h     ****    * Units alt: milimeters above reference ellipsoid
 152:./state.h     ****    */
 153:./state.h     ****   struct LlaCoor_i lla_pos_i;
 154:./state.h     **** 
 155:./state.h     ****   /**
 156:./state.h     ****    * Definition of the local (flat earth) coordinate system.
 157:./state.h     ****    * Defines the origin of the local NorthEastDown coordinate system
 158:./state.h     ****    * in ECEF (EarthCenteredEarthFixed) and LLA (LatitudeLongitudeAlt)
 159:./state.h     ****    * coordinates and the roation matrix from ECEF to local frame.
 160:./state.h     ****    * (int version)
 161:./state.h     ****    */
 162:./state.h     ****   struct LtpDef_i ned_origin_i;
 163:./state.h     **** 
 164:./state.h     ****   /**
 165:./state.h     ****    * true if local int coordinate frame is initialsed
 166:./state.h     ****    */
 167:./state.h     ****   bool_t ned_initialized_i;
 168:./state.h     **** 
 169:./state.h     ****   /**
 170:./state.h     ****    * Position in North East Down coordinates.
 171:./state.h     ****    * with respect to ned_origin_i (flat earth)
 172:./state.h     ****    * Units: m in BFP with INT32_POS_FRAC
 173:./state.h     ****    */
 174:./state.h     ****   struct NedCoor_i ned_pos_i;
 175:./state.h     **** 
 176:./state.h     ****   /**
 177:./state.h     ****    * Position in East North Up coordinates.
 178:./state.h     ****    * with respect to ned_origin_i (flat earth)
 179:./state.h     ****    * Units: m in BFP with INT32_POS_FRAC
 180:./state.h     ****    */
 181:./state.h     ****   struct EnuCoor_i enu_pos_i;
 182:./state.h     **** 
 183:./state.h     ****   /**
 184:./state.h     ****    * Position in UTM coordinates.
 185:./state.h     ****    * Units x,y: meters.
 186:./state.h     ****    * Units z: meters above MSL
 187:./state.h     ****    */
 188:./state.h     ****   struct UtmCoor_f utm_pos_f;
 189:./state.h     **** 
 190:./state.h     ****   /**
 191:./state.h     ****    * Altitude above ground level.
 192:./state.h     ****    * Unit: meters
 193:./state.h     ****    */
 194:./state.h     ****   float alt_agl_f;
 195:./state.h     **** 
 196:./state.h     ****   /**
 197:./state.h     ****    * Position in Latitude, Longitude and Altitude.
 198:./state.h     ****    * Units lat,lon: radians
 199:./state.h     ****    * Units alt: meters above reference ellipsoid
 200:./state.h     ****    */
 201:./state.h     ****   struct LlaCoor_f lla_pos_f;
 202:./state.h     **** 
 203:./state.h     ****   /**
 204:./state.h     ****    * Position in EarthCenteredEarthFixed coordinates.
 205:./state.h     ****    * Units: meters
 206:./state.h     ****    */
 207:./state.h     ****   struct EcefCoor_f ecef_pos_f;
 208:./state.h     **** 
 209:./state.h     ****   /**
 210:./state.h     ****    * Definition of the local (flat earth) coordinate system.
 211:./state.h     ****    * Defines the origin of the local NorthEastDown coordinate system
 212:./state.h     ****    * in ECEF (EarthCenteredEarthFixed) and LLA (LatitudeLongitudeAlt)
 213:./state.h     ****    * coordinates and the roation matrix from ECEF to local frame.
 214:./state.h     ****    * (float version)
 215:./state.h     ****    */
 216:./state.h     ****   struct LtpDef_f ned_origin_f;
 217:./state.h     **** 
 218:./state.h     ****   /// True if local float coordinate frame is initialsed
 219:./state.h     ****   bool_t ned_initialized_f;
 220:./state.h     **** 
 221:./state.h     ****   /**
 222:./state.h     ****    * Definition of the origin of Utm coordinate system.
 223:./state.h     ****    * Defines the origin of the local NorthEastDown coordinate system
 224:./state.h     ****    * in UTM coordinates, used as a reference when ned_origin is not
 225:./state.h     ****    * initialized.
 226:./state.h     ****    * (float version)
 227:./state.h     ****    */
 228:./state.h     ****   struct UtmCoor_f utm_origin_f;
 229:./state.h     **** 
 230:./state.h     ****   /// True if utm origin (float) coordinate frame is initialsed
 231:./state.h     ****   bool_t utm_initialized_f;
 232:./state.h     **** 
 233:./state.h     ****   /**
 234:./state.h     ****    * Position in North East Down coordinates.
 235:./state.h     ****    * with respect to ned_origin_i (flat earth)
 236:./state.h     ****    * Units: meters
 237:./state.h     ****    */
 238:./state.h     ****   struct NedCoor_f ned_pos_f;
 239:./state.h     **** 
 240:./state.h     ****   /**
 241:./state.h     ****    * Position in East North Up coordinates.
 242:./state.h     ****    * with respect to ned_origin_i (flat earth)
 243:./state.h     ****    * Units: meters
 244:./state.h     ****    */
 245:./state.h     ****   struct EnuCoor_f enu_pos_f;
 246:./state.h     ****   /** @}*/
 247:./state.h     **** 
 248:./state.h     **** 
 249:./state.h     ****   /** @addtogroup state_velocity
 250:./state.h     ****    *  @{ */
 251:./state.h     ****   /**
 252:./state.h     ****    * Holds the status bits for all ground speed representations.
 253:./state.h     ****    * When the corresponding bit is one the representation
 254:./state.h     ****    * is already computed.
 255:./state.h     ****    */
 256:./state.h     ****   uint16_t speed_status;
 257:./state.h     **** 
 258:./state.h     ****   /**
 259:./state.h     ****    * Velocity in EarthCenteredEarthFixed coordinates.
 260:./state.h     ****    * Units: m/s in BFP with #INT32_SPEED_FRAC
 261:./state.h     ****    */
 262:./state.h     ****   struct EcefCoor_i ecef_speed_i;
 263:./state.h     **** 
 264:./state.h     ****   /**
 265:./state.h     ****    * Velocity in North East Down coordinates.
 266:./state.h     ****    * Units: m/s in BFP with #INT32_SPEED_FRAC
 267:./state.h     ****    */
 268:./state.h     ****   struct NedCoor_i ned_speed_i;
 269:./state.h     **** 
 270:./state.h     ****   /**
 271:./state.h     ****    * Velocity in East North Up coordinates.
 272:./state.h     ****    * Units: m/s in BFP with #INT32_SPEED_FRAC
 273:./state.h     ****    */
 274:./state.h     ****   struct EnuCoor_i enu_speed_i;
 275:./state.h     **** 
 276:./state.h     ****   /**
 277:./state.h     ****    * Norm of horizontal ground speed.
 278:./state.h     ****    * Unit: m/s in BFP with #INT32_SPEED_FRAC
 279:./state.h     ****    */
 280:./state.h     ****   int32_t h_speed_norm_i;
 281:./state.h     **** 
 282:./state.h     ****   /**
 283:./state.h     ****    * Direction of horizontal ground speed.
 284:./state.h     ****    * Unit: rad in BFP with #INT32_ANGLE_FRAC
 285:./state.h     ****    * (clockwise, zero=north)
 286:./state.h     ****    */
 287:./state.h     ****   int32_t h_speed_dir_i;
 288:./state.h     **** 
 289:./state.h     ****   /**
 290:./state.h     ****    * Velocity in EarthCenteredEarthFixed coordinates.
 291:./state.h     ****    * Units: m/s
 292:./state.h     ****    */
 293:./state.h     ****   struct EcefCoor_f ecef_speed_f;
 294:./state.h     **** 
 295:./state.h     ****   /**
 296:./state.h     ****    * @brief speed in North East Down coordinates
 297:./state.h     ****    * @details Units: m/s */
 298:./state.h     ****   struct NedCoor_f ned_speed_f;
 299:./state.h     **** 
 300:./state.h     ****   /**
 301:./state.h     ****    * Velocity in East North Up coordinates.
 302:./state.h     ****    * Units: m/s
 303:./state.h     ****    */
 304:./state.h     ****   struct EnuCoor_f enu_speed_f;
 305:./state.h     **** 
 306:./state.h     ****   /**
 307:./state.h     ****    * Norm of horizontal ground speed.
 308:./state.h     ****    * Unit: m/s
 309:./state.h     ****    */
 310:./state.h     ****   float h_speed_norm_f;
 311:./state.h     **** 
 312:./state.h     ****   /**
 313:./state.h     ****    * Direction of horizontal ground speed.
 314:./state.h     ****    * Unit: rad (clockwise, zero=north)
 315:./state.h     ****    */
 316:./state.h     ****   float h_speed_dir_f;
 317:./state.h     ****   /** @}*/
 318:./state.h     **** 
 319:./state.h     **** 
 320:./state.h     ****   /** @addtogroup state_acceleration
 321:./state.h     ****    *  @{ */
 322:./state.h     ****   /**
 323:./state.h     ****    * Holds the status bits for all acceleration representations.
 324:./state.h     ****    * When the corresponding bit is one the representation
 325:./state.h     ****    * is already computed.
 326:./state.h     ****    */
 327:./state.h     ****   uint8_t accel_status;
 328:./state.h     **** 
 329:./state.h     ****   /**
 330:./state.h     ****    * Acceleration in North East Down coordinates.
 331:./state.h     ****    * Units: m/s^2 in BFP with #INT32_ACCEL_FRAC
 332:./state.h     ****    */
 333:./state.h     ****   struct NedCoor_i ned_accel_i;
 334:./state.h     **** 
 335:./state.h     ****   /**
 336:./state.h     ****    * Acceleration in EarthCenteredEarthFixed coordinates.
 337:./state.h     ****    * Units: m/s^2 in BFP with INT32_ACCEL_FRAC
 338:./state.h     ****    */
 339:./state.h     ****   struct EcefCoor_i ecef_accel_i;
 340:./state.h     **** 
 341:./state.h     ****   /**
 342:./state.h     ****    * Acceleration in North East Down coordinates.
 343:./state.h     ****    * Units: m/s^2
 344:./state.h     ****    */
 345:./state.h     ****   struct NedCoor_f ned_accel_f;
 346:./state.h     **** 
 347:./state.h     ****   /**
 348:./state.h     ****    * Acceleration in EarthCenteredEarthFixed coordinates.
 349:./state.h     ****    * Units: m/s^2
 350:./state.h     ****    */
 351:./state.h     ****   struct EcefCoor_f ecef_accel_f;
 352:./state.h     ****   /** @}*/
 353:./state.h     **** 
 354:./state.h     **** 
 355:./state.h     ****   /** @defgroup state_attitude Attitude representations
 356:./state.h     ****    */
 357:./state.h     ****   struct OrientationReps ned_to_body_orientation;
 358:./state.h     **** 
 359:./state.h     **** 
 360:./state.h     ****   /** @addtogroup state_rate
 361:./state.h     ****    *  @{ */
 362:./state.h     ****   /**
 363:./state.h     ****    * Holds the status bits for all angular rate representations.
 364:./state.h     ****    * When the corresponding bit is one the representation
 365:./state.h     ****    * is already computed.
 366:./state.h     ****    */
 367:./state.h     ****   uint8_t rate_status;
 368:./state.h     **** 
 369:./state.h     ****   /**
 370:./state.h     ****    * Angular rates in body frame.
 371:./state.h     ****    * Units: rad/s in BFP with #INT32_RATE_FRAC
 372:./state.h     ****    */
 373:./state.h     ****   struct Int32Rates  body_rates_i;
 374:./state.h     **** 
 375:./state.h     ****   /**
 376:./state.h     ****    * Angular rates in body frame.
 377:./state.h     ****    * Units: rad/s
 378:./state.h     ****    */
 379:./state.h     ****   struct FloatRates  body_rates_f;
 380:./state.h     ****   /** @}*/
 381:./state.h     **** 
 382:./state.h     **** 
 383:./state.h     ****   /** @addtogroup state_wind_airspeed
 384:./state.h     ****    *  @{ */
 385:./state.h     ****   /**
 386:./state.h     ****    * Holds the status bits for all wind- and airspeed representations.
 387:./state.h     ****    * When the corresponding bit is one the representation
 388:./state.h     ****    * is already computed.
 389:./state.h     ****    */
 390:./state.h     ****   uint8_t wind_air_status;
 391:./state.h     **** 
 392:./state.h     ****   /**
 393:./state.h     ****    * Horizontal windspeed in north/east.
 394:./state.h     ****    * Units: m/s in BFP with #INT32_SPEED_FRAC
 395:./state.h     ****    */
 396:./state.h     ****   struct Int32Vect2 h_windspeed_i;
 397:./state.h     **** 
 398:./state.h     ****   /**
 399:./state.h     ****    * Norm of horizontal ground speed.
 400:./state.h     ****    * @details Unit: m/s in BFP with #INT32_SPEED_FRAC
 401:./state.h     ****    */
 402:./state.h     ****   int32_t airspeed_i;
 403:./state.h     **** 
 404:./state.h     ****   /**
 405:./state.h     ****    * Horizontal windspeed.
 406:./state.h     ****    * Units: m/s with x=north, y=east
 407:./state.h     ****    */
 408:./state.h     ****   struct FloatVect2 h_windspeed_f;
 409:./state.h     **** 
 410:./state.h     ****   /**
 411:./state.h     ****    * Norm of relative air speed.
 412:./state.h     ****    * Unit: m/s
 413:./state.h     ****    */
 414:./state.h     ****   float airspeed_f;
 415:./state.h     **** 
 416:./state.h     ****   /**
 417:./state.h     ****    * Angle of attack
 418:./state.h     ****    * Unit: rad
 419:./state.h     ****    */
 420:./state.h     ****   float angle_of_attack_f;
 421:./state.h     **** 
 422:./state.h     ****   /**
 423:./state.h     ****    * Sideslip angle
 424:./state.h     ****    * Unit: rad
 425:./state.h     ****    */
 426:./state.h     ****   float sideslip_f;
 427:./state.h     **** 
 428:./state.h     ****   /** @}*/
 429:./state.h     **** 
 430:./state.h     **** };
 431:./state.h     **** 
 432:./state.h     **** extern struct State state;
 433:./state.h     **** 
 434:./state.h     **** extern void stateInit(void);
 435:./state.h     **** 
 436:./state.h     **** /** @addtogroup state_position
 437:./state.h     ****  *  @{ */
 438:./state.h     **** 
 439:./state.h     **** /// Set the local (flat earth) coordinate frame origin (int).
 440:./state.h     **** static inline void stateSetLocalOrigin_i(struct LtpDef_i* ltp_def) {
 441:./state.h     ****   memcpy(&state.ned_origin_i, ltp_def, sizeof(struct LtpDef_i));
 442:./state.h     ****   /* convert to float */
 443:./state.h     ****   ECEF_FLOAT_OF_BFP(state.ned_origin_f.ecef, state.ned_origin_i.ecef);
 444:./state.h     ****   LLA_FLOAT_OF_BFP(state.ned_origin_f.lla, state.ned_origin_i.lla);
 445:./state.h     ****   RMAT_FLOAT_OF_BFP(state.ned_origin_f.ltp_of_ecef, state.ned_origin_i.ltp_of_ecef);
 446:./state.h     ****   state.ned_origin_f.hmsl = M_OF_MM(state.ned_origin_i.hmsl);
 447:./state.h     **** 
 448:./state.h     ****   /* clear bits for all local frame representations */
 449:./state.h     ****   state.pos_status &= ~(POS_LOCAL_COORD);
 450:./state.h     ****   state.speed_status &= ~(SPEED_LOCAL_COORD);
 451:./state.h     ****   ClearBit(state.accel_status, ACCEL_NED_I);
 452:./state.h     ****   ClearBit(state.accel_status, ACCEL_NED_F);
 453:./state.h     **** 
 454:./state.h     ****   state.ned_initialized_i = TRUE;
 455:./state.h     ****   state.ned_initialized_f = TRUE;
 456:./state.h     **** }
 457:./state.h     **** 
 458:./state.h     **** /// Set the local (flat earth) coordinate frame origin from UTM (float).
 459:./state.h     **** static inline void stateSetLocalUtmOrigin_f(struct UtmCoor_f* utm_def) {
 460:./state.h     ****   memcpy(&state.utm_origin_f, utm_def, sizeof(struct UtmCoor_f));
 461:./state.h     ****   state.utm_initialized_f = TRUE;
 462:./state.h     **** 
 463:./state.h     ****   /* clear bits for all local frame representations */
 464:./state.h     ****   state.pos_status &= ~(POS_LOCAL_COORD);
 465:./state.h     ****   state.speed_status &= ~(SPEED_LOCAL_COORD);
 466:./state.h     ****   ClearBit(state.accel_status, ACCEL_NED_I);
 467:./state.h     ****   ClearBit(state.accel_status, ACCEL_NED_F);
 468:./state.h     **** }
 469:./state.h     **** /*******************************************************************************
 470:./state.h     ****  *                                                                             *
 471:./state.h     ****  * Set and Get functions for the POSITION representations                      *
 472:./state.h     ****  *                                                                             *
 473:./state.h     ****  ******************************************************************************/
 474:./state.h     **** 
 475:./state.h     **** /************* declaration of transformation functions ************/
 476:./state.h     **** extern void stateCalcPositionEcef_i(void);
 477:./state.h     **** extern void stateCalcPositionNed_i(void);
 478:./state.h     **** extern void stateCalcPositionEnu_i(void);
 479:./state.h     **** extern void stateCalcPositionLla_i(void);
 480:./state.h     **** extern void stateCalcPositionUtm_f(void);
 481:./state.h     **** extern void stateCalcPositionEcef_f(void);
 482:./state.h     **** extern void stateCalcPositionNed_f(void);
 483:./state.h     **** extern void stateCalcPositionEnu_f(void);
 484:./state.h     **** extern void stateCalcPositionLla_f(void);
 485:./state.h     **** 
 486:./state.h     **** /*********************** validity test functions ******************/
 487:./state.h     **** 
 488:./state.h     **** /// Test if local coordinates are valid.
 489:./state.h     **** static inline bool_t stateIsLocalCoordinateValid(void) {
 490:./state.h     ****   return ((state.ned_initialized_i || state.utm_initialized_f) && (state.pos_status & (POS_LOCAL_CO
 491:./state.h     **** }
 492:./state.h     **** 
 493:./state.h     **** /// Test if global coordinates are valid.
 494:./state.h     **** static inline bool_t stateIsGlobalCoordinateValid(void) {
 495:./state.h     ****   return ((state.pos_status & (POS_GLOBAL_COORD)) || stateIsLocalCoordinateValid());
 496:./state.h     **** }
 497:./state.h     **** 
 498:./state.h     **** /************************ Set functions ****************************/
 499:./state.h     **** 
 500:./state.h     **** /// Set position from ECEF coordinates (int).
 501:./state.h     **** static inline void stateSetPositionEcef_i(struct EcefCoor_i* ecef_pos) {
 502:./state.h     ****   INT32_VECT3_COPY(state.ecef_pos_i, *ecef_pos);
 503:./state.h     ****   /* clear bits for all position representations and only set the new one */
 504:./state.h     ****   state.pos_status = (1 << POS_ECEF_I);
 505:./state.h     **** }
 506:./state.h     **** 
 507:./state.h     **** /// Set position from local NED coordinates (int).
 508:./state.h     **** static inline void stateSetPositionNed_i(struct NedCoor_i* ned_pos) {
 509:./state.h     ****   INT32_VECT3_COPY(state.ned_pos_i, *ned_pos);
 510:./state.h     ****   /* clear bits for all position representations and only set the new one */
 511:./state.h     ****   state.pos_status = (1 << POS_NED_I);
 512:./state.h     **** }
 513:./state.h     **** 
 514:./state.h     **** /// Set position from local ENU coordinates (int).
 515:./state.h     **** static inline void stateSetPositionEnu_i(struct EnuCoor_i* enu_pos) {
 516:./state.h     ****   INT32_VECT3_COPY(state.enu_pos_i, *enu_pos);
 517:./state.h     ****   /* clear bits for all position representations and only set the new one */
 518:./state.h     ****   state.pos_status = (1 << POS_ENU_I);
 519:./state.h     **** }
 520:./state.h     **** 
 521:./state.h     **** /// Set position from LLA coordinates (int).
 522:./state.h     **** static inline void stateSetPositionLla_i(struct LlaCoor_i* lla_pos) {
 523:./state.h     ****   LLA_COPY(state.lla_pos_i, *lla_pos);
 524:./state.h     ****   /* clear bits for all position representations and only set the new one */
 525:./state.h     ****   state.pos_status = (1 << POS_LLA_I);
 526:./state.h     **** }
 527:./state.h     **** 
 528:./state.h     **** /// Set multiple position coordinates (int).
 529:./state.h     **** static inline void stateSetPosition_i(
 530:./state.h     ****     struct EcefCoor_i* ecef_pos,
 531:./state.h     ****     struct NedCoor_i* ned_pos,
 532:./state.h     ****     struct EnuCoor_i* enu_pos,
 533:./state.h     ****     struct LlaCoor_i* lla_pos) {
 534:./state.h     ****   /* clear all status bit */
 535:./state.h     ****   state.pos_status = 0;
 536:./state.h     ****   if (ecef_pos != NULL) {
 537:./state.h     ****     INT32_VECT3_COPY(state.ecef_pos_i, *ecef_pos);
 538:./state.h     ****     state.pos_status |= (1 << POS_ECEF_I);
 539:./state.h     ****   }
 540:./state.h     ****   if (ned_pos != NULL) {
 541:./state.h     ****     INT32_VECT3_COPY(state.ned_pos_i, *ned_pos);
 542:./state.h     ****     state.pos_status |= (1 << POS_NED_I);
 543:./state.h     ****   }
 544:./state.h     ****   if (enu_pos != NULL) {
 545:./state.h     ****     INT32_VECT3_COPY(state.enu_pos_i, *enu_pos);
 546:./state.h     ****     state.pos_status |= (1 << POS_ENU_I);
 547:./state.h     ****   }
 548:./state.h     ****   if (lla_pos != NULL) {
 549:./state.h     ****     LLA_COPY(state.lla_pos_i, *lla_pos);
 550:./state.h     ****     state.pos_status |= (1 << POS_LLA_I);
 551:./state.h     ****   }
 552:./state.h     **** }
 553:./state.h     **** 
 554:./state.h     **** /// Set position from UTM coordinates (float).
 555:./state.h     **** static inline void stateSetPositionUtm_f(struct UtmCoor_f* utm_pos) {
 556:./state.h     ****   memcpy(&state.utm_pos_f, utm_pos, sizeof(struct UtmCoor_f));
 557:./state.h     ****   /* clear bits for all position representations and only set the new one */
 558:./state.h     ****   state.pos_status = (1 << POS_UTM_F);
 559:./state.h     **** }
 560:./state.h     **** 
 561:./state.h     **** /// Set position from ECEF coordinates (float).
 562:./state.h     **** static inline void stateSetPositionEcef_f(struct EcefCoor_f* ecef_pos) {
 563:./state.h     ****   VECT3_COPY(state.ecef_pos_f, *ecef_pos);
 564:./state.h     ****   /* clear bits for all position representations and only set the new one */
 565:./state.h     ****   state.pos_status = (1 << POS_ECEF_F);
 566:./state.h     **** }
 567:./state.h     **** 
 568:./state.h     **** /// Set position from local NED coordinates (float).
 569:./state.h     **** static inline void stateSetPositionNed_f(struct NedCoor_f* ned_pos) {
 570:./state.h     ****   VECT3_COPY(state.ned_pos_f, *ned_pos);
 571:./state.h     ****   /* clear bits for all position representations and only set the new one */
 572:./state.h     ****   state.pos_status = (1 << POS_NED_F);
 573:./state.h     **** }
 574:./state.h     **** 
 575:./state.h     **** /// Set position from local ENU coordinates (float).
 576:./state.h     **** static inline void stateSetPositionEnu_f(struct EnuCoor_f* enu_pos) {
 577:./state.h     ****   VECT3_COPY(state.enu_pos_f, *enu_pos);
 578:./state.h     ****   /* clear bits for all position representations and only set the new one */
 579:./state.h     ****   state.pos_status = (1 << POS_ENU_F);
 580:./state.h     **** }
 581:./state.h     **** 
 582:./state.h     **** /// Set position from LLA coordinates (float).
 583:./state.h     **** static inline void stateSetPositionLla_f(struct LlaCoor_f* lla_pos) {
 584:./state.h     ****   LLA_COPY(state.lla_pos_f, *lla_pos);
 585:./state.h     ****   /* clear bits for all position representations and only set the new one */
 586:./state.h     ****   state.pos_status = (1 << POS_LLA_F);
 587:./state.h     **** }
 588:./state.h     **** 
 589:./state.h     **** /// Set multiple position coordinates (float).
 590:./state.h     **** static inline void stateSetPosition_f(
 591:./state.h     ****     struct EcefCoor_f* ecef_pos,
 592:./state.h     ****     struct NedCoor_f* ned_pos,
 593:./state.h     ****     struct EnuCoor_f* enu_pos,
 594:./state.h     ****     struct LlaCoor_f* lla_pos,
 595:./state.h     ****     struct UtmCoor_f* utm_pos) {
 596:./state.h     ****   /* clear all status bit */
 597:./state.h     ****   state.pos_status = 0;
 598:./state.h     ****   if (ecef_pos != NULL) {
 599:./state.h     ****     VECT3_COPY(state.ecef_pos_f, *ecef_pos);
 600:./state.h     ****     state.pos_status |= (1 << POS_ECEF_F);
 601:./state.h     ****   }
 602:./state.h     ****   if (ned_pos != NULL) {
 603:./state.h     ****     VECT3_COPY(state.ned_pos_f, *ned_pos);
 604:./state.h     ****     state.pos_status |= (1 << POS_NED_F);
 605:./state.h     ****   }
 606:./state.h     ****   if (enu_pos != NULL) {
 607:./state.h     ****     VECT3_COPY(state.enu_pos_f, *enu_pos);
 608:./state.h     ****     state.pos_status |= (1 << POS_ENU_F);
 609:./state.h     ****   }
 610:./state.h     ****   if (lla_pos != NULL) {
 611:./state.h     ****     LLA_COPY(state.lla_pos_f, *lla_pos);
 612:./state.h     ****     state.pos_status |= (1 << POS_LLA_F);
 613:./state.h     ****   }
 614:./state.h     ****   if (utm_pos != NULL) {
 615:./state.h     ****     memcpy(&state.utm_pos_f, utm_pos, sizeof(struct UtmCoor_f));
 616:./state.h     ****     state.pos_status |= (1 << POS_UTM_F);
 617:./state.h     ****   }
 618:./state.h     **** }
 619:./state.h     **** 
 620:./state.h     **** /************************ Get functions ****************************/
 621:./state.h     **** 
 622:./state.h     **** /// Get position in ECEF coordinates (int).
 623:./state.h     **** static inline struct EcefCoor_i* stateGetPositionEcef_i(void) {
 624:./state.h     ****   if (!bit_is_set(state.pos_status, POS_ECEF_I))
 625:./state.h     ****     stateCalcPositionEcef_i();
 626:./state.h     ****   return &state.ecef_pos_i;
 627:./state.h     **** }
 628:./state.h     **** 
 629:./state.h     **** /// Get position in local NED coordinates (int).
 630:./state.h     **** static inline struct NedCoor_i* stateGetPositionNed_i(void) {
 631:./state.h     ****   if (!bit_is_set(state.pos_status, POS_NED_I))
 632:./state.h     ****     stateCalcPositionNed_i();
 633:./state.h     ****   return &state.ned_pos_i;
 634:./state.h     **** }
 635:./state.h     **** 
 636:./state.h     **** /// Get position in local ENU coordinates (int).
 637:./state.h     **** static inline struct EnuCoor_i* stateGetPositionEnu_i(void) {
 638:./state.h     ****   if (!bit_is_set(state.pos_status, POS_ENU_I))
 639:./state.h     ****     stateCalcPositionEnu_i();
 640:./state.h     ****   return &state.enu_pos_i;
 641:./state.h     **** }
 642:./state.h     **** 
 643:./state.h     **** /// Get position in LLA coordinates (int).
 644:./state.h     **** static inline struct LlaCoor_i* stateGetPositionLla_i(void) {
 645:./state.h     ****   if (!bit_is_set(state.pos_status, POS_LLA_I))
 646:./state.h     ****     stateCalcPositionLla_i();
 647:./state.h     ****   return &state.lla_pos_i;
 648:./state.h     **** }
 649:./state.h     **** 
 650:./state.h     **** /// Get position in UTM coordinates (float).
 651:./state.h     **** static inline struct UtmCoor_f* stateGetPositionUtm_f(void) {
 652:./state.h     ****   if (!bit_is_set(state.pos_status, POS_UTM_F))
 653:./state.h     ****     stateCalcPositionUtm_f();
 654:./state.h     ****   return &state.utm_pos_f;
 655:./state.h     **** }
 656:./state.h     **** 
 657:./state.h     **** /// Get position in ECEF coordinates (float).
 658:./state.h     **** static inline struct EcefCoor_f* stateGetPositionEcef_f(void) {
 659:./state.h     ****   if (!bit_is_set(state.pos_status, POS_ECEF_F))
 660:./state.h     ****     stateCalcPositionEcef_f();
 661:./state.h     ****   return &state.ecef_pos_f;
 662:./state.h     **** }
 663:./state.h     **** 
 664:./state.h     **** /// Get position in local NED coordinates (float).
 665:./state.h     **** static inline struct NedCoor_f* stateGetPositionNed_f(void) {
 666:./state.h     ****   if (!bit_is_set(state.pos_status, POS_NED_F))
 667:./state.h     ****     stateCalcPositionNed_f();
 668:./state.h     ****   return &state.ned_pos_f;
 669:./state.h     **** }
 670:./state.h     **** 
 671:./state.h     **** /// Get position in local ENU coordinates (float).
 672:./state.h     **** static inline struct EnuCoor_f* stateGetPositionEnu_f(void) {
 673:./state.h     ****   if (!bit_is_set(state.pos_status, POS_ENU_F))
 674:./state.h     ****     stateCalcPositionEnu_f();
 675:./state.h     ****   return &state.enu_pos_f;
 676:./state.h     **** }
 677:./state.h     **** 
 678:./state.h     **** /// Get position in LLA coordinates (float).
 679:./state.h     **** static inline struct LlaCoor_f* stateGetPositionLla_f(void) {
 680:./state.h     ****   if (!bit_is_set(state.pos_status, POS_LLA_F))
 681:./state.h     ****     stateCalcPositionLla_f();
 682:./state.h     ****   return &state.lla_pos_f;
 683:./state.h     **** }
 684:./state.h     **** 
 685:./state.h     **** /** @}*/
 686:./state.h     **** 
 687:./state.h     **** 
 688:./state.h     **** 
 689:./state.h     **** /******************************************************************************
 690:./state.h     ****  *                                                                            *
 691:./state.h     ****  * Set and Get functions for the SPEED representations                        *
 692:./state.h     ****  *                                                                            *
 693:./state.h     ****  *****************************************************************************/
 694:./state.h     **** /** @addtogroup state_velocity
 695:./state.h     ****  *  @{ */
 696:./state.h     **** 
 697:./state.h     **** /************* declaration of transformation functions ************/
 698:./state.h     **** extern void stateCalcSpeedNed_i(void);
 699:./state.h     **** extern void stateCalcSpeedEnu_i(void);
 700:./state.h     **** extern void stateCalcSpeedEcef_i(void);
 701:./state.h     **** extern void stateCalcHorizontalSpeedNorm_i(void);
 702:./state.h     **** extern void stateCalcHorizontalSpeedDir_i(void);
 703:./state.h     **** extern void stateCalcSpeedNed_f(void);
 704:./state.h     **** extern void stateCalcSpeedEnu_f(void);
 705:./state.h     **** extern void stateCalcSpeedEcef_f(void);
 706:./state.h     **** extern void stateCalcHorizontalSpeedNorm_f(void);
 707:./state.h     **** extern void stateCalcHorizontalSpeedDir_f(void);
 708:./state.h     **** 
 709:./state.h     **** /************************ Set functions ****************************/
 710:./state.h     **** 
 711:./state.h     **** /// Set ground speed in local NED coordinates (int).
 712:./state.h     **** static inline void stateSetSpeedNed_i(struct NedCoor_i* ned_speed) {
 713:./state.h     ****   INT32_VECT3_COPY(state.ned_speed_i, *ned_speed);
 714:./state.h     ****   /* clear bits for all speed representations and only set the new one */
 715:./state.h     ****   state.speed_status = (1 << SPEED_NED_I);
 716:./state.h     **** }
 717:./state.h     **** 
 718:./state.h     **** /// Set ground speed in local ENU coordinates (int).
 719:./state.h     **** static inline void stateSetSpeedEnu_i(struct EnuCoor_i* enu_speed) {
 720:./state.h     ****   INT32_VECT3_COPY(state.enu_speed_i, *enu_speed);
 721:./state.h     ****   /* clear bits for all speed representations and only set the new one */
 722:./state.h     ****   state.speed_status = (1 << SPEED_ENU_I);
 723:./state.h     **** }
 724:./state.h     **** 
 725:./state.h     **** /// Set ground speed in ECEF coordinates (int).
 726:./state.h     **** static inline void stateSetSpeedEcef_i(struct EcefCoor_i* ecef_speed) {
 727:./state.h     ****   INT32_VECT3_COPY(state.ecef_speed_i, *ecef_speed);
 728:./state.h     ****   /* clear bits for all speed representations and only set the new one */
 729:./state.h     ****   state.speed_status = (1 << SPEED_ECEF_I);
 730:./state.h     **** }
 731:./state.h     **** 
 732:./state.h     **** /// Set multiple speed coordinates (int).
 733:./state.h     **** static inline void stateSetSpeed_i(
 734:./state.h     ****     struct EcefCoor_i* ecef_speed,
 735:./state.h     ****     struct NedCoor_i* ned_speed,
 736:./state.h     ****     struct EnuCoor_i* enu_speed) {
 737:./state.h     ****   /* clear all status bit */
 738:./state.h     ****   state.speed_status = 0;
 739:./state.h     ****   if (ecef_speed != NULL) {
 740:./state.h     ****     INT32_VECT3_COPY(state.ecef_speed_i, *ecef_speed);
 741:./state.h     ****     state.speed_status |= (1 << SPEED_ECEF_I);
 742:./state.h     ****   }
 743:./state.h     ****   if (ned_speed != NULL) {
 744:./state.h     ****     INT32_VECT3_COPY(state.ned_speed_i, *ned_speed);
 745:./state.h     ****     state.speed_status |= (1 << SPEED_NED_I);
 746:./state.h     ****   }
 747:./state.h     ****   if (enu_speed != NULL) {
 748:./state.h     ****     INT32_VECT3_COPY(state.enu_speed_i, *enu_speed);
 749:./state.h     ****     state.speed_status |= (1 << SPEED_ENU_I);
 750:./state.h     ****   }
 751:./state.h     **** }
 752:./state.h     **** 
 753:./state.h     **** /// Set ground speed in local NED coordinates (float).
 754:./state.h     **** static inline void stateSetSpeedNed_f(struct NedCoor_f* ned_speed) {
 755:./state.h     ****   VECT3_COPY(state.ned_speed_f, *ned_speed);
 756:./state.h     ****   /* clear bits for all speed representations and only set the new one */
 757:./state.h     ****   state.speed_status = (1 << SPEED_NED_F);
 758:./state.h     **** }
 759:./state.h     **** 
 760:./state.h     **** /// Set ground speed in local ENU coordinates (float).
 761:./state.h     **** static inline void stateSetSpeedEnu_f(struct EnuCoor_f* enu_speed) {
 762:./state.h     ****   VECT3_COPY(state.enu_speed_f, *enu_speed);
 763:./state.h     ****   /* clear bits for all speed representations and only set the new one */
 764:./state.h     ****   state.speed_status = (1 << SPEED_ENU_F);
 765:./state.h     **** }
 766:./state.h     **** 
 767:./state.h     **** /// Set ground speed in ECEF coordinates (float).
 768:./state.h     **** static inline void stateSetSpeedEcef_f(struct EcefCoor_f* ecef_speed) {
 769:./state.h     ****   VECT3_COPY(state.ecef_speed_f, *ecef_speed);
 770:./state.h     ****   /* clear bits for all speed representations and only set the new one */
 771:./state.h     ****   state.speed_status = (1 << SPEED_ECEF_F);
 772:./state.h     **** }
 773:./state.h     **** 
 774:./state.h     **** /// Set multiple speed coordinates (float).
 775:./state.h     **** static inline void stateSetSpeed_f(
 776:./state.h     ****     struct EcefCoor_f* ecef_speed,
 777:./state.h     ****     struct NedCoor_f* ned_speed,
 778:./state.h     ****     struct EnuCoor_f* enu_speed) {
 779:./state.h     ****   /* clear all status bit */
 780:./state.h     ****   state.speed_status = 0;
 781:./state.h     ****   if (ecef_speed != NULL) {
 782:./state.h     ****     VECT3_COPY(state.ecef_speed_f, *ecef_speed);
 783:./state.h     ****     state.speed_status |= (1 << SPEED_ECEF_F);
 784:./state.h     ****   }
 785:./state.h     ****   if (ned_speed != NULL) {
 786:./state.h     ****     VECT3_COPY(state.ned_speed_f, *ned_speed);
 787:./state.h     ****     state.speed_status |= (1 << SPEED_NED_F);
 788:./state.h     ****   }
 789:./state.h     ****   if (enu_speed != NULL) {
 790:./state.h     ****     VECT3_COPY(state.enu_speed_f, *enu_speed);
 791:./state.h     ****     state.speed_status |= (1 << SPEED_ENU_F);
 792:./state.h     ****   }
 793:./state.h     **** }
 794:./state.h     **** 
 795:./state.h     **** /************************ Get functions ****************************/
 796:./state.h     **** 
 797:./state.h     **** /// Get ground speed in local NED coordinates (int).
 798:./state.h     **** static inline struct NedCoor_i* stateGetSpeedNed_i(void) {
 799:./state.h     ****   if (!bit_is_set(state.speed_status, SPEED_NED_I))
 800:./state.h     ****     stateCalcSpeedNed_i();
 801:./state.h     ****   return &state.ned_speed_i;
 802:./state.h     **** }
 803:./state.h     **** 
 804:./state.h     **** /// Get ground speed in local ENU coordinates (int).
 805:./state.h     **** static inline struct EnuCoor_i* stateGetSpeedEnu_i(void) {
 806:./state.h     ****   if (!bit_is_set(state.speed_status, SPEED_ENU_I))
 807:./state.h     ****     stateCalcSpeedEnu_i();
 808:./state.h     ****   return &state.enu_speed_i;
 809:./state.h     **** }
 810:./state.h     **** 
 811:./state.h     **** /// Get ground speed in ECEF coordinates (int).
 812:./state.h     **** static inline struct EcefCoor_i* stateGetSpeedEcef_i(void) {
 813:./state.h     ****   if (!bit_is_set(state.speed_status, SPEED_ECEF_I))
 814:./state.h     ****     stateCalcSpeedEcef_i();
 815:./state.h     ****   return &state.ecef_speed_i;
 816:./state.h     **** }
 817:./state.h     **** 
 818:./state.h     **** /// Get norm of horizontal ground speed (int).
 819:./state.h     **** static inline int32_t* stateGetHorizontalSpeedNorm_i(void) {
 820:./state.h     ****   if (!bit_is_set(state.speed_status, SPEED_HNORM_I))
 821:./state.h     ****     stateCalcHorizontalSpeedNorm_i();
 822:./state.h     ****   return &state.h_speed_norm_i;
 823:./state.h     **** }
 824:./state.h     **** 
 825:./state.h     **** /// Get dir of horizontal ground speed (int).
 826:./state.h     **** static inline int32_t* stateGetHorizontalSpeedDir_i(void) {
 827:./state.h     ****   if (!bit_is_set(state.speed_status, SPEED_HDIR_I))
 828:./state.h     ****     stateCalcHorizontalSpeedDir_i();
 829:./state.h     ****   return &state.h_speed_dir_i;
 830:./state.h     **** }
 831:./state.h     **** 
 832:./state.h     **** /// Get ground speed in local NED coordinates (float).
 833:./state.h     **** static inline struct NedCoor_f* stateGetSpeedNed_f(void) {
 834:./state.h     ****   if (!bit_is_set(state.speed_status, SPEED_NED_F))
 835:./state.h     ****     stateCalcSpeedNed_f();
 836:./state.h     ****   return &state.ned_speed_f;
 837:./state.h     **** }
 838:./state.h     **** 
 839:./state.h     **** /// Get ground speed in local ENU coordinates (float).
 840:./state.h     **** static inline struct EnuCoor_f* stateGetSpeedEnu_f(void) {
 841:./state.h     ****   if (!bit_is_set(state.speed_status, SPEED_ENU_F))
 842:./state.h     ****     stateCalcSpeedEnu_f();
 843:./state.h     ****   return &state.enu_speed_f;
 844:./state.h     **** }
 845:./state.h     **** 
 846:./state.h     **** /// Get ground speed in ECEF coordinates (float).
 847:./state.h     **** static inline struct EcefCoor_f* stateGetSpeedEcef_f(void) {
 848:./state.h     ****   if (!bit_is_set(state.speed_status, SPEED_ECEF_F))
 849:./state.h     ****     stateCalcSpeedEcef_f();
 850:./state.h     ****   return &state.ecef_speed_f;
 851:./state.h     **** }
 852:./state.h     **** 
 853:./state.h     **** /// Get norm of horizontal ground speed (float).
 854:./state.h     **** static inline float* stateGetHorizontalSpeedNorm_f(void) {
 855:./state.h     ****   if (!bit_is_set(state.speed_status, SPEED_HNORM_F))
 856:./state.h     ****     stateCalcHorizontalSpeedNorm_f();
 857:./state.h     ****   return &state.h_speed_norm_f;
 858:./state.h     **** }
 859:./state.h     **** 
 860:./state.h     **** /// Get dir of horizontal ground speed (float).
 861:./state.h     **** static inline float* stateGetHorizontalSpeedDir_f(void) {
 862:./state.h     ****   if (!bit_is_set(state.speed_status, SPEED_HDIR_F))
 863:./state.h     ****     stateCalcHorizontalSpeedDir_f();
 864:./state.h     ****   return &state.h_speed_dir_f;
 865:./state.h     **** }
 866:./state.h     **** /** @}*/
 867:./state.h     **** 
 868:./state.h     **** 
 869:./state.h     **** 
 870:./state.h     **** /******************************************************************************
 871:./state.h     ****  *                                                                            *
 872:./state.h     ****  * Set and Get functions for the ACCELERATION representations                 *
 873:./state.h     ****  *                                                                            *
 874:./state.h     ****  *****************************************************************************/
 875:./state.h     **** /** @addtogroup state_acceleration
 876:./state.h     ****  *  @{ */
 877:./state.h     **** 
 878:./state.h     **** /************* declaration of transformation functions ************/
 879:./state.h     **** extern void stateCalcAccelNed_i(void);
 880:./state.h     **** extern void stateCalcAccelEcef_i(void);
 881:./state.h     **** extern void stateCalcAccelNed_f(void);
 882:./state.h     **** extern void stateCalcAccelEcef_f(void);
 883:./state.h     **** 
 884:./state.h     **** /*********************** validity test functions ******************/
 885:./state.h     **** 
 886:./state.h     **** /// Test if accelerations are valid.
 887:./state.h     **** static inline bool_t stateIsAccelValid(void) {
 888:./state.h     ****   return (state.accel_status);
 889:./state.h     **** }
 890:./state.h     **** 
 891:./state.h     **** /************************ Set functions ****************************/
 892:./state.h     **** 
 893:./state.h     **** /// Set acceleration in NED coordinates (int).
 894:./state.h     **** static inline void stateSetAccelNed_i(struct NedCoor_i* ned_accel) {
  26              		.loc 1 894 0
  27              		.cfi_startproc
  28              		@ args = 0, pretend = 0, frame = 0
  29              		@ frame_needed = 0, uses_anonymous_args = 0
  30              		@ link register save eliminated.
  31              	.LVL0:
 895:./state.h     ****   INT32_VECT3_COPY(state.ned_accel_i, *ned_accel);
  32              		.loc 1 895 0
  33 0000 074A     		ldr	r2, .L2
  34 0002 084B     		ldr	r3, .L2+4
  35 0004 1168     		ldr	r1, [r2, #0]
  36 0006 5068     		ldr	r0, [r2, #4]
  37 0008 9268     		ldr	r2, [r2, #8]
  38 000a C3F87411 		str	r1, [r3, #372]
 896:./state.h     ****   /* clear bits for all accel representations and only set the new one */
 897:./state.h     ****   state.accel_status = (1 << ACCEL_NED_I);
  39              		.loc 1 897 0
  40 000e 0221     		movs	r1, #2
 895:./state.h     ****   INT32_VECT3_COPY(state.ned_accel_i, *ned_accel);
  41              		.loc 1 895 0
  42 0010 C3F87801 		str	r0, [r3, #376]
  43 0014 C3F87C21 		str	r2, [r3, #380]
  44              		.loc 1 897 0
  45 0018 83F87011 		strb	r1, [r3, #368]
  46 001c 7047     		bx	lr
  47              	.L3:
  48 001e 00BF     		.align	2
  49              	.L2:
  50 0020 00000000 		.word	.LANCHOR0
  51 0024 00000000 		.word	state
  52              		.cfi_endproc
  53              	.LFE135:
  55              		.section	.text.stateSetSpeedNed_i.constprop.1,"ax",%progbits
  56              		.align	1
  57              		.thumb
  58              		.thumb_func
  60              	stateSetSpeedNed_i.constprop.1:
  61              	.LFB134:
 712:./state.h     **** static inline void stateSetSpeedNed_i(struct NedCoor_i* ned_speed) {
  62              		.loc 1 712 0
  63              		.cfi_startproc
  64              		@ args = 0, pretend = 0, frame = 0
  65              		@ frame_needed = 0, uses_anonymous_args = 0
  66              		@ link register save eliminated.
  67              	.LVL1:
 713:./state.h     ****   INT32_VECT3_COPY(state.ned_speed_i, *ned_speed);
  68              		.loc 1 713 0
  69 0000 074A     		ldr	r2, .L5
  70 0002 084B     		ldr	r3, .L5+4
  71 0004 1168     		ldr	r1, [r2, #0]
  72 0006 5068     		ldr	r0, [r2, #4]
  73 0008 9268     		ldr	r2, [r2, #8]
  74 000a C3F82411 		str	r1, [r3, #292]
 715:./state.h     ****   state.speed_status = (1 << SPEED_NED_I);
  75              		.loc 1 715 0
  76 000e 0221     		movs	r1, #2
 713:./state.h     ****   INT32_VECT3_COPY(state.ned_speed_i, *ned_speed);
  77              		.loc 1 713 0
  78 0010 C3F82801 		str	r0, [r3, #296]
  79 0014 C3F82C21 		str	r2, [r3, #300]
 715:./state.h     ****   state.speed_status = (1 << SPEED_NED_I);
  80              		.loc 1 715 0
  81 0018 A3F81411 		strh	r1, [r3, #276]	@ movhi
  82 001c 7047     		bx	lr
  83              	.L6:
  84 001e 00BF     		.align	2
  85              	.L5:
  86 0020 00000000 		.word	.LANCHOR1
  87 0024 00000000 		.word	state
  88              		.cfi_endproc
  89              	.LFE134:
  91              		.section	.text.stateSetPositionNed_i.constprop.2,"ax",%progbits
  92              		.align	1
  93              		.thumb
  94              		.thumb_func
  96              	stateSetPositionNed_i.constprop.2:
  97              	.LFB133:
 508:./state.h     **** static inline void stateSetPositionNed_i(struct NedCoor_i* ned_pos) {
  98              		.loc 1 508 0
  99              		.cfi_startproc
 100              		@ args = 0, pretend = 0, frame = 0
 101              		@ frame_needed = 0, uses_anonymous_args = 0
 102              		@ link register save eliminated.
 103              	.LVL2:
 509:./state.h     ****   INT32_VECT3_COPY(state.ned_pos_i, *ned_pos);
 104              		.loc 1 509 0
 105 0000 054A     		ldr	r2, .L8
 106 0002 064B     		ldr	r3, .L8+4
 107 0004 1168     		ldr	r1, [r2, #0]
 108 0006 5068     		ldr	r0, [r2, #4]
 109 0008 9268     		ldr	r2, [r2, #8]
 110 000a 1966     		str	r1, [r3, #96]
 511:./state.h     ****   state.pos_status = (1 << POS_NED_I);
 111              		.loc 1 511 0
 112 000c 0221     		movs	r1, #2
 509:./state.h     ****   INT32_VECT3_COPY(state.ned_pos_i, *ned_pos);
 113              		.loc 1 509 0
 114 000e 5866     		str	r0, [r3, #100]
 115 0010 9A66     		str	r2, [r3, #104]
 511:./state.h     ****   state.pos_status = (1 << POS_NED_I);
 116              		.loc 1 511 0
 117 0012 1980     		strh	r1, [r3, #0]	@ movhi
 118 0014 7047     		bx	lr
 119              	.L9:
 120 0016 00BF     		.align	2
 121              	.L8:
 122 0018 00000000 		.word	.LANCHOR2
 123 001c 00000000 		.word	state
 124              		.cfi_endproc
 125              	.LFE133:
 127              		.global	__aeabi_i2d
 128              		.global	__aeabi_ddiv
 129              		.global	__aeabi_d2f
 130              		.global	__aeabi_i2f
 131              		.global	__aeabi_fmul
 132              		.section	.text.stateSetLocalOrigin_i.constprop.3,"ax",%progbits
 133              		.align	1
 134              		.thumb
 135              		.thumb_func
 137              	stateSetLocalOrigin_i.constprop.3:
 138              	.LFB132:
 440:./state.h     **** static inline void stateSetLocalOrigin_i(struct LtpDef_i* ltp_def) {
 139              		.loc 1 440 0
 140              		.cfi_startproc
 141              		@ args = 0, pretend = 0, frame = 0
 142              		@ frame_needed = 0, uses_anonymous_args = 0
 143              	.LVL3:
 144 0000 70B5     		push	{r4, r5, r6, lr}
 145              	.LCFI0:
 146              		.cfi_def_cfa_offset 16
 147              		.cfi_offset 4, -16
 148              		.cfi_offset 5, -12
 149              		.cfi_offset 6, -8
 150              		.cfi_offset 14, -4
 441:./state.h     ****   memcpy(&state.ned_origin_i, ltp_def, sizeof(struct LtpDef_i));
 151              		.loc 1 441 0
 152 0002 654C     		ldr	r4, .L11+8
 153 0004 654E     		ldr	r6, .L11+12
 154 0006 04F11C05 		add	r5, r4, #28
 155 000a 0FCE     		ldmia	r6!, {r0, r1, r2, r3}
 156 000c 0FC5     		stmia	r5!, {r0, r1, r2, r3}
 157 000e 0FCE     		ldmia	r6!, {r0, r1, r2, r3}
 158 0010 0FC5     		stmia	r5!, {r0, r1, r2, r3}
 159 0012 0FCE     		ldmia	r6!, {r0, r1, r2, r3}
 160 0014 0FC5     		stmia	r5!, {r0, r1, r2, r3}
 161 0016 96E80F00 		ldmia	r6, {r0, r1, r2, r3}
 162 001a 85E80F00 		stmia	r5, {r0, r1, r2, r3}
 443:./state.h     ****   ECEF_FLOAT_OF_BFP(state.ned_origin_f.ecef, state.ned_origin_i.ecef);
 163              		.loc 1 443 0
 164 001e E069     		ldr	r0, [r4, #28]
 165 0020 FFF7FEFF 		bl	__aeabi_i2d
 166              	.LVL4:
 167 0024 0022     		movs	r2, #0
 168 0026 5E4B     		ldr	r3, .L11+16
 169 0028 FFF7FEFF 		bl	__aeabi_ddiv
 170              	.LVL5:
 171 002c FFF7FEFF 		bl	__aeabi_d2f
 172              	.LVL6:
 173 0030 C4F8A400 		str	r0, [r4, #164]	@ float
 174 0034 206A     		ldr	r0, [r4, #32]
 175 0036 FFF7FEFF 		bl	__aeabi_i2d
 176              	.LVL7:
 177 003a 0022     		movs	r2, #0
 178 003c 584B     		ldr	r3, .L11+16
 179 003e FFF7FEFF 		bl	__aeabi_ddiv
 180              	.LVL8:
 181 0042 FFF7FEFF 		bl	__aeabi_d2f
 182              	.LVL9:
 183 0046 C4F8A800 		str	r0, [r4, #168]	@ float
 184 004a 606A     		ldr	r0, [r4, #36]
 185 004c FFF7FEFF 		bl	__aeabi_i2d
 186              	.LVL10:
 187 0050 0022     		movs	r2, #0
 188 0052 534B     		ldr	r3, .L11+16
 189 0054 FFF7FEFF 		bl	__aeabi_ddiv
 190              	.LVL11:
 191 0058 FFF7FEFF 		bl	__aeabi_d2f
 192              	.LVL12:
 193 005c C4F8AC00 		str	r0, [r4, #172]	@ float
 444:./state.h     ****   LLA_FLOAT_OF_BFP(state.ned_origin_f.lla, state.ned_origin_i.lla);
 194              		.loc 1 444 0
 195 0060 E06A     		ldr	r0, [r4, #44]
 196 0062 FFF7FEFF 		bl	__aeabi_i2d
 197              	.LVL13:
 198 0066 4AA3     		adr	r3, .L11
 199 0068 D3E90023 		ldrd	r2, [r3]
 200 006c FFF7FEFF 		bl	__aeabi_ddiv
 201              	.LVL14:
 202 0070 FFF7FEFF 		bl	__aeabi_d2f
 203              	.LVL15:
 204 0074 C4F8B400 		str	r0, [r4, #180]	@ float
 205 0078 A06A     		ldr	r0, [r4, #40]
 206 007a FFF7FEFF 		bl	__aeabi_i2d
 207              	.LVL16:
 208 007e 44A3     		adr	r3, .L11
 209 0080 D3E90023 		ldrd	r2, [r3]
 210 0084 FFF7FEFF 		bl	__aeabi_ddiv
 211              	.LVL17:
 212 0088 FFF7FEFF 		bl	__aeabi_d2f
 213              	.LVL18:
 214 008c C4F8B000 		str	r0, [r4, #176]	@ float
 215 0090 206B     		ldr	r0, [r4, #48]
 216 0092 FFF7FEFF 		bl	__aeabi_i2d
 217              	.LVL19:
 218 0096 0022     		movs	r2, #0
 219 0098 424B     		ldr	r3, .L11+20
 220 009a FFF7FEFF 		bl	__aeabi_ddiv
 221              	.LVL20:
 222 009e FFF7FEFF 		bl	__aeabi_d2f
 223              	.LVL21:
 224 00a2 C4F8B800 		str	r0, [r4, #184]	@ float
 445:./state.h     ****   RMAT_FLOAT_OF_BFP(state.ned_origin_f.ltp_of_ecef, state.ned_origin_i.ltp_of_ecef);
 225              		.loc 1 445 0
 226 00a6 606B     		ldr	r0, [r4, #52]
 227 00a8 FFF7FEFF 		bl	__aeabi_i2f
 228              	.LVL22:
 229 00ac 4FF06251 		mov	r1, #947912704
 230 00b0 FFF7FEFF 		bl	__aeabi_fmul
 231              	.LVL23:
 232 00b4 C4F8BC00 		str	r0, [r4, #188]	@ float
 233 00b8 A06B     		ldr	r0, [r4, #56]
 234 00ba FFF7FEFF 		bl	__aeabi_i2f
 235              	.LVL24:
 236 00be 4FF06251 		mov	r1, #947912704
 237 00c2 FFF7FEFF 		bl	__aeabi_fmul
 238              	.LVL25:
 239 00c6 C4F8C000 		str	r0, [r4, #192]	@ float
 240 00ca E06B     		ldr	r0, [r4, #60]
 241 00cc FFF7FEFF 		bl	__aeabi_i2f
 242              	.LVL26:
 243 00d0 4FF06251 		mov	r1, #947912704
 244 00d4 FFF7FEFF 		bl	__aeabi_fmul
 245              	.LVL27:
 246 00d8 C4F8C400 		str	r0, [r4, #196]	@ float
 247 00dc 206C     		ldr	r0, [r4, #64]
 248 00de FFF7FEFF 		bl	__aeabi_i2f
 249              	.LVL28:
 250 00e2 4FF06251 		mov	r1, #947912704
 251 00e6 FFF7FEFF 		bl	__aeabi_fmul
 252              	.LVL29:
 253 00ea C4F8C800 		str	r0, [r4, #200]	@ float
 254 00ee 606C     		ldr	r0, [r4, #68]
 255 00f0 FFF7FEFF 		bl	__aeabi_i2f
 256              	.LVL30:
 257 00f4 4FF06251 		mov	r1, #947912704
 258 00f8 FFF7FEFF 		bl	__aeabi_fmul
 259              	.LVL31:
 260 00fc C4F8CC00 		str	r0, [r4, #204]	@ float
 261 0100 A06C     		ldr	r0, [r4, #72]
 262 0102 FFF7FEFF 		bl	__aeabi_i2f
 263              	.LVL32:
 264 0106 4FF06251 		mov	r1, #947912704
 265 010a FFF7FEFF 		bl	__aeabi_fmul
 266              	.LVL33:
 267 010e C4F8D000 		str	r0, [r4, #208]	@ float
 268 0112 E06C     		ldr	r0, [r4, #76]
 269 0114 FFF7FEFF 		bl	__aeabi_i2f
 270              	.LVL34:
 271 0118 4FF06251 		mov	r1, #947912704
 272 011c FFF7FEFF 		bl	__aeabi_fmul
 273              	.LVL35:
 274 0120 C4F8D400 		str	r0, [r4, #212]	@ float
 275 0124 206D     		ldr	r0, [r4, #80]
 276 0126 FFF7FEFF 		bl	__aeabi_i2f
 277              	.LVL36:
 278 012a 4FF06251 		mov	r1, #947912704
 279 012e FFF7FEFF 		bl	__aeabi_fmul
 280              	.LVL37:
 281 0132 C4F8D800 		str	r0, [r4, #216]	@ float
 282 0136 606D     		ldr	r0, [r4, #84]
 283 0138 FFF7FEFF 		bl	__aeabi_i2f
 284              	.LVL38:
 285 013c 4FF06251 		mov	r1, #947912704
 286 0140 FFF7FEFF 		bl	__aeabi_fmul
 287              	.LVL39:
 288 0144 C4F8DC00 		str	r0, [r4, #220]	@ float
 446:./state.h     ****   state.ned_origin_f.hmsl = M_OF_MM(state.ned_origin_i.hmsl);
 289              		.loc 1 446 0
 290 0148 A06D     		ldr	r0, [r4, #88]
 291 014a FFF7FEFF 		bl	__aeabi_i2d
 292              	.LVL40:
 293 014e 0022     		movs	r2, #0
 294 0150 144B     		ldr	r3, .L11+20
 295 0152 FFF7FEFF 		bl	__aeabi_ddiv
 296              	.LVL41:
 297 0156 FFF7FEFF 		bl	__aeabi_d2f
 298              	.LVL42:
 299 015a C4F8E000 		str	r0, [r4, #224]	@ float
 449:./state.h     ****   state.pos_status &= ~(POS_LOCAL_COORD);
 300              		.loc 1 449 0
 301 015e 2388     		ldrh	r3, [r4, #0]
 450:./state.h     ****   state.speed_status &= ~(SPEED_LOCAL_COORD);
 302              		.loc 1 450 0
 303 0160 B4F81411 		ldrh	r1, [r4, #276]
 449:./state.h     ****   state.pos_status &= ~(POS_LOCAL_COORD);
 304              		.loc 1 449 0
 305 0164 23F0C600 		bic	r0, r3, #198
 452:./state.h     ****   ClearBit(state.accel_status, ACCEL_NED_F);
 306              		.loc 1 452 0
 307 0168 94F87031 		ldrb	r3, [r4, #368]	@ zero_extendqisi2
 450:./state.h     ****   state.speed_status &= ~(SPEED_LOCAL_COORD);
 308              		.loc 1 450 0
 309 016c 21F0C602 		bic	r2, r1, #198
 449:./state.h     ****   state.pos_status &= ~(POS_LOCAL_COORD);
 310              		.loc 1 449 0
 311 0170 2080     		strh	r0, [r4, #0]	@ movhi
 454:./state.h     ****   state.ned_initialized_i = TRUE;
 312              		.loc 1 454 0
 313 0172 0121     		movs	r1, #1
 452:./state.h     ****   ClearBit(state.accel_status, ACCEL_NED_F);
 314              		.loc 1 452 0
 315 0174 23F00A00 		bic	r0, r3, #10
 450:./state.h     ****   state.speed_status &= ~(SPEED_LOCAL_COORD);
 316              		.loc 1 450 0
 317 0178 A4F81421 		strh	r2, [r4, #276]	@ movhi
 452:./state.h     ****   ClearBit(state.accel_status, ACCEL_NED_F);
 318              		.loc 1 452 0
 319 017c 84F87001 		strb	r0, [r4, #368]
 454:./state.h     ****   state.ned_initialized_i = TRUE;
 320              		.loc 1 454 0
 321 0180 84F85C10 		strb	r1, [r4, #92]
 455:./state.h     ****   state.ned_initialized_f = TRUE;
 322              		.loc 1 455 0
 323 0184 84F8E410 		strb	r1, [r4, #228]
 324 0188 70BD     		pop	{r4, r5, r6, pc}
 325              	.L12:
 326 018a 00BFAFF3 		.align	3
 326      0080
 327              	.L11:
 328 0190 00000000 		.word	0
 329 0194 D0126341 		.word	1097011920
 330 0198 00000000 		.word	state
 331 019c 00000000 		.word	.LANCHOR3
 332 01a0 00005940 		.word	1079574528
 333 01a4 00408F40 		.word	1083129856
 334              		.cfi_endproc
 335              	.LFE132:
 337              		.section	.text.stateGetNedToBodyRMat_i,"ax",%progbits
 338              		.align	1
 339              		.thumb
 340              		.thumb_func
 342              	stateGetNedToBodyRMat_i:
 343              	.LFB74:
 898:./state.h     **** }
 899:./state.h     **** 
 900:./state.h     **** /// Set acceleration in ECEF coordinates (int).
 901:./state.h     **** static inline void stateSetAccelEcef_i(struct EcefCoor_i* ecef_accel) {
 902:./state.h     ****   INT32_VECT3_COPY(state.ecef_accel_i, *ecef_accel);
 903:./state.h     ****   /* clear bits for all accel representations and only set the new one */
 904:./state.h     ****   state.accel_status = (1 << ACCEL_ECEF_I);
 905:./state.h     **** }
 906:./state.h     **** 
 907:./state.h     **** /// Set acceleration in NED coordinates (float).
 908:./state.h     **** static inline void stateSetAccelNed_f(struct NedCoor_f* ned_accel) {
 909:./state.h     ****   VECT3_COPY(state.ned_accel_f, *ned_accel);
 910:./state.h     ****   /* clear bits for all accel representations and only set the new one */
 911:./state.h     ****   state.accel_status = (1 << ACCEL_NED_F);
 912:./state.h     **** }
 913:./state.h     **** 
 914:./state.h     **** /// Set acceleration in ECEF coordinates (float).
 915:./state.h     **** static inline void stateSetAccelEcef_f(struct EcefCoor_f* ecef_accel) {
 916:./state.h     ****   VECT3_COPY(state.ecef_accel_f, *ecef_accel);
 917:./state.h     ****   /* clear bits for all accel representations and only set the new one */
 918:./state.h     ****   state.accel_status = (1 << ACCEL_ECEF_F);
 919:./state.h     **** }
 920:./state.h     **** 
 921:./state.h     **** /************************ Get functions ****************************/
 922:./state.h     **** 
 923:./state.h     **** /// Get acceleration in NED coordinates (int).
 924:./state.h     **** static inline struct NedCoor_i* stateGetAccelNed_i(void) {
 925:./state.h     ****   if (!bit_is_set(state.accel_status, ACCEL_NED_I))
 926:./state.h     ****     stateCalcAccelNed_i();
 927:./state.h     ****   return &state.ned_accel_i;
 928:./state.h     **** }
 929:./state.h     **** 
 930:./state.h     **** /// Get acceleration in ECEF coordinates (int).
 931:./state.h     **** static inline struct EcefCoor_i* stateGetAccelEcef_i(void) {
 932:./state.h     ****   if (!bit_is_set(state.accel_status, ACCEL_ECEF_I))
 933:./state.h     ****     stateCalcAccelEcef_i();
 934:./state.h     ****   return &state.ecef_accel_i;
 935:./state.h     **** }
 936:./state.h     **** 
 937:./state.h     **** /// Get acceleration in NED coordinates (float).
 938:./state.h     **** static inline struct NedCoor_f* stateGetAccelNed_f(void) {
 939:./state.h     ****   if (!bit_is_set(state.accel_status, ACCEL_NED_F))
 940:./state.h     ****     stateCalcAccelNed_f();
 941:./state.h     ****   return &state.ned_accel_f;
 942:./state.h     **** }
 943:./state.h     **** 
 944:./state.h     **** /// Get acceleration in ECEF coordinates (float).
 945:./state.h     **** static inline struct EcefCoor_f* stateGetAccelEcef_f(void) {
 946:./state.h     ****   if (!bit_is_set(state.accel_status, ACCEL_ECEF_F))
 947:./state.h     ****     stateCalcAccelEcef_f();
 948:./state.h     ****   return &state.ecef_accel_f;
 949:./state.h     **** }
 950:./state.h     **** /** @}*/
 951:./state.h     **** 
 952:./state.h     **** /******************************************************************************
 953:./state.h     **** *                                                                             *
 954:./state.h     **** * Set and Get functions for the ATTITUDE representations                      *
 955:./state.h     **** * (Calls the functions in math/pprz_orientation_conversion)                   *
 956:./state.h     **** *                                                                             *
 957:./state.h     **** *****************************************************************************/
 958:./state.h     **** /** @addtogroup state_attitude
 959:./state.h     **** * @{ */
 960:./state.h     **** /*********************** validity test functions ******************/
 961:./state.h     **** 
 962:./state.h     **** /// Test if attitudes are valid.
 963:./state.h     **** static inline bool_t stateIsAttitudeValid(void) {
 964:./state.h     ****   return (orienationCheckValid(&state.ned_to_body_orientation));
 965:./state.h     **** }
 966:./state.h     **** 
 967:./state.h     **** /************************ Set functions ****************************/
 968:./state.h     **** 
 969:./state.h     **** /// Set vehicle body attitude from quaternion (int).
 970:./state.h     **** static inline void stateSetNedToBodyQuat_i(struct Int32Quat* ned_to_body_quat) {
 971:./state.h     ****   orientationSetQuat_i(&state.ned_to_body_orientation,ned_to_body_quat);
 972:./state.h     **** }
 973:./state.h     **** 
 974:./state.h     **** /// Set vehicle body attitude from rotation matrix (int).
 975:./state.h     **** static inline void stateSetNedToBodyRMat_i(struct Int32RMat* ned_to_body_rmat) {
 976:./state.h     ****   orientationSetRMat_i(&state.ned_to_body_orientation,ned_to_body_rmat);
 977:./state.h     **** }
 978:./state.h     **** 
 979:./state.h     **** /// Set vehicle body attitude from euler angles (int).
 980:./state.h     **** static inline void stateSetNedToBodyEulers_i(struct Int32Eulers* ned_to_body_eulers) {
 981:./state.h     ****   orientationSetEulers_i(&state.ned_to_body_orientation,ned_to_body_eulers);
 982:./state.h     **** }
 983:./state.h     **** 
 984:./state.h     **** /// Set vehicle body attitude from quaternion (float).
 985:./state.h     **** static inline void stateSetNedToBodyQuat_f(struct FloatQuat* ned_to_body_quat) {
 986:./state.h     ****   orientationSetQuat_f(&state.ned_to_body_orientation,ned_to_body_quat);
 987:./state.h     **** }
 988:./state.h     **** 
 989:./state.h     **** /// Set vehicle body attitude from rotation matrix (float).
 990:./state.h     **** static inline void stateSetNedToBodyRMat_f(struct FloatRMat* ned_to_body_rmat) {
 991:./state.h     ****   orientationSetRMat_f(&state.ned_to_body_orientation,ned_to_body_rmat);
 992:./state.h     **** }
 993:./state.h     **** 
 994:./state.h     **** /// Set vehicle body attitude from euler angles (float).
 995:./state.h     **** static inline void stateSetNedToBodyEulers_f(struct FloatEulers* ned_to_body_eulers) {
 996:./state.h     ****   orientationSetEulers_f(&state.ned_to_body_orientation,ned_to_body_eulers);
 997:./state.h     **** }
 998:./state.h     **** 
 999:./state.h     **** /************************ Get functions ****************************/
1000:./state.h     **** 
1001:./state.h     **** /// Get vehicle body attitude quaternion (int).
1002:./state.h     **** static inline struct Int32Quat* stateGetNedToBodyQuat_i(void) {
1003:./state.h     ****   return orientationGetQuat_i(&state.ned_to_body_orientation);
1004:./state.h     **** }
1005:./state.h     **** 
1006:./state.h     **** /// Get vehicle body attitude rotation matrix (int).
1007:./state.h     **** static inline struct Int32RMat* stateGetNedToBodyRMat_i(void) {
 344              		.loc 1 1007 0
 345              		.cfi_startproc
 346              		@ args = 0, pretend = 0, frame = 0
 347              		@ frame_needed = 0, uses_anonymous_args = 0
 348              	.LVL43:
 349 0000 08B5     		push	{r3, lr}
 350              	.LCFI1:
 351              		.cfi_def_cfa_offset 8
 352              		.cfi_offset 3, -8
 353              		.cfi_offset 14, -4
 354              	.LBB4:
 355              	.LBB5:
 356              		.file 2 "./math/pprz_orientation_conversion.h"
   1:./math/pprz_orientation_conversion.h **** /*
   2:./math/pprz_orientation_conversion.h ****  * Copyright (C) 2011-2012 The Paparazzi Team
   3:./math/pprz_orientation_conversion.h ****  *
   4:./math/pprz_orientation_conversion.h ****  * This file is part of paparazzi.
   5:./math/pprz_orientation_conversion.h ****  *
   6:./math/pprz_orientation_conversion.h ****  * paparazzi is free software; you can redistribute it and/or modify
   7:./math/pprz_orientation_conversion.h ****  * it under the terms of the GNU General Public License as published by
   8:./math/pprz_orientation_conversion.h ****  * the Free Software Foundation; either version 2, or (at your option)
   9:./math/pprz_orientation_conversion.h ****  * any later version.
  10:./math/pprz_orientation_conversion.h ****  *
  11:./math/pprz_orientation_conversion.h ****  * paparazzi is distributed in the hope that it will be useful,
  12:./math/pprz_orientation_conversion.h ****  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  13:./math/pprz_orientation_conversion.h ****  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  14:./math/pprz_orientation_conversion.h ****  * GNU General Public License for more details.
  15:./math/pprz_orientation_conversion.h ****  *
  16:./math/pprz_orientation_conversion.h ****  * You should have received a copy of the GNU General Public License
  17:./math/pprz_orientation_conversion.h ****  * along with paparazzi; see the file COPYING.  If not, see
  18:./math/pprz_orientation_conversion.h ****  * <http://www.gnu.org/licenses/>.
  19:./math/pprz_orientation_conversion.h ****  *
  20:./math/pprz_orientation_conversion.h ****  */
  21:./math/pprz_orientation_conversion.h **** 
  22:./math/pprz_orientation_conversion.h **** /**
  23:./math/pprz_orientation_conversion.h ****  * @file math/pprz_orientation_conversion.h
  24:./math/pprz_orientation_conversion.h ****  * Generic orientation representation and conversions.
  25:./math/pprz_orientation_conversion.h ****  *
  26:./math/pprz_orientation_conversion.h ****  * This file contains the functions to automatically convert between
  27:./math/pprz_orientation_conversion.h ****  * the different representations. They should normally not be used
  28:./math/pprz_orientation_conversion.h ****  * directly and instead the stateGet/Set interfaces used.
  29:./math/pprz_orientation_conversion.h ****  * Also see the @ref math_orientation_representation "Generic Orientation Representation" page.
  30:./math/pprz_orientation_conversion.h ****  *
  31:./math/pprz_orientation_conversion.h ****  * @author Felix Ruess <felix.ruess@gmail.com>
  32:./math/pprz_orientation_conversion.h ****  */
  33:./math/pprz_orientation_conversion.h **** 
  34:./math/pprz_orientation_conversion.h **** /**
  35:./math/pprz_orientation_conversion.h ****  * @addtogroup math
  36:./math/pprz_orientation_conversion.h ****  * @{
  37:./math/pprz_orientation_conversion.h ****  */
  38:./math/pprz_orientation_conversion.h **** 
  39:./math/pprz_orientation_conversion.h **** /**
  40:./math/pprz_orientation_conversion.h ****  * This generic orientation representation consists of a struct, containing the 6 orientation
  41:./math/pprz_orientation_conversion.h ****  * representations, and a status variable. The bits in the status variable indicate  which
  42:./math/pprz_orientation_conversion.h ****  * representations of the orientation are up-to-date.
  43:./math/pprz_orientation_conversion.h ****  *
  44:./math/pprz_orientation_conversion.h ****  * When a getter is used to get a certain representation, the status bit is checked to see if
  45:./math/pprz_orientation_conversion.h ****  * the current value is already available in the desired orientation representation.
  46:./math/pprz_orientation_conversion.h ****  * If the desired representation is not available, it will be calculated.
  47:./math/pprz_orientation_conversion.h ****  *
  48:./math/pprz_orientation_conversion.h ****  * When a setter is used to set a representation, all status bits are cleared, and only the
  49:./math/pprz_orientation_conversion.h ****  * status bit for the set representation is set to one.
  50:./math/pprz_orientation_conversion.h ****  */
  51:./math/pprz_orientation_conversion.h **** 
  52:./math/pprz_orientation_conversion.h **** /**
  53:./math/pprz_orientation_conversion.h ****  * @defgroup math_orientation_representation Generic Orientation Representations
  54:./math/pprz_orientation_conversion.h ****  * @{
  55:./math/pprz_orientation_conversion.h ****  */
  56:./math/pprz_orientation_conversion.h **** 
  57:./math/pprz_orientation_conversion.h **** #ifndef PPRZ_ORIENTATION_CONVERSION_H
  58:./math/pprz_orientation_conversion.h **** #define PPRZ_ORIENTATION_CONVERSION_H
  59:./math/pprz_orientation_conversion.h **** 
  60:./math/pprz_orientation_conversion.h **** #include "math/pprz_algebra_int.h"
  61:./math/pprz_orientation_conversion.h **** #include "math/pprz_algebra_float.h"
  62:./math/pprz_orientation_conversion.h **** 
  63:./math/pprz_orientation_conversion.h **** #include "std.h"
  64:./math/pprz_orientation_conversion.h **** 
  65:./math/pprz_orientation_conversion.h **** 
  66:./math/pprz_orientation_conversion.h **** #define ORREP_QUAT_I  0  ///< Quaternion (BFP int)
  67:./math/pprz_orientation_conversion.h **** #define ORREP_EULER_I 1  ///< zyx Euler (BFP int)
  68:./math/pprz_orientation_conversion.h **** #define ORREP_RMAT_I  2  ///< Rotation Matrix (BFP int)
  69:./math/pprz_orientation_conversion.h **** #define ORREP_QUAT_F  3  ///< Quaternion (float)
  70:./math/pprz_orientation_conversion.h **** #define ORREP_EULER_F 4  ///< zyx Euler (float)
  71:./math/pprz_orientation_conversion.h **** #define ORREP_RMAT_F  5  ///< Rotation Matrix (float)
  72:./math/pprz_orientation_conversion.h **** 
  73:./math/pprz_orientation_conversion.h **** /*
  74:./math/pprz_orientation_conversion.h ****  * @brief Struct with euler/rmat/quaternion orientation representations in BFP int and float
  75:./math/pprz_orientation_conversion.h ****  */
  76:./math/pprz_orientation_conversion.h **** struct OrientationReps {
  77:./math/pprz_orientation_conversion.h ****   /**
  78:./math/pprz_orientation_conversion.h ****    * Holds the status bits for all orientation representations.
  79:./math/pprz_orientation_conversion.h ****    * When the corresponding bit is set, the representation
  80:./math/pprz_orientation_conversion.h ****    * is already computed.
  81:./math/pprz_orientation_conversion.h ****    */
  82:./math/pprz_orientation_conversion.h ****   uint8_t status;
  83:./math/pprz_orientation_conversion.h **** 
  84:./math/pprz_orientation_conversion.h ****   /**
  85:./math/pprz_orientation_conversion.h ****    * Orientation quaternion.
  86:./math/pprz_orientation_conversion.h ****    * Units: #INT32_QUAT_FRAC
  87:./math/pprz_orientation_conversion.h ****    */
  88:./math/pprz_orientation_conversion.h ****   struct Int32Quat quat_i;
  89:./math/pprz_orientation_conversion.h **** 
  90:./math/pprz_orientation_conversion.h ****   /**
  91:./math/pprz_orientation_conversion.h ****    * Orientation in zyx euler angles.
  92:./math/pprz_orientation_conversion.h ****    * Units: rad in BFP with #INT32_ANGLE_FRAC
  93:./math/pprz_orientation_conversion.h ****    */
  94:./math/pprz_orientation_conversion.h ****   struct Int32Eulers eulers_i;
  95:./math/pprz_orientation_conversion.h **** 
  96:./math/pprz_orientation_conversion.h ****   /**
  97:./math/pprz_orientation_conversion.h ****    * Orientation rotation matrix.
  98:./math/pprz_orientation_conversion.h ****    * Units: rad in BFP with #INT32_TRIG_FRAC
  99:./math/pprz_orientation_conversion.h ****    */
 100:./math/pprz_orientation_conversion.h ****   struct Int32RMat rmat_i;
 101:./math/pprz_orientation_conversion.h **** 
 102:./math/pprz_orientation_conversion.h ****   /**
 103:./math/pprz_orientation_conversion.h ****    * Orientation as quaternion.
 104:./math/pprz_orientation_conversion.h ****    * Units: unit length quaternion
 105:./math/pprz_orientation_conversion.h ****    */
 106:./math/pprz_orientation_conversion.h ****   struct FloatQuat quat_f;
 107:./math/pprz_orientation_conversion.h **** 
 108:./math/pprz_orientation_conversion.h ****   /**
 109:./math/pprz_orientation_conversion.h ****    * Orienation in zyx euler angles.
 110:./math/pprz_orientation_conversion.h ****    * Units: rad
 111:./math/pprz_orientation_conversion.h ****    */
 112:./math/pprz_orientation_conversion.h ****   struct FloatEulers eulers_f;
 113:./math/pprz_orientation_conversion.h **** 
 114:./math/pprz_orientation_conversion.h ****   /**
 115:./math/pprz_orientation_conversion.h ****    * Orientation rotation matrix.
 116:./math/pprz_orientation_conversion.h ****    * Units: rad
 117:./math/pprz_orientation_conversion.h ****    */
 118:./math/pprz_orientation_conversion.h ****   struct FloatRMat   rmat_f;
 119:./math/pprz_orientation_conversion.h **** };
 120:./math/pprz_orientation_conversion.h **** 
 121:./math/pprz_orientation_conversion.h **** /************* declaration of transformation functions ************/
 122:./math/pprz_orientation_conversion.h **** extern void orientationCalcQuat_i(struct OrientationReps* orientation);
 123:./math/pprz_orientation_conversion.h **** extern void orientationCalcRMat_i(struct OrientationReps* orientation);
 124:./math/pprz_orientation_conversion.h **** extern void orientationCalcEulers_i(struct OrientationReps* orientation);
 125:./math/pprz_orientation_conversion.h **** extern void orientationCalcQuat_f(struct OrientationReps* orientation);
 126:./math/pprz_orientation_conversion.h **** extern void orientationCalcRMat_f(struct OrientationReps* orientation);
 127:./math/pprz_orientation_conversion.h **** extern void orientationCalcEulers_f(struct OrientationReps* orientation);
 128:./math/pprz_orientation_conversion.h **** 
 129:./math/pprz_orientation_conversion.h **** 
 130:./math/pprz_orientation_conversion.h **** /*********************** validity test functions ******************/
 131:./math/pprz_orientation_conversion.h **** /// Test if orientations are valid.
 132:./math/pprz_orientation_conversion.h **** static inline bool_t orienationCheckValid(struct OrientationReps* orientation) {
 133:./math/pprz_orientation_conversion.h ****   return (orientation->status);
 134:./math/pprz_orientation_conversion.h **** }
 135:./math/pprz_orientation_conversion.h **** 
 136:./math/pprz_orientation_conversion.h **** /// Set vehicle body attitude from quaternion (int).
 137:./math/pprz_orientation_conversion.h **** static inline void orientationSetQuat_i(struct OrientationReps* orientation, struct Int32Quat* quat
 138:./math/pprz_orientation_conversion.h ****   QUAT_COPY(orientation->quat_i, *quat);
 139:./math/pprz_orientation_conversion.h ****   /* clear bits for all attitude representations and only set the new one */
 140:./math/pprz_orientation_conversion.h ****   orientation->status = (1 << ORREP_QUAT_I);
 141:./math/pprz_orientation_conversion.h **** }
 142:./math/pprz_orientation_conversion.h **** 
 143:./math/pprz_orientation_conversion.h **** /// Set vehicle body attitude from rotation matrix (int).
 144:./math/pprz_orientation_conversion.h **** static inline void orientationSetRMat_i(struct OrientationReps* orientation, struct Int32RMat* rmat
 145:./math/pprz_orientation_conversion.h ****   RMAT_COPY(orientation->rmat_i, *rmat);
 146:./math/pprz_orientation_conversion.h ****   /* clear bits for all attitude representations and only set the new one */
 147:./math/pprz_orientation_conversion.h ****   orientation->status = (1 << ORREP_RMAT_I);
 148:./math/pprz_orientation_conversion.h **** }
 149:./math/pprz_orientation_conversion.h **** 
 150:./math/pprz_orientation_conversion.h **** /// Set vehicle body attitude from euler angles (int).
 151:./math/pprz_orientation_conversion.h **** static inline void orientationSetEulers_i(struct OrientationReps* orientation, struct Int32Eulers* 
 152:./math/pprz_orientation_conversion.h ****   EULERS_COPY(orientation->eulers_i, *eulers);
 153:./math/pprz_orientation_conversion.h ****   /* clear bits for all attitude representations and only set the new one */
 154:./math/pprz_orientation_conversion.h ****   orientation->status = (1 << ORREP_EULER_I);
 155:./math/pprz_orientation_conversion.h **** }
 156:./math/pprz_orientation_conversion.h **** 
 157:./math/pprz_orientation_conversion.h **** /// Set vehicle body attitude from quaternion (float).
 158:./math/pprz_orientation_conversion.h **** static inline void orientationSetQuat_f(struct OrientationReps* orientation, struct FloatQuat* quat
 159:./math/pprz_orientation_conversion.h ****   QUAT_COPY(orientation->quat_f, *quat);
 160:./math/pprz_orientation_conversion.h ****   /* clear bits for all attitude representations and only set the new one */
 161:./math/pprz_orientation_conversion.h ****   orientation->status = (1 << ORREP_QUAT_F);
 162:./math/pprz_orientation_conversion.h **** }
 163:./math/pprz_orientation_conversion.h **** 
 164:./math/pprz_orientation_conversion.h **** /// Set vehicle body attitude from rotation matrix (float).
 165:./math/pprz_orientation_conversion.h **** static inline void orientationSetRMat_f(struct OrientationReps* orientation, struct FloatRMat* rmat
 166:./math/pprz_orientation_conversion.h ****   RMAT_COPY(orientation->rmat_f, *rmat);
 167:./math/pprz_orientation_conversion.h ****   /* clear bits for all attitude representations and only set the new one */
 168:./math/pprz_orientation_conversion.h ****   orientation->status = (1 << ORREP_RMAT_F);
 169:./math/pprz_orientation_conversion.h **** }
 170:./math/pprz_orientation_conversion.h **** 
 171:./math/pprz_orientation_conversion.h **** /// Set vehicle body attitude from euler angles (float).
 172:./math/pprz_orientation_conversion.h **** static inline void orientationSetEulers_f(struct OrientationReps* orientation, struct FloatEulers* 
 173:./math/pprz_orientation_conversion.h ****   EULERS_COPY(orientation->eulers_f, *eulers);
 174:./math/pprz_orientation_conversion.h ****   /* clear bits for all attitude representations and only set the new one */
 175:./math/pprz_orientation_conversion.h ****   orientation->status = (1 << ORREP_EULER_F);
 176:./math/pprz_orientation_conversion.h **** }
 177:./math/pprz_orientation_conversion.h **** 
 178:./math/pprz_orientation_conversion.h **** 
 179:./math/pprz_orientation_conversion.h **** /// Get vehicle body attitude quaternion (int).
 180:./math/pprz_orientation_conversion.h **** static inline struct Int32Quat* orientationGetQuat_i(struct OrientationReps* orientation) {
 181:./math/pprz_orientation_conversion.h ****   if (!bit_is_set(orientation->status, ORREP_QUAT_I))
 182:./math/pprz_orientation_conversion.h ****     orientationCalcQuat_i(orientation);
 183:./math/pprz_orientation_conversion.h ****   return &orientation->quat_i;
 184:./math/pprz_orientation_conversion.h **** }
 185:./math/pprz_orientation_conversion.h **** 
 186:./math/pprz_orientation_conversion.h **** /// Get vehicle body attitude rotation matrix (int).
 187:./math/pprz_orientation_conversion.h **** static inline struct Int32RMat* orientationGetRMat_i(struct OrientationReps* orientation) {
 188:./math/pprz_orientation_conversion.h ****   if (!bit_is_set(orientation->status, ORREP_RMAT_I))
 357              		.loc 2 188 0
 358 0002 0548     		ldr	r0, .L16
 359 0004 90F8A431 		ldrb	r3, [r0, #420]	@ zero_extendqisi2
 360 0008 5B07     		lsls	r3, r3, #29
 361 000a 03D4     		bmi	.L14
 189:./math/pprz_orientation_conversion.h ****     orientationCalcRMat_i(orientation);
 362              		.loc 2 189 0
 363 000c 00F5D270 		add	r0, r0, #420
 364 0010 FFF7FEFF 		bl	orientationCalcRMat_i
 365              	.LVL44:
 366              	.L14:
 367              	.LBE5:
 368              	.LBE4:
1008:./state.h     ****   return orientationGetRMat_i(&state.ned_to_body_orientation);
1009:./state.h     **** }
 369              		.loc 1 1009 0
 370 0014 0148     		ldr	r0, .L16+4
 371 0016 08BD     		pop	{r3, pc}
 372              	.L17:
 373              		.align	2
 374              	.L16:
 375 0018 00000000 		.word	state
 376 001c C4010000 		.word	state+452
 377              		.cfi_endproc
 378              	.LFE74:
 380              		.section	.text.ins_init,"ax",%progbits
 381              		.align	1
 382              		.global	ins_init
 383              		.thumb
 384              		.thumb_func
 386              	ins_init:
 387              	.LFB123:
 388              		.file 3 "subsystems/ins/ins_int.c"
   1:subsystems/ins/ins_int.c **** /*
   2:subsystems/ins/ins_int.c ****  * Copyright (C) 2008-2010 The Paparazzi Team
   3:subsystems/ins/ins_int.c ****  *
   4:subsystems/ins/ins_int.c ****  * This file is part of paparazzi.
   5:subsystems/ins/ins_int.c ****  *
   6:subsystems/ins/ins_int.c ****  * paparazzi is free software; you can redistribute it and/or modify
   7:subsystems/ins/ins_int.c ****  * it under the terms of the GNU General Public License as published by
   8:subsystems/ins/ins_int.c ****  * the Free Software Foundation; either version 2, or (at your option)
   9:subsystems/ins/ins_int.c ****  * any later version.
  10:subsystems/ins/ins_int.c ****  *
  11:subsystems/ins/ins_int.c ****  * paparazzi is distributed in the hope that it will be useful,
  12:subsystems/ins/ins_int.c ****  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  13:subsystems/ins/ins_int.c ****  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  14:subsystems/ins/ins_int.c ****  * GNU General Public License for more details.
  15:subsystems/ins/ins_int.c ****  *
  16:subsystems/ins/ins_int.c ****  * You should have received a copy of the GNU General Public License
  17:subsystems/ins/ins_int.c ****  * along with paparazzi; see the file COPYING.  If not, write to
  18:subsystems/ins/ins_int.c ****  * the Free Software Foundation, 59 Temple Place - Suite 330,
  19:subsystems/ins/ins_int.c ****  * Boston, MA 02111-1307, USA.
  20:subsystems/ins/ins_int.c ****  */
  21:subsystems/ins/ins_int.c **** 
  22:subsystems/ins/ins_int.c **** /**
  23:subsystems/ins/ins_int.c ****  * @file subsystems/ins/ins_int.c
  24:subsystems/ins/ins_int.c ****  *
  25:subsystems/ins/ins_int.c ****  * INS for rotorcrafts combining vertical and horizontal filters.
  26:subsystems/ins/ins_int.c ****  *
  27:subsystems/ins/ins_int.c ****  */
  28:subsystems/ins/ins_int.c **** 
  29:subsystems/ins/ins_int.c **** #include "subsystems/ins/ins_int.h"
  30:subsystems/ins/ins_int.c **** 
  31:subsystems/ins/ins_int.c **** #include "subsystems/imu.h"
  32:subsystems/ins/ins_int.c **** #include "subsystems/sensors/baro.h"
  33:subsystems/ins/ins_int.c **** #include "subsystems/gps.h"
  34:subsystems/ins/ins_int.c **** 
  35:subsystems/ins/ins_int.c **** #include "generated/airframe.h"
  36:subsystems/ins/ins_int.c **** 
  37:subsystems/ins/ins_int.c **** #if USE_VFF
  38:subsystems/ins/ins_int.c **** #include "subsystems/ins/vf_float.h"
  39:subsystems/ins/ins_int.c **** #endif
  40:subsystems/ins/ins_int.c **** 
  41:subsystems/ins/ins_int.c **** #if USE_HFF
  42:subsystems/ins/ins_int.c **** #include "subsystems/ins/hf_float.h"
  43:subsystems/ins/ins_int.c **** #endif
  44:subsystems/ins/ins_int.c **** 
  45:subsystems/ins/ins_int.c **** #ifdef SITL
  46:subsystems/ins/ins_int.c **** #include "nps_fdm.h"
  47:subsystems/ins/ins_int.c **** #include <stdio.h>
  48:subsystems/ins/ins_int.c **** #endif
  49:subsystems/ins/ins_int.c **** 
  50:subsystems/ins/ins_int.c **** 
  51:subsystems/ins/ins_int.c **** #include "math/pprz_geodetic_int.h"
  52:subsystems/ins/ins_int.c **** 
  53:subsystems/ins/ins_int.c **** #include "generated/flight_plan.h"
  54:subsystems/ins/ins_int.c **** 
  55:subsystems/ins/ins_int.c **** #ifndef USE_INS_NAV_INIT
  56:subsystems/ins/ins_int.c **** #define USE_INS_NAV_INIT TRUE
  57:subsystems/ins/ins_int.c **** PRINT_CONFIG_MSG("USE_INS_NAV_INIT defaulting to TRUE")
  58:subsystems/ins/ins_int.c **** #endif
  59:subsystems/ins/ins_int.c **** 
  60:subsystems/ins/ins_int.c **** /* gps transformed to LTP-NED  */
  61:subsystems/ins/ins_int.c **** struct LtpDef_i  ins_ltp_def;
  62:subsystems/ins/ins_int.c ****          bool_t  ins_ltp_initialised;
  63:subsystems/ins/ins_int.c **** struct NedCoor_i ins_gps_pos_cm_ned;
  64:subsystems/ins/ins_int.c **** struct NedCoor_i ins_gps_speed_cm_s_ned;
  65:subsystems/ins/ins_int.c **** #if USE_HFF
  66:subsystems/ins/ins_int.c **** /* horizontal gps transformed to NED in meters as float */
  67:subsystems/ins/ins_int.c **** struct FloatVect2 ins_gps_pos_m_ned;
  68:subsystems/ins/ins_int.c **** struct FloatVect2 ins_gps_speed_m_s_ned;
  69:subsystems/ins/ins_int.c **** #endif
  70:subsystems/ins/ins_int.c **** 
  71:subsystems/ins/ins_int.c **** /* barometer                   */
  72:subsystems/ins/ins_int.c **** #if USE_VFF
  73:subsystems/ins/ins_int.c **** int32_t ins_qfe;
  74:subsystems/ins/ins_int.c **** bool_t  ins_baro_initialised;
  75:subsystems/ins/ins_int.c **** int32_t ins_baro_alt;
  76:subsystems/ins/ins_int.c **** #if USE_SONAR
  77:subsystems/ins/ins_int.c **** bool_t  ins_update_on_agl;
  78:subsystems/ins/ins_int.c **** int32_t ins_sonar_offset;
  79:subsystems/ins/ins_int.c **** #endif
  80:subsystems/ins/ins_int.c **** #endif
  81:subsystems/ins/ins_int.c **** 
  82:subsystems/ins/ins_int.c **** /* output                      */
  83:subsystems/ins/ins_int.c **** struct NedCoor_i ins_ltp_pos;
  84:subsystems/ins/ins_int.c **** struct NedCoor_i ins_ltp_speed;
  85:subsystems/ins/ins_int.c **** struct NedCoor_i ins_ltp_accel;
  86:subsystems/ins/ins_int.c **** 
  87:subsystems/ins/ins_int.c **** 
  88:subsystems/ins/ins_int.c **** void ins_init() {
 389              		.loc 3 88 0
 390              		.cfi_startproc
 391              		@ args = 0, pretend = 0, frame = 24
 392              		@ frame_needed = 0, uses_anonymous_args = 0
 393 0000 70B5     		push	{r4, r5, r6, lr}
 394              	.LCFI2:
 395              		.cfi_def_cfa_offset 16
 396              		.cfi_offset 4, -16
 397              		.cfi_offset 5, -12
 398              		.cfi_offset 6, -8
 399              		.cfi_offset 14, -4
  89:subsystems/ins/ins_int.c **** #if USE_INS_NAV_INIT
  90:subsystems/ins/ins_int.c ****   ins_ltp_initialised = TRUE;
 400              		.loc 3 90 0
 401 0002 184B     		ldr	r3, .L19
  91:subsystems/ins/ins_int.c **** 
  92:subsystems/ins/ins_int.c ****   /** FIXME: should use the same code than MOVE_WP in firmwares/rotorcraft/datalink.c */
  93:subsystems/ins/ins_int.c ****   struct LlaCoor_i llh_nav0; /* Height above the ellipsoid */
  94:subsystems/ins/ins_int.c ****   llh_nav0.lat = INT32_RAD_OF_DEG(NAV_LAT0);
  95:subsystems/ins/ins_int.c ****   llh_nav0.lon = INT32_RAD_OF_DEG(NAV_LON0);
  96:subsystems/ins/ins_int.c ****   /* NAV_ALT0 = ground alt above msl, NAV_MSL0 = geoid-height (msl) over ellipsoid */
  97:subsystems/ins/ins_int.c ****   llh_nav0.alt = NAV_ALT0 + NAV_MSL0;
 402              		.loc 3 97 0
 403 0004 184A     		ldr	r2, .L19+4
  90:subsystems/ins/ins_int.c ****   ins_ltp_initialised = TRUE;
 404              		.loc 3 90 0
 405 0006 0125     		movs	r5, #1
 406              		.loc 3 97 0
 407 0008 1849     		ldr	r1, .L19+8
  88:subsystems/ins/ins_int.c **** void ins_init() {
 408              		.loc 3 88 0
 409 000a 86B0     		sub	sp, sp, #24
 410              	.LCFI3:
 411              		.cfi_def_cfa_offset 40
  90:subsystems/ins/ins_int.c ****   ins_ltp_initialised = TRUE;
 412              		.loc 3 90 0
 413 000c 1D70     		strb	r5, [r3, #0]
  98:subsystems/ins/ins_int.c **** 
  99:subsystems/ins/ins_int.c ****   struct EcefCoor_i ecef_nav0;
 100:subsystems/ins/ins_int.c ****   ecef_of_lla_i(&ecef_nav0, &llh_nav0);
 101:subsystems/ins/ins_int.c **** 
 102:subsystems/ins/ins_int.c ****   ltp_def_from_ecef_i(&ins_ltp_def, &ecef_nav0);
 414              		.loc 3 102 0
 415 000e 184E     		ldr	r6, .L19+12
  97:subsystems/ins/ins_int.c ****   llh_nav0.alt = NAV_ALT0 + NAV_MSL0;
 416              		.loc 3 97 0
 417 0010 4CF68A23 		movw	r3, #51850
 418 0014 8DE80E00 		stmia	sp, {r1, r2, r3}
 100:subsystems/ins/ins_int.c ****   ecef_of_lla_i(&ecef_nav0, &llh_nav0);
 419              		.loc 3 100 0
 420 0018 03A8     		add	r0, sp, #12
 421 001a 6946     		mov	r1, sp
 103:subsystems/ins/ins_int.c ****   ins_ltp_def.hmsl = NAV_ALT0;
 422              		.loc 3 103 0
 423 001c 0024     		movs	r4, #0
 100:subsystems/ins/ins_int.c ****   ecef_of_lla_i(&ecef_nav0, &llh_nav0);
 424              		.loc 3 100 0
 425 001e FFF7FEFF 		bl	ecef_of_lla_i
 426              	.LVL45:
 102:subsystems/ins/ins_int.c ****   ltp_def_from_ecef_i(&ins_ltp_def, &ecef_nav0);
 427              		.loc 3 102 0
 428 0022 3046     		mov	r0, r6
 429 0024 03A9     		add	r1, sp, #12
 430 0026 FFF7FEFF 		bl	ltp_def_from_ecef_i
 431              	.LVL46:
 432              		.loc 3 103 0
 433 002a F463     		str	r4, [r6, #60]
 104:subsystems/ins/ins_int.c ****   stateSetLocalOrigin_i(&ins_ltp_def);
 434              		.loc 3 104 0
 435 002c FFF7FEFF 		bl	stateSetLocalOrigin_i.constprop.3
 436              	.LVL47:
 105:subsystems/ins/ins_int.c **** #else
 106:subsystems/ins/ins_int.c ****   ins_ltp_initialised  = FALSE;
 107:subsystems/ins/ins_int.c **** #endif
 108:subsystems/ins/ins_int.c **** #if USE_VFF
 109:subsystems/ins/ins_int.c ****   ins_baro_initialised = FALSE;
 437              		.loc 3 109 0
 438 0030 1048     		ldr	r0, .L19+16
 439 0032 0470     		strb	r4, [r0, #0]
 110:subsystems/ins/ins_int.c **** #if USE_SONAR
 111:subsystems/ins/ins_int.c ****   ins_update_on_agl = FALSE;
 112:subsystems/ins/ins_int.c **** #endif
 113:subsystems/ins/ins_int.c ****   vff_init(0., 0., 0.);
 440              		.loc 3 113 0
 441 0034 0020     		movs	r0, #0
 442 0036 0146     		mov	r1, r0
 443 0038 0246     		mov	r2, r0
 444 003a FFF7FEFF 		bl	vff_init
 445              	.LVL48:
 114:subsystems/ins/ins_int.c **** #endif
 115:subsystems/ins/ins_int.c ****   ins.vf_realign = FALSE;
 446              		.loc 3 115 0
 447 003e 0E49     		ldr	r1, .L19+20
 116:subsystems/ins/ins_int.c ****   ins.hf_realign = FALSE;
 117:subsystems/ins/ins_int.c **** #if USE_HFF
 118:subsystems/ins/ins_int.c ****   b2_hff_init(0., 0., 0., 0.);
 119:subsystems/ins/ins_int.c **** #endif
 120:subsystems/ins/ins_int.c ****   INT32_VECT3_ZERO(ins_ltp_pos);
 448              		.loc 3 120 0
 449 0040 0E4A     		ldr	r2, .L19+24
 121:subsystems/ins/ins_int.c ****   INT32_VECT3_ZERO(ins_ltp_speed);
 450              		.loc 3 121 0
 451 0042 0F4B     		ldr	r3, .L19+28
 122:subsystems/ins/ins_int.c ****   INT32_VECT3_ZERO(ins_ltp_accel);
 452              		.loc 3 122 0
 453 0044 0F48     		ldr	r0, .L19+32
 115:subsystems/ins/ins_int.c ****   ins.vf_realign = FALSE;
 454              		.loc 3 115 0
 455 0046 8C70     		strb	r4, [r1, #2]
 116:subsystems/ins/ins_int.c ****   ins.hf_realign = FALSE;
 456              		.loc 3 116 0
 457 0048 4C70     		strb	r4, [r1, #1]
 120:subsystems/ins/ins_int.c ****   INT32_VECT3_ZERO(ins_ltp_pos);
 458              		.loc 3 120 0
 459 004a 1460     		str	r4, [r2, #0]
 460 004c 5460     		str	r4, [r2, #4]
 461 004e 9460     		str	r4, [r2, #8]
 121:subsystems/ins/ins_int.c ****   INT32_VECT3_ZERO(ins_ltp_speed);
 462              		.loc 3 121 0
 463 0050 1C60     		str	r4, [r3, #0]
 464 0052 5C60     		str	r4, [r3, #4]
 465 0054 9C60     		str	r4, [r3, #8]
 466              		.loc 3 122 0
 467 0056 0460     		str	r4, [r0, #0]
 468 0058 4460     		str	r4, [r0, #4]
 469 005a 8460     		str	r4, [r0, #8]
 123:subsystems/ins/ins_int.c **** 
 124:subsystems/ins/ins_int.c ****   // TODO correct init
 125:subsystems/ins/ins_int.c ****   ins.status = INS_RUNNING;
 470              		.loc 3 125 0
 471 005c 0D70     		strb	r5, [r1, #0]
 126:subsystems/ins/ins_int.c **** 
 127:subsystems/ins/ins_int.c **** }
 472              		.loc 3 127 0
 473 005e 06B0     		add	sp, sp, #24
 474 0060 70BD     		pop	{r4, r5, r6, pc}
 475              	.L20:
 476 0062 00BF     		.align	2
 477              	.L19:
 478 0064 00000000 		.word	.LANCHOR4
 479 0068 AD047400 		.word	7603373
 480 006c E4F10300 		.word	258532
 481 0070 00000000 		.word	.LANCHOR3
 482 0074 00000000 		.word	.LANCHOR5
 483 0078 00000000 		.word	ins
 484 007c 00000000 		.word	.LANCHOR2
 485 0080 00000000 		.word	.LANCHOR1
 486 0084 00000000 		.word	.LANCHOR0
 487              		.cfi_endproc
 488              	.LFE123:
 490              		.section	.text.ins_periodic,"ax",%progbits
 491              		.align	1
 492              		.global	ins_periodic
 493              		.thumb
 494              		.thumb_func
 496              	ins_periodic:
 497              	.LFB124:
 128:subsystems/ins/ins_int.c **** 
 129:subsystems/ins/ins_int.c **** void ins_periodic( void ) {
 498              		.loc 3 129 0
 499              		.cfi_startproc
 500              		@ args = 0, pretend = 0, frame = 0
 501              		@ frame_needed = 0, uses_anonymous_args = 0
 502              		@ link register save eliminated.
 503 0000 7047     		bx	lr
 504              		.cfi_endproc
 505              	.LFE124:
 507              		.section	.text.ins_realign_h,"ax",%progbits
 508              		.align	1
 509              		.global	ins_realign_h
 510              		.thumb
 511              		.thumb_func
 513              	ins_realign_h:
 514              	.LFB125:
 130:subsystems/ins/ins_int.c **** }
 131:subsystems/ins/ins_int.c **** 
 132:subsystems/ins/ins_int.c **** void ins_realign_h(struct FloatVect2 pos __attribute__ ((unused)), struct FloatVect2 speed __attrib
 515              		.loc 3 132 0
 516              		.cfi_startproc
 517              		@ args = 0, pretend = 0, frame = 16
 518              		@ frame_needed = 0, uses_anonymous_args = 0
 519              		.loc 3 132 0
 520 0000 1FB5     		push	{r0, r1, r2, r3, r4, lr}
 521              	.LCFI4:
 522              		.cfi_def_cfa_offset 24
 523              		.cfi_offset 0, -24
 524              		.cfi_offset 1, -20
 525              		.cfi_offset 2, -16
 526              		.cfi_offset 3, -12
 527              		.cfi_offset 4, -8
 528              		.cfi_offset 14, -4
 529              		.loc 3 132 0
 530 0002 04AC     		add	r4, sp, #16
 531 0004 04E90300 		stmdb	r4, {r0, r1}
 532 0008 8DE80C00 		stmia	sp, {r2, r3}
 133:subsystems/ins/ins_int.c **** #if USE_HFF
 134:subsystems/ins/ins_int.c ****   b2_hff_realign(pos, speed);
 135:subsystems/ins/ins_int.c **** #endif /* USE_HFF */
 136:subsystems/ins/ins_int.c **** }
 533              		.loc 3 136 0
 534 000c 1FBD     		pop	{r0, r1, r2, r3, r4, pc}
 535              		.cfi_endproc
 536              	.LFE125:
 538              		.section	.text.ins_realign_v,"ax",%progbits
 539              		.align	1
 540              		.global	ins_realign_v
 541              		.thumb
 542              		.thumb_func
 544              	ins_realign_v:
 545              	.LFB126:
 137:subsystems/ins/ins_int.c **** 
 138:subsystems/ins/ins_int.c **** void ins_realign_v(float z __attribute__ ((unused))) {
 546              		.loc 3 138 0
 547              		.cfi_startproc
 548              		@ args = 0, pretend = 0, frame = 0
 549              		@ frame_needed = 0, uses_anonymous_args = 0
 550              		@ link register save eliminated.
 551              	.LVL49:
 139:subsystems/ins/ins_int.c **** #if USE_VFF
 140:subsystems/ins/ins_int.c ****   vff_realign(z);
 141:subsystems/ins/ins_int.c **** #endif
 142:subsystems/ins/ins_int.c **** }
 552              		.loc 3 142 0
 140:subsystems/ins/ins_int.c ****   vff_realign(z);
 553              		.loc 3 140 0
 554 0000 FFF7FEBF 		b	vff_realign
 555              	.LVL50:
 556              		.cfi_endproc
 557              	.LFE126:
 559              		.global	__aeabi_f2iz
 560              		.global	__aeabi_dadd
 561              		.global	__aeabi_d2iz
 562              		.section	.text.ins_propagate,"ax",%progbits
 563              		.align	1
 564              		.global	ins_propagate
 565              		.thumb
 566              		.thumb_func
 568              	ins_propagate:
 569              	.LFB127:
 143:subsystems/ins/ins_int.c **** 
 144:subsystems/ins/ins_int.c **** void ins_propagate() {
 570              		.loc 3 144 0
 571              		.cfi_startproc
 572              		@ args = 0, pretend = 0, frame = 0
 573              		@ frame_needed = 0, uses_anonymous_args = 0
 145:subsystems/ins/ins_int.c ****   /* untilt accels */
 146:subsystems/ins/ins_int.c ****   struct Int32Vect3 accel_meas_body;
 147:subsystems/ins/ins_int.c ****   INT32_RMAT_TRANSP_VMULT(accel_meas_body, imu.body_to_imu_rmat, imu.accel);
 574              		.loc 3 147 0
 575 0000 514B     		ldr	r3, .L31+8
 144:subsystems/ins/ins_int.c **** void ins_propagate() {
 576              		.loc 3 144 0
 577 0002 2DE9F041 		push	{r4, r5, r6, r7, r8, lr}
 578              	.LCFI5:
 579              		.cfi_def_cfa_offset 24
 580              		.cfi_offset 4, -24
 581              		.cfi_offset 5, -20
 582              		.cfi_offset 6, -16
 583              		.cfi_offset 7, -12
 584              		.cfi_offset 8, -8
 585              		.cfi_offset 14, -4
 586              		.loc 3 147 0
 587 0006 1869     		ldr	r0, [r3, #16]
 588 0008 D3F8A040 		ldr	r4, [r3, #160]
 589 000c D968     		ldr	r1, [r3, #12]
 590 000e 4443     		muls	r4, r0, r4
 591 0010 D3F89450 		ldr	r5, [r3, #148]
 592 0014 5A69     		ldr	r2, [r3, #20]
 593 0016 05FB0146 		mla	r6, r5, r1, r4
 594 001a D3F8AC70 		ldr	r7, [r3, #172]
 595 001e D3F8A440 		ldr	r4, [r3, #164]
 596 0022 07FB0265 		mla	r5, r7, r2, r6
 597 0026 4443     		muls	r4, r0, r4
 598 0028 D3F89870 		ldr	r7, [r3, #152]
 599 002c AE13     		asrs	r6, r5, #14
 600              	.LVL51:
 601 002e 07FB0145 		mla	r5, r7, r1, r4
 602 0032 D3F8B070 		ldr	r7, [r3, #176]
 603 0036 07FB0254 		mla	r4, r7, r2, r5
 604 003a A513     		asrs	r5, r4, #14
 605              	.LVL52:
 606 003c D3F8A840 		ldr	r4, [r3, #168]
 607 0040 D3F89C70 		ldr	r7, [r3, #156]
 608 0044 4443     		muls	r4, r0, r4
 609 0046 07FB0141 		mla	r1, r7, r1, r4
 610 004a D3F8B430 		ldr	r3, [r3, #180]
 611 004e 03FB0210 		mla	r0, r3, r2, r1
 612 0052 8413     		asrs	r4, r0, #14
 613              	.LVL53:
 148:subsystems/ins/ins_int.c ****   struct Int32Vect3 accel_meas_ltp;
 149:subsystems/ins/ins_int.c ****   INT32_RMAT_TRANSP_VMULT(accel_meas_ltp, (*stateGetNedToBodyRMat_i()), accel_meas_body);
 614              		.loc 3 149 0
 615 0054 FFF7FEFF 		bl	stateGetNedToBodyRMat_i
 616              	.LVL54:
 617 0058 0268     		ldr	r2, [r0, #0]
 618 005a 02FB06F8 		mul	r8, r2, r6
 619 005e FFF7FEFF 		bl	stateGetNedToBodyRMat_i
 620              	.LVL55:
 621 0062 C768     		ldr	r7, [r0, #12]
 622 0064 FFF7FEFF 		bl	stateGetNedToBodyRMat_i
 623              	.LVL56:
 624 0068 07FB0588 		mla	r8, r7, r5, r8
 625 006c 8169     		ldr	r1, [r0, #24]
 626 006e 01FB0483 		mla	r3, r1, r4, r8
 627 0072 4FEAA338 		asr	r8, r3, #14
 628              	.LVL57:
 629 0076 FFF7FEFF 		bl	stateGetNedToBodyRMat_i
 630              	.LVL58:
 631 007a 4768     		ldr	r7, [r0, #4]
 632 007c FFF7FEFF 		bl	stateGetNedToBodyRMat_i
 633              	.LVL59:
 634 0080 7743     		muls	r7, r6, r7
 635 0082 0069     		ldr	r0, [r0, #16]
 636 0084 00FB0577 		mla	r7, r0, r5, r7
 637 0088 FFF7FEFF 		bl	stateGetNedToBodyRMat_i
 638              	.LVL60:
 639 008c C269     		ldr	r2, [r0, #28]
 640 008e 02FB0471 		mla	r1, r2, r4, r7
 641 0092 8F13     		asrs	r7, r1, #14
 642              	.LVL61:
 643 0094 FFF7FEFF 		bl	stateGetNedToBodyRMat_i
 644              	.LVL62:
 645 0098 8368     		ldr	r3, [r0, #8]
 646 009a 5E43     		muls	r6, r3, r6
 647              	.LVL63:
 648 009c FFF7FEFF 		bl	stateGetNedToBodyRMat_i
 649              	.LVL64:
 650 00a0 4069     		ldr	r0, [r0, #20]
 651 00a2 00FB0565 		mla	r5, r0, r5, r6
 652              	.LVL65:
 653 00a6 FFF7FEFF 		bl	stateGetNedToBodyRMat_i
 654              	.LVL66:
 655 00aa 026A     		ldr	r2, [r0, #32]
 150:subsystems/ins/ins_int.c **** 
 151:subsystems/ins/ins_int.c **** #if USE_VFF
 152:subsystems/ins/ins_int.c ****   float z_accel_meas_float = ACCEL_FLOAT_OF_BFP(accel_meas_ltp.z);
 153:subsystems/ins/ins_int.c ****   if (baro.status == BS_RUNNING && ins_baro_initialised) {
 656              		.loc 3 153 0
 657 00ac 2749     		ldr	r1, .L31+12
 149:subsystems/ins/ins_int.c ****   INT32_RMAT_TRANSP_VMULT(accel_meas_ltp, (*stateGetNedToBodyRMat_i()), accel_meas_body);
 658              		.loc 3 149 0
 659 00ae 02FB0455 		mla	r5, r2, r4, r5
 660              		.loc 3 153 0
 661 00b2 0B7A     		ldrb	r3, [r1, #8]	@ zero_extendqisi2
 149:subsystems/ins/ins_int.c ****   INT32_RMAT_TRANSP_VMULT(accel_meas_ltp, (*stateGetNedToBodyRMat_i()), accel_meas_body);
 662              		.loc 3 149 0
 663 00b4 A813     		asrs	r0, r5, #14
 664              	.LVL67:
 665              		.loc 3 153 0
 666 00b6 012B     		cmp	r3, #1
 667 00b8 28D1     		bne	.L25
 668              		.loc 3 153 0 is_stmt 0 discriminator 1
 669 00ba 254A     		ldr	r2, .L31+16
 670 00bc 1178     		ldrb	r1, [r2, #0]	@ zero_extendqisi2
 671 00be 29B3     		cbz	r1, .L25
 152:subsystems/ins/ins_int.c ****   float z_accel_meas_float = ACCEL_FLOAT_OF_BFP(accel_meas_ltp.z);
 672              		.loc 3 152 0 is_stmt 1
 673 00c0 FFF7FEFF 		bl	__aeabi_i2f
 674              	.LVL68:
 675 00c4 4FF06A51 		mov	r1, #981467136
 676 00c8 FFF7FEFF 		bl	__aeabi_fmul
 677              	.LVL69:
 154:subsystems/ins/ins_int.c ****     vff_propagate(z_accel_meas_float);
 678              		.loc 3 154 0
 679 00cc FFF7FEFF 		bl	vff_propagate
 680              	.LVL70:
 155:subsystems/ins/ins_int.c ****     ins_ltp_accel.z = ACCEL_BFP_OF_REAL(vff_zdotdot);
 681              		.loc 3 155 0
 682 00d0 2048     		ldr	r0, .L31+20
 683 00d2 4FF08941 		mov	r1, #1149239296
 684 00d6 0068     		ldr	r0, [r0, #0]	@ float
 685 00d8 FFF7FEFF 		bl	__aeabi_fmul
 686              	.LVL71:
 687 00dc FFF7FEFF 		bl	__aeabi_f2iz
 688              	.LVL72:
 689 00e0 1D4A     		ldr	r2, .L31+24
 156:subsystems/ins/ins_int.c ****     ins_ltp_speed.z = SPEED_BFP_OF_REAL(vff_zdot);
 690              		.loc 3 156 0
 691 00e2 1E49     		ldr	r1, .L31+28
 155:subsystems/ins/ins_int.c ****     ins_ltp_accel.z = ACCEL_BFP_OF_REAL(vff_zdotdot);
 692              		.loc 3 155 0
 693 00e4 9060     		str	r0, [r2, #8]
 694              		.loc 3 156 0
 695 00e6 0868     		ldr	r0, [r1, #0]	@ float
 696 00e8 4FF09241 		mov	r1, #1224736768
 697 00ec FFF7FEFF 		bl	__aeabi_fmul
 698              	.LVL73:
 699 00f0 FFF7FEFF 		bl	__aeabi_f2iz
 700              	.LVL74:
 701 00f4 1A4B     		ldr	r3, .L31+32
 157:subsystems/ins/ins_int.c ****     ins_ltp_pos.z   = POS_BFP_OF_REAL(vff_z);
 702              		.loc 3 157 0
 703 00f6 4FF08741 		mov	r1, #1132462080
 156:subsystems/ins/ins_int.c ****     ins_ltp_speed.z = SPEED_BFP_OF_REAL(vff_zdot);
 704              		.loc 3 156 0
 705 00fa 9860     		str	r0, [r3, #8]
 706              		.loc 3 157 0
 707 00fc 1948     		ldr	r0, .L31+36
 708 00fe 0068     		ldr	r0, [r0, #0]	@ float
 709 0100 FFF7FEFF 		bl	__aeabi_fmul
 710              	.LVL75:
 711 0104 FFF7FEFF 		bl	__aeabi_f2iz
 712              	.LVL76:
 713 0108 174B     		ldr	r3, .L31+40
 714 010a 09E0     		b	.L30
 715              	.LVL77:
 716              	.L25:
 158:subsystems/ins/ins_int.c ****   }
 159:subsystems/ins/ins_int.c ****   else { // feed accel from the sensors
 160:subsystems/ins/ins_int.c ****     // subtract -9.81m/s2 (acceleration measured due to gravity, but vehivle not accelerating in lt
 161:subsystems/ins/ins_int.c ****     ins_ltp_accel.z = accel_meas_ltp.z + ACCEL_BFP_OF_REAL(9.81);
 717              		.loc 3 161 0
 718 010c FFF7FEFF 		bl	__aeabi_i2d
 719              	.LVL78:
 720 0110 0BA3     		adr	r3, .L31
 721 0112 D3E90023 		ldrd	r2, [r3]
 722 0116 FFF7FEFF 		bl	__aeabi_dadd
 723              	.LVL79:
 724 011a FFF7FEFF 		bl	__aeabi_d2iz
 725              	.LVL80:
 726 011e 0E4B     		ldr	r3, .L31+24
 727              	.L30:
 162:subsystems/ins/ins_int.c ****   }
 163:subsystems/ins/ins_int.c **** #else
 164:subsystems/ins/ins_int.c ****   ins_ltp_accel.z = accel_meas_ltp.z + ACCEL_BFP_OF_REAL(9.81);
 165:subsystems/ins/ins_int.c **** #endif /* USE_VFF */
 166:subsystems/ins/ins_int.c **** 
 167:subsystems/ins/ins_int.c **** #if USE_HFF
 168:subsystems/ins/ins_int.c ****   /* propagate horizontal filter */
 169:subsystems/ins/ins_int.c ****   b2_hff_propagate();
 170:subsystems/ins/ins_int.c **** #else
 171:subsystems/ins/ins_int.c ****   ins_ltp_accel.x = accel_meas_ltp.x;
 728              		.loc 3 171 0
 729 0120 0D4A     		ldr	r2, .L31+24
 161:subsystems/ins/ins_int.c ****     ins_ltp_accel.z = accel_meas_ltp.z + ACCEL_BFP_OF_REAL(9.81);
 730              		.loc 3 161 0
 731 0122 9860     		str	r0, [r3, #8]
 732              		.loc 3 171 0
 733 0124 C2F80080 		str	r8, [r2, #0]
 172:subsystems/ins/ins_int.c ****   ins_ltp_accel.y = accel_meas_ltp.y;
 734              		.loc 3 172 0
 735 0128 5760     		str	r7, [r2, #4]
 173:subsystems/ins/ins_int.c **** #endif /* USE_HFF */
 174:subsystems/ins/ins_int.c **** 
 175:subsystems/ins/ins_int.c ****   INS_NED_TO_STATE();
 736              		.loc 3 175 0
 737 012a FFF7FEFF 		bl	stateSetPositionNed_i.constprop.2
 738              	.LVL81:
 739 012e FFF7FEFF 		bl	stateSetSpeedNed_i.constprop.1
 740              	.LVL82:
 176:subsystems/ins/ins_int.c **** }
 741              		.loc 3 176 0
 742 0132 BDE8F041 		pop	{r4, r5, r6, r7, r8, lr}
 175:subsystems/ins/ins_int.c ****   INS_NED_TO_STATE();
 743              		.loc 3 175 0
 744 0136 FFF7FEBF 		b	stateSetAccelNed_i.constprop.0
 745              	.LVL83:
 746              	.L32:
 747 013a 00BFAFF3 		.align	3
 747      0080
 748              	.L31:
 749 0140 1F85EB51 		.word	1374389535
 750 0144 B89EC340 		.word	1086561976
 751 0148 00000000 		.word	imu
 752 014c 00000000 		.word	baro
 753 0150 00000000 		.word	.LANCHOR5
 754 0154 00000000 		.word	vff_zdotdot
 755 0158 00000000 		.word	.LANCHOR0
 756 015c 00000000 		.word	vff_zdot
 757 0160 00000000 		.word	.LANCHOR1
 758 0164 00000000 		.word	vff_z
 759 0168 00000000 		.word	.LANCHOR2
 760              		.cfi_endproc
 761              	.LFE127:
 763 016c AFF30080 		.section	.text.ins_update_baro,"ax",%progbits
 764              		.align	1
 765              		.global	ins_update_baro
 766              		.thumb
 767              		.thumb_func
 769              	ins_update_baro:
 770              	.LFB128:
 177:subsystems/ins/ins_int.c **** 
 178:subsystems/ins/ins_int.c **** void ins_update_baro() {
 771              		.loc 3 178 0
 772              		.cfi_startproc
 773              		@ args = 0, pretend = 0, frame = 0
 774              		@ frame_needed = 0, uses_anonymous_args = 0
 179:subsystems/ins/ins_int.c **** #if USE_VFF
 180:subsystems/ins/ins_int.c ****   if (baro.status == BS_RUNNING) {
 775              		.loc 3 180 0
 776 0000 2849     		ldr	r1, .L37
 178:subsystems/ins/ins_int.c **** void ins_update_baro() {
 777              		.loc 3 178 0
 778 0002 08B5     		push	{r3, lr}
 779              	.LCFI6:
 780              		.cfi_def_cfa_offset 8
 781              		.cfi_offset 3, -8
 782              		.cfi_offset 14, -4
 783              		.loc 3 180 0
 784 0004 0A7A     		ldrb	r2, [r1, #8]	@ zero_extendqisi2
 785 0006 012A     		cmp	r2, #1
 786 0008 43D1     		bne	.L34
 181:subsystems/ins/ins_int.c ****     if (!ins_baro_initialised) {
 787              		.loc 3 181 0
 788 000a 274B     		ldr	r3, .L37+4
 789 000c 1878     		ldrb	r0, [r3, #0]	@ zero_extendqisi2
 790 000e 18B9     		cbnz	r0, .L35
 182:subsystems/ins/ins_int.c ****       ins_qfe = baro.absolute;
 791              		.loc 3 182 0
 792 0010 0868     		ldr	r0, [r1, #0]
 793 0012 2649     		ldr	r1, .L37+8
 183:subsystems/ins/ins_int.c ****       ins_baro_initialised = TRUE;
 794              		.loc 3 183 0
 795 0014 1A70     		strb	r2, [r3, #0]
 182:subsystems/ins/ins_int.c ****       ins_qfe = baro.absolute;
 796              		.loc 3 182 0
 797 0016 0860     		str	r0, [r1, #0]
 798              	.L35:
 184:subsystems/ins/ins_int.c ****     }
 185:subsystems/ins/ins_int.c ****     if (ins.vf_realign) {
 799              		.loc 3 185 0
 800 0018 2549     		ldr	r1, .L37+12
 801 001a 224A     		ldr	r2, .L37
 802 001c 8878     		ldrb	r0, [r1, #2]	@ zero_extendqisi2
 803 001e 234B     		ldr	r3, .L37+8
 804 0020 28B3     		cbz	r0, .L36
 186:subsystems/ins/ins_int.c ****       ins.vf_realign = FALSE;
 805              		.loc 3 186 0
 806 0022 0020     		movs	r0, #0
 807 0024 8870     		strb	r0, [r1, #2]
 187:subsystems/ins/ins_int.c ****       ins_qfe = baro.absolute;
 808              		.loc 3 187 0
 809 0026 1168     		ldr	r1, [r2, #0]
 188:subsystems/ins/ins_int.c **** #if USE_SONAR
 189:subsystems/ins/ins_int.c ****       ins_sonar_offset = sonar_meas;
 190:subsystems/ins/ins_int.c **** #endif
 191:subsystems/ins/ins_int.c ****       vff_realign(0.);
 810              		.loc 3 191 0
 811 0028 0020     		movs	r0, #0
 187:subsystems/ins/ins_int.c ****       ins_qfe = baro.absolute;
 812              		.loc 3 187 0
 813 002a 1960     		str	r1, [r3, #0]
 814              		.loc 3 191 0
 815 002c FFF7FEFF 		bl	vff_realign
 816              	.LVL84:
 192:subsystems/ins/ins_int.c ****       ins_ltp_accel.z = ACCEL_BFP_OF_REAL(vff_zdotdot);
 817              		.loc 3 192 0
 818 0030 204B     		ldr	r3, .L37+16
 819 0032 4FF08941 		mov	r1, #1149239296
 820 0036 1868     		ldr	r0, [r3, #0]	@ float
 821 0038 FFF7FEFF 		bl	__aeabi_fmul
 822              	.LVL85:
 823 003c FFF7FEFF 		bl	__aeabi_f2iz
 824              	.LVL86:
 825 0040 1D4A     		ldr	r2, .L37+20
 193:subsystems/ins/ins_int.c ****       ins_ltp_speed.z = SPEED_BFP_OF_REAL(vff_zdot);
 826              		.loc 3 193 0
 827 0042 4FF09241 		mov	r1, #1224736768
 192:subsystems/ins/ins_int.c ****       ins_ltp_accel.z = ACCEL_BFP_OF_REAL(vff_zdotdot);
 828              		.loc 3 192 0
 829 0046 9060     		str	r0, [r2, #8]
 830              		.loc 3 193 0
 831 0048 1C48     		ldr	r0, .L37+24
 832 004a 0068     		ldr	r0, [r0, #0]	@ float
 833 004c FFF7FEFF 		bl	__aeabi_fmul
 834              	.LVL87:
 835 0050 FFF7FEFF 		bl	__aeabi_f2iz
 836              	.LVL88:
 194:subsystems/ins/ins_int.c ****       ins_ltp_pos.z   = POS_BFP_OF_REAL(vff_z);
 837              		.loc 3 194 0
 838 0054 1A4B     		ldr	r3, .L37+28
 193:subsystems/ins/ins_int.c ****       ins_ltp_speed.z = SPEED_BFP_OF_REAL(vff_zdot);
 839              		.loc 3 193 0
 840 0056 1B49     		ldr	r1, .L37+32
 841 0058 8860     		str	r0, [r1, #8]
 842              		.loc 3 194 0
 843 005a 1868     		ldr	r0, [r3, #0]	@ float
 844 005c 4FF08741 		mov	r1, #1132462080
 845 0060 FFF7FEFF 		bl	__aeabi_fmul
 846              	.LVL89:
 847 0064 FFF7FEFF 		bl	__aeabi_f2iz
 848              	.LVL90:
 849 0068 174A     		ldr	r2, .L37+36
 850 006a 9060     		str	r0, [r2, #8]
 851 006c 11E0     		b	.L34
 852              	.L36:
 853              	.LBB6:
 195:subsystems/ins/ins_int.c ****     }
 196:subsystems/ins/ins_int.c ****     else { /* not realigning, so normal update with baro measurement */
 197:subsystems/ins/ins_int.c ****       ins_baro_alt = ((baro.absolute - ins_qfe) * INS_BARO_SENS_NUM)/INS_BARO_SENS_DEN;
 854              		.loc 3 197 0
 855 006e 1168     		ldr	r1, [r2, #0]
 856 0070 1868     		ldr	r0, [r3, #0]
 857 0072 DF23     		movs	r3, #223
 858 0074 0A1A     		subs	r2, r1, r0
 859 0076 5A43     		muls	r2, r3, r2
 860 0078 0A21     		movs	r1, #10
 861 007a 92FBF1F0 		sdiv	r0, r2, r1
 862 007e 134A     		ldr	r2, .L37+40
 863 0080 1060     		str	r0, [r2, #0]
 864              	.LVL91:
 198:subsystems/ins/ins_int.c ****       float alt_float = POS_FLOAT_OF_BFP(ins_baro_alt);
 865              		.loc 3 198 0
 866 0082 FFF7FEFF 		bl	__aeabi_i2f
 867              	.LVL92:
 868 0086 4FF06E51 		mov	r1, #998244352
 869 008a FFF7FEFF 		bl	__aeabi_fmul
 870              	.LVL93:
 199:subsystems/ins/ins_int.c ****       vff_update(alt_float);
 871              		.loc 3 199 0
 872 008e FFF7FEFF 		bl	vff_update
 873              	.LVL94:
 874              	.L34:
 875              	.LBE6:
 200:subsystems/ins/ins_int.c ****     }
 201:subsystems/ins/ins_int.c ****   }
 202:subsystems/ins/ins_int.c ****   INS_NED_TO_STATE();
 876              		.loc 3 202 0
 877 0092 FFF7FEFF 		bl	stateSetPositionNed_i.constprop.2
 878              	.LVL95:
 879 0096 FFF7FEFF 		bl	stateSetSpeedNed_i.constprop.1
 880              	.LVL96:
 203:subsystems/ins/ins_int.c **** #endif
 204:subsystems/ins/ins_int.c **** }
 881              		.loc 3 204 0
 882 009a BDE80840 		pop	{r3, lr}
 202:subsystems/ins/ins_int.c ****   INS_NED_TO_STATE();
 883              		.loc 3 202 0
 884 009e FFF7FEBF 		b	stateSetAccelNed_i.constprop.0
 885              	.LVL97:
 886              	.L38:
 887 00a2 00BF     		.align	2
 888              	.L37:
 889 00a4 00000000 		.word	baro
 890 00a8 00000000 		.word	.LANCHOR5
 891 00ac 00000000 		.word	.LANCHOR6
 892 00b0 00000000 		.word	ins
 893 00b4 00000000 		.word	vff_zdotdot
 894 00b8 00000000 		.word	.LANCHOR0
 895 00bc 00000000 		.word	vff_zdot
 896 00c0 00000000 		.word	vff_z
 897 00c4 00000000 		.word	.LANCHOR1
 898 00c8 00000000 		.word	.LANCHOR2
 899 00cc 00000000 		.word	.LANCHOR7
 900              		.cfi_endproc
 901              	.LFE128:
 903              		.section	.text.ins_update_gps,"ax",%progbits
 904              		.align	1
 905              		.global	ins_update_gps
 906              		.thumb
 907              		.thumb_func
 909              	ins_update_gps:
 910              	.LFB129:
 205:subsystems/ins/ins_int.c **** 
 206:subsystems/ins/ins_int.c **** 
 207:subsystems/ins/ins_int.c **** void ins_update_gps(void) {
 911              		.loc 3 207 0
 912              		.cfi_startproc
 913              		@ args = 0, pretend = 0, frame = 0
 914              		@ frame_needed = 0, uses_anonymous_args = 0
 915 0000 70B5     		push	{r4, r5, r6, lr}
 916              	.LCFI7:
 917              		.cfi_def_cfa_offset 16
 918              		.cfi_offset 4, -16
 919              		.cfi_offset 5, -12
 920              		.cfi_offset 6, -8
 921              		.cfi_offset 14, -4
 208:subsystems/ins/ins_int.c **** #if USE_GPS
 209:subsystems/ins/ins_int.c ****   if (gps.fix == GPS_FIX_3D) {
 922              		.loc 3 209 0
 923 0002 224C     		ldr	r4, .L42
 924 0004 94F85B30 		ldrb	r3, [r4, #91]	@ zero_extendqisi2
 925 0008 032B     		cmp	r3, #3
 926 000a 3ED1     		bne	.L39
 210:subsystems/ins/ins_int.c ****     if (!ins_ltp_initialised) {
 927              		.loc 3 210 0
 928 000c 204E     		ldr	r6, .L42+4
 929 000e 3078     		ldrb	r0, [r6, #0]	@ zero_extendqisi2
 930 0010 60B9     		cbnz	r0, .L41
 211:subsystems/ins/ins_int.c ****       ltp_def_from_ecef_i(&ins_ltp_def, &gps.ecef_pos);
 931              		.loc 3 211 0
 932 0012 204D     		ldr	r5, .L42+8
 933 0014 2146     		mov	r1, r4
 934 0016 2846     		mov	r0, r5
 935 0018 FFF7FEFF 		bl	ltp_def_from_ecef_i
 936              	.LVL98:
 212:subsystems/ins/ins_int.c ****       ins_ltp_def.lla.alt = gps.lla_pos.alt;
 937              		.loc 3 212 0
 938 001c 6169     		ldr	r1, [r4, #20]
 213:subsystems/ins/ins_int.c ****       ins_ltp_def.hmsl = gps.hmsl;
 939              		.loc 3 213 0
 940 001e A26A     		ldr	r2, [r4, #40]
 214:subsystems/ins/ins_int.c ****       ins_ltp_initialised = TRUE;
 941              		.loc 3 214 0
 942 0020 0124     		movs	r4, #1
 212:subsystems/ins/ins_int.c ****       ins_ltp_def.lla.alt = gps.lla_pos.alt;
 943              		.loc 3 212 0
 944 0022 6961     		str	r1, [r5, #20]
 213:subsystems/ins/ins_int.c ****       ins_ltp_def.hmsl = gps.hmsl;
 945              		.loc 3 213 0
 946 0024 EA63     		str	r2, [r5, #60]
 947              		.loc 3 214 0
 948 0026 3470     		strb	r4, [r6, #0]
 215:subsystems/ins/ins_int.c ****       stateSetLocalOrigin_i(&ins_ltp_def);
 949              		.loc 3 215 0
 950 0028 FFF7FEFF 		bl	stateSetLocalOrigin_i.constprop.3
 951              	.LVL99:
 952              	.L41:
 216:subsystems/ins/ins_int.c ****     }
 217:subsystems/ins/ins_int.c ****     ned_of_ecef_point_i(&ins_gps_pos_cm_ned, &ins_ltp_def, &gps.ecef_pos);
 953              		.loc 3 217 0
 954 002c 1A4D     		ldr	r5, .L42+12
 218:subsystems/ins/ins_int.c ****     ned_of_ecef_vect_i(&ins_gps_speed_cm_s_ned, &ins_ltp_def, &gps.ecef_vel);
 955              		.loc 3 218 0
 956 002e 1B4C     		ldr	r4, .L42+16
 217:subsystems/ins/ins_int.c ****     ned_of_ecef_point_i(&ins_gps_pos_cm_ned, &ins_ltp_def, &gps.ecef_pos);
 957              		.loc 3 217 0
 958 0030 2846     		mov	r0, r5
 959 0032 1849     		ldr	r1, .L42+8
 960 0034 154A     		ldr	r2, .L42
 961 0036 FFF7FEFF 		bl	ned_of_ecef_point_i
 962              	.LVL100:
 963              		.loc 3 218 0
 964 003a 2046     		mov	r0, r4
 965 003c 1549     		ldr	r1, .L42+8
 966 003e 184A     		ldr	r2, .L42+20
 967 0040 FFF7FEFF 		bl	ned_of_ecef_vect_i
 968              	.LVL101:
 219:subsystems/ins/ins_int.c **** #if USE_HFF
 220:subsystems/ins/ins_int.c ****     VECT2_ASSIGN(ins_gps_pos_m_ned, ins_gps_pos_cm_ned.x, ins_gps_pos_cm_ned.y);
 221:subsystems/ins/ins_int.c ****     VECT2_SDIV(ins_gps_pos_m_ned, ins_gps_pos_m_ned, 100.);
 222:subsystems/ins/ins_int.c ****     VECT2_ASSIGN(ins_gps_speed_m_s_ned, ins_gps_speed_cm_s_ned.x, ins_gps_speed_cm_s_ned.y);
 223:subsystems/ins/ins_int.c ****     VECT2_SDIV(ins_gps_speed_m_s_ned, ins_gps_speed_m_s_ned, 100.);
 224:subsystems/ins/ins_int.c ****     if (ins.hf_realign) {
 225:subsystems/ins/ins_int.c ****       ins.hf_realign = FALSE;
 226:subsystems/ins/ins_int.c **** #ifdef SITL
 227:subsystems/ins/ins_int.c ****       struct FloatVect2 true_pos, true_speed;
 228:subsystems/ins/ins_int.c ****       VECT2_COPY(true_pos, fdm.ltpprz_pos);
 229:subsystems/ins/ins_int.c ****       VECT2_COPY(true_speed, fdm.ltpprz_ecef_vel);
 230:subsystems/ins/ins_int.c ****       b2_hff_realign(true_pos, true_speed);
 231:subsystems/ins/ins_int.c **** #else
 232:subsystems/ins/ins_int.c ****       const struct FloatVect2 zero = {0.0, 0.0};
 233:subsystems/ins/ins_int.c ****       b2_hff_realign(ins_gps_pos_m_ned, zero);
 234:subsystems/ins/ins_int.c **** #endif
 235:subsystems/ins/ins_int.c ****     }
 236:subsystems/ins/ins_int.c ****     b2_hff_update_gps();
 237:subsystems/ins/ins_int.c **** #if !USE_VFF /* vff not used */
 238:subsystems/ins/ins_int.c ****     ins_ltp_pos.z =  (ins_gps_pos_cm_ned.z * INT32_POS_OF_CM_NUM) / INT32_POS_OF_CM_DEN;
 239:subsystems/ins/ins_int.c ****     ins_ltp_speed.z =  (ins_gps_speed_cm_s_ned.z * INT32_SPEED_OF_CM_S_NUM) INT32_SPEED_OF_CM_S_DEN
 240:subsystems/ins/ins_int.c **** #endif /* vff not used */
 241:subsystems/ins/ins_int.c **** #endif /* hff used */
 242:subsystems/ins/ins_int.c **** 
 243:subsystems/ins/ins_int.c **** 
 244:subsystems/ins/ins_int.c **** #if !USE_HFF /* hff not used */
 245:subsystems/ins/ins_int.c **** #if !USE_VFF /* neither hf nor vf used */
 246:subsystems/ins/ins_int.c ****     INT32_VECT3_SCALE_3(ins_ltp_pos, ins_gps_pos_cm_ned, INT32_POS_OF_CM_NUM, INT32_POS_OF_CM_DEN);
 247:subsystems/ins/ins_int.c ****     INT32_VECT3_SCALE_3(ins_ltp_speed, ins_gps_speed_cm_s_ned, INT32_SPEED_OF_CM_S_NUM, INT32_SPEED
 248:subsystems/ins/ins_int.c **** #else /* only vff used */
 249:subsystems/ins/ins_int.c ****     INT32_VECT2_SCALE_2(ins_ltp_pos, ins_gps_pos_cm_ned, INT32_POS_OF_CM_NUM, INT32_POS_OF_CM_DEN);
 969              		.loc 3 249 0
 970 0044 2868     		ldr	r0, [r5, #0]
 971 0046 1922     		movs	r2, #25
 972 0048 8101     		lsls	r1, r0, #6
 973 004a 91FBF2F0 		sdiv	r0, r1, r2
 974 004e 154B     		ldr	r3, .L42+24
 975 0050 6968     		ldr	r1, [r5, #4]
 976 0052 1860     		str	r0, [r3, #0]
 977 0054 8801     		lsls	r0, r1, #6
 978 0056 90FBF2F2 		sdiv	r2, r0, r2
 250:subsystems/ins/ins_int.c ****     INT32_VECT2_SCALE_2(ins_ltp_speed, ins_gps_speed_cm_s_ned, INT32_SPEED_OF_CM_S_NUM, INT32_SPEED
 979              		.loc 3 250 0
 980 005a 2068     		ldr	r0, [r4, #0]
 981 005c 4AF2D731 		movw	r1, #41943
 982 0060 01FB00F0 		mul	r0, r1, r0
 249:subsystems/ins/ins_int.c ****     INT32_VECT2_SCALE_2(ins_ltp_pos, ins_gps_pos_cm_ned, INT32_POS_OF_CM_NUM, INT32_POS_OF_CM_DEN);
 983              		.loc 3 249 0
 984 0064 5A60     		str	r2, [r3, #4]
 985              		.loc 3 250 0
 986 0066 104B     		ldr	r3, .L42+28
 987 0068 0822     		movs	r2, #8
 988 006a 90FBF2F0 		sdiv	r0, r0, r2
 989 006e 1860     		str	r0, [r3, #0]
 990 0070 6068     		ldr	r0, [r4, #4]
 991 0072 4143     		muls	r1, r0, r1
 992 0074 91FBF2F1 		sdiv	r1, r1, r2
 993 0078 5960     		str	r1, [r3, #4]
 251:subsystems/ins/ins_int.c **** #endif
 252:subsystems/ins/ins_int.c **** 
 253:subsystems/ins/ins_int.c **** #if USE_GPS_LAG_HACK
 254:subsystems/ins/ins_int.c ****     VECT2_COPY(d_pos, ins_ltp_speed);
 255:subsystems/ins/ins_int.c ****     INT32_VECT2_RSHIFT(d_pos, d_pos, 11);
 256:subsystems/ins/ins_int.c ****     VECT2_ADD(ins_ltp_pos, d_pos);
 257:subsystems/ins/ins_int.c **** #endif
 258:subsystems/ins/ins_int.c **** #endif /* hff not used */
 259:subsystems/ins/ins_int.c **** 
 260:subsystems/ins/ins_int.c ****     INS_NED_TO_STATE();
 994              		.loc 3 260 0
 995 007a FFF7FEFF 		bl	stateSetPositionNed_i.constprop.2
 996              	.LVL102:
 997 007e FFF7FEFF 		bl	stateSetSpeedNed_i.constprop.1
 998              	.LVL103:
 261:subsystems/ins/ins_int.c ****   }
 262:subsystems/ins/ins_int.c **** #endif /* USE_GPS */
 263:subsystems/ins/ins_int.c **** }
 999              		.loc 3 263 0
 1000 0082 BDE87040 		pop	{r4, r5, r6, lr}
 260:subsystems/ins/ins_int.c ****     INS_NED_TO_STATE();
 1001              		.loc 3 260 0
 1002 0086 FFF7FEBF 		b	stateSetAccelNed_i.constprop.0
 1003              	.LVL104:
 1004              	.L39:
 1005 008a 70BD     		pop	{r4, r5, r6, pc}
 1006              	.L43:
 1007              		.align	2
 1008              	.L42:
 1009 008c 00000000 		.word	gps
 1010 0090 00000000 		.word	.LANCHOR4
 1011 0094 00000000 		.word	.LANCHOR3
 1012 0098 00000000 		.word	.LANCHOR8
 1013 009c 00000000 		.word	.LANCHOR9
 1014 00a0 2C000000 		.word	gps+44
 1015 00a4 00000000 		.word	.LANCHOR2
 1016 00a8 00000000 		.word	.LANCHOR1
 1017              		.cfi_endproc
 1018              	.LFE129:
 1020              		.section	.text.ins_update_sonar,"ax",%progbits
 1021              		.align	1
 1022              		.global	ins_update_sonar
 1023              		.thumb
 1024              		.thumb_func
 1026              	ins_update_sonar:
 1027              	.LFB130:
 264:subsystems/ins/ins_int.c **** 
 265:subsystems/ins/ins_int.c **** void ins_update_sonar() {
 1028              		.loc 3 265 0
 1029              		.cfi_startproc
 1030              		@ args = 0, pretend = 0, frame = 0
 1031              		@ frame_needed = 0, uses_anonymous_args = 0
 1032              		@ link register save eliminated.
 1033 0000 7047     		bx	lr
 1034              		.cfi_endproc
 1035              	.LFE130:
 1037              		.global	ins_ltp_accel
 1038              		.global	ins_ltp_speed
 1039              		.global	ins_ltp_pos
 1040              		.global	ins_baro_alt
 1041              		.global	ins_baro_initialised
 1042              		.global	ins_qfe
 1043              		.global	ins_gps_speed_cm_s_ned
 1044              		.global	ins_gps_pos_cm_ned
 1045              		.global	ins_ltp_initialised
 1046              		.global	ins_ltp_def
 1047              		.section	.bss.ins_baro_initialised,"aw",%nobits
 1048              		.set	.LANCHOR5,. + 0
 1051              	ins_baro_initialised:
 1052 0000 00       		.space	1
 1053              		.section	.bss.ins_ltp_pos,"aw",%nobits
 1054              		.align	2
 1055              		.set	.LANCHOR2,. + 0
 1058              	ins_ltp_pos:
 1059 0000 00000000 		.space	12
 1059      00000000 
 1059      00000000 
 1060              		.section	.bss.ins_ltp_accel,"aw",%nobits
 1061              		.align	2
 1062              		.set	.LANCHOR0,. + 0
 1065              	ins_ltp_accel:
 1066 0000 00000000 		.space	12
 1066      00000000 
 1066      00000000 
 1067              		.section	.bss.ins_baro_alt,"aw",%nobits
 1068              		.align	2
 1069              		.set	.LANCHOR7,. + 0
 1072              	ins_baro_alt:
 1073 0000 00000000 		.space	4
 1074              		.section	.bss.ins_ltp_def,"aw",%nobits
 1075              		.align	2
 1076              		.set	.LANCHOR3,. + 0
 1079              	ins_ltp_def:
 1080 0000 00000000 		.space	64
 1080      00000000 
 1080      00000000 
 1080      00000000 
 1080      00000000 
 1081              		.section	.bss.ins_gps_pos_cm_ned,"aw",%nobits
 1082              		.align	2
 1083              		.set	.LANCHOR8,. + 0
 1086              	ins_gps_pos_cm_ned:
 1087 0000 00000000 		.space	12
 1087      00000000 
 1087      00000000 
 1088              		.section	.bss.ins_qfe,"aw",%nobits
 1089              		.align	2
 1090              		.set	.LANCHOR6,. + 0
 1093              	ins_qfe:
 1094 0000 00000000 		.space	4
 1095              		.section	.bss.ins_gps_speed_cm_s_ned,"aw",%nobits
 1096              		.align	2
 1097              		.set	.LANCHOR9,. + 0
 1100              	ins_gps_speed_cm_s_ned:
 1101 0000 00000000 		.space	12
 1101      00000000 
 1101      00000000 
 1102              		.section	.bss.ins_ltp_speed,"aw",%nobits
 1103              		.align	2
 1104              		.set	.LANCHOR1,. + 0
 1107              	ins_ltp_speed:
 1108 0000 00000000 		.space	12
 1108      00000000 
 1108      00000000 
 1109              		.section	.bss.ins_ltp_initialised,"aw",%nobits
 1110              		.set	.LANCHOR4,. + 0
 1113              	ins_ltp_initialised:
 1114 0000 00       		.space	1
 1115              		.text
 1116              	.Letext0:
 1117              		.file 4 "/opt/local/bin/../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include/stdint.h"
 1118              		.file 5 "/Users/tony-yi/git/paparazzi_local/sw/include/std.h"
 1119              		.file 6 "./math/pprz_algebra_int.h"
 1120              		.file 7 "./math/pprz_geodetic_int.h"
 1121              		.file 8 "./math/pprz_algebra_float.h"
 1122              		.file 9 "./math/pprz_geodetic_float.h"
 1123              		.file 10 "./subsystems/ins.h"
 1124              		.file 11 "./subsystems/imu.h"
 1125              		.file 12 "./mcu_periph/spi.h"
 1126              		.file 13 "./peripherals/mpu60x0_regs.h"
 1127              		.file 14 "./peripherals/mpu60x0.h"
 1128              		.file 15 "./peripherals/mpu60x0_spi.h"
 1129              		.file 16 "./subsystems/imu/imu_aspirin_2_spi.h"
 1130              		.file 17 "./subsystems/sensors/baro.h"
 1131              		.file 18 "./mcu_periph/sys_time.h"
 1132              		.file 19 "./subsystems/gps.h"
 1133              		.file 20 "./subsystems/ins/vf_float.h"
 1134              		.file 21 "firmwares/rotorcraft/autopilot.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 ins_int.c
/var/tmp//cce9osTz.s:19     .text.stateSetAccelNed_i.constprop.0:0000000000000000 $t
/var/tmp//cce9osTz.s:23     .text.stateSetAccelNed_i.constprop.0:0000000000000000 stateSetAccelNed_i.constprop.0
/var/tmp//cce9osTz.s:50     .text.stateSetAccelNed_i.constprop.0:0000000000000020 $d
/var/tmp//cce9osTz.s:56     .text.stateSetSpeedNed_i.constprop.1:0000000000000000 $t
/var/tmp//cce9osTz.s:60     .text.stateSetSpeedNed_i.constprop.1:0000000000000000 stateSetSpeedNed_i.constprop.1
/var/tmp//cce9osTz.s:86     .text.stateSetSpeedNed_i.constprop.1:0000000000000020 $d
/var/tmp//cce9osTz.s:92     .text.stateSetPositionNed_i.constprop.2:0000000000000000 $t
/var/tmp//cce9osTz.s:96     .text.stateSetPositionNed_i.constprop.2:0000000000000000 stateSetPositionNed_i.constprop.2
/var/tmp//cce9osTz.s:122    .text.stateSetPositionNed_i.constprop.2:0000000000000018 $d
/var/tmp//cce9osTz.s:133    .text.stateSetLocalOrigin_i.constprop.3:0000000000000000 $t
/var/tmp//cce9osTz.s:137    .text.stateSetLocalOrigin_i.constprop.3:0000000000000000 stateSetLocalOrigin_i.constprop.3
/var/tmp//cce9osTz.s:328    .text.stateSetLocalOrigin_i.constprop.3:0000000000000190 $d
/var/tmp//cce9osTz.s:338    .text.stateGetNedToBodyRMat_i:0000000000000000 $t
/var/tmp//cce9osTz.s:342    .text.stateGetNedToBodyRMat_i:0000000000000000 stateGetNedToBodyRMat_i
/var/tmp//cce9osTz.s:375    .text.stateGetNedToBodyRMat_i:0000000000000018 $d
/var/tmp//cce9osTz.s:381    .text.ins_init:0000000000000000 $t
/var/tmp//cce9osTz.s:386    .text.ins_init:0000000000000000 ins_init
/var/tmp//cce9osTz.s:478    .text.ins_init:0000000000000064 $d
/var/tmp//cce9osTz.s:491    .text.ins_periodic:0000000000000000 $t
/var/tmp//cce9osTz.s:496    .text.ins_periodic:0000000000000000 ins_periodic
/var/tmp//cce9osTz.s:508    .text.ins_realign_h:0000000000000000 $t
/var/tmp//cce9osTz.s:513    .text.ins_realign_h:0000000000000000 ins_realign_h
/var/tmp//cce9osTz.s:539    .text.ins_realign_v:0000000000000000 $t
/var/tmp//cce9osTz.s:544    .text.ins_realign_v:0000000000000000 ins_realign_v
/var/tmp//cce9osTz.s:563    .text.ins_propagate:0000000000000000 $t
/var/tmp//cce9osTz.s:568    .text.ins_propagate:0000000000000000 ins_propagate
/var/tmp//cce9osTz.s:749    .text.ins_propagate:0000000000000140 $d
/var/tmp//cce9osTz.s:764    .text.ins_update_baro:0000000000000000 $t
/var/tmp//cce9osTz.s:769    .text.ins_update_baro:0000000000000000 ins_update_baro
/var/tmp//cce9osTz.s:889    .text.ins_update_baro:00000000000000a4 $d
/var/tmp//cce9osTz.s:904    .text.ins_update_gps:0000000000000000 $t
/var/tmp//cce9osTz.s:909    .text.ins_update_gps:0000000000000000 ins_update_gps
/var/tmp//cce9osTz.s:1009   .text.ins_update_gps:000000000000008c $d
/var/tmp//cce9osTz.s:1021   .text.ins_update_sonar:0000000000000000 $t
/var/tmp//cce9osTz.s:1026   .text.ins_update_sonar:0000000000000000 ins_update_sonar
/var/tmp//cce9osTz.s:1065   .bss.ins_ltp_accel:0000000000000000 ins_ltp_accel
/var/tmp//cce9osTz.s:1107   .bss.ins_ltp_speed:0000000000000000 ins_ltp_speed
/var/tmp//cce9osTz.s:1058   .bss.ins_ltp_pos:0000000000000000 ins_ltp_pos
/var/tmp//cce9osTz.s:1072   .bss.ins_baro_alt:0000000000000000 ins_baro_alt
/var/tmp//cce9osTz.s:1051   .bss.ins_baro_initialised:0000000000000000 ins_baro_initialised
/var/tmp//cce9osTz.s:1093   .bss.ins_qfe:0000000000000000 ins_qfe
/var/tmp//cce9osTz.s:1100   .bss.ins_gps_speed_cm_s_ned:0000000000000000 ins_gps_speed_cm_s_ned
/var/tmp//cce9osTz.s:1086   .bss.ins_gps_pos_cm_ned:0000000000000000 ins_gps_pos_cm_ned
/var/tmp//cce9osTz.s:1113   .bss.ins_ltp_initialised:0000000000000000 ins_ltp_initialised
/var/tmp//cce9osTz.s:1079   .bss.ins_ltp_def:0000000000000000 ins_ltp_def
/var/tmp//cce9osTz.s:1052   .bss.ins_baro_initialised:0000000000000000 $d
/var/tmp//cce9osTz.s:1054   .bss.ins_ltp_pos:0000000000000000 $d
/var/tmp//cce9osTz.s:1061   .bss.ins_ltp_accel:0000000000000000 $d
/var/tmp//cce9osTz.s:1068   .bss.ins_baro_alt:0000000000000000 $d
/var/tmp//cce9osTz.s:1075   .bss.ins_ltp_def:0000000000000000 $d
/var/tmp//cce9osTz.s:1082   .bss.ins_gps_pos_cm_ned:0000000000000000 $d
/var/tmp//cce9osTz.s:1089   .bss.ins_qfe:0000000000000000 $d
/var/tmp//cce9osTz.s:1096   .bss.ins_gps_speed_cm_s_ned:0000000000000000 $d
/var/tmp//cce9osTz.s:1103   .bss.ins_ltp_speed:0000000000000000 $d
/var/tmp//cce9osTz.s:1114   .bss.ins_ltp_initialised:0000000000000000 $d
                     .debug_frame:0000000000000010 $d
/var/tmp//cce9osTz.s:763    .text.ins_propagate:000000000000016c $t

UNDEFINED SYMBOLS
state
__aeabi_i2d
__aeabi_ddiv
__aeabi_d2f
__aeabi_i2f
__aeabi_fmul
orientationCalcRMat_i
ecef_of_lla_i
ltp_def_from_ecef_i
vff_init
ins
vff_realign
__aeabi_f2iz
__aeabi_dadd
__aeabi_d2iz
vff_propagate
imu
baro
vff_zdotdot
vff_zdot
vff_z
vff_update
ned_of_ecef_point_i
ned_of_ecef_vect_i
gps
