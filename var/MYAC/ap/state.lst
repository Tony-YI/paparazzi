   1              		.syntax unified
   2              		.cpu cortex-m3
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 4
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.thumb
  14              		.file	"state.c"
  15              		.text
  16              	.Ltext0:
  17              		.cfi_sections	.debug_frame
  18              		.section	.text.stateInit,"ax",%progbits
  19              		.align	1
  20              		.global	stateInit
  21              		.thumb
  22              		.thumb_func
  24              	stateInit:
  25              	.LFB100:
  26              		.file 1 "state.c"
   1:state.c       **** /*
   2:state.c       ****  * Copyright (C) 2011-2012 Felix Ruess <felix.ruess@gmail.com>
   3:state.c       ****  *
   4:state.c       ****  * This file is part of paparazzi.
   5:state.c       ****  *
   6:state.c       ****  * paparazzi is free software; you can redistribute it and/or modify
   7:state.c       ****  * it under the terms of the GNU General Public License as published by
   8:state.c       ****  * the Free Software Foundation; either version 2, or (at your option)
   9:state.c       ****  * any later version.
  10:state.c       ****  *
  11:state.c       ****  * paparazzi is distributed in the hope that it will be useful,
  12:state.c       ****  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  13:state.c       ****  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  14:state.c       ****  * GNU General Public License for more details.
  15:state.c       ****  *
  16:state.c       ****  * You should have received a copy of the GNU General Public License
  17:state.c       ****  * along with paparazzi; see the file COPYING.  If not, see
  18:state.c       ****  * <http://www.gnu.org/licenses/>.
  19:state.c       ****  */
  20:state.c       **** 
  21:state.c       **** /**
  22:state.c       ****  * @file state.c
  23:state.c       ****  *
  24:state.c       ****  * General interface for the main vehicle states.
  25:state.c       ****  *
  26:state.c       ****  * This file contains the functions to automatically convert between
  27:state.c       ****  * the different representations. They should normally not be used
  28:state.c       ****  * directly and instead the stateGet/Set interfaces used.
  29:state.c       ****  * Also see the @ref state_interface "State Interface" page.
  30:state.c       ****  *
  31:state.c       ****  * @author Felix Ruess <felix.ruess@gmail.com>
  32:state.c       ****  */
  33:state.c       **** 
  34:state.c       **** #include "state.h"
  35:state.c       **** 
  36:state.c       **** struct State state;
  37:state.c       **** 
  38:state.c       **** /**
  39:state.c       ****  * @addtogroup state_interface
  40:state.c       ****  * @{
  41:state.c       ****  */
  42:state.c       **** 
  43:state.c       **** void stateInit(void) {
  27              		.loc 1 43 0
  28              		.cfi_startproc
  29              		@ args = 0, pretend = 0, frame = 0
  30              		@ frame_needed = 0, uses_anonymous_args = 0
  31              		@ link register save eliminated.
  44:state.c       ****   state.pos_status = 0;
  32              		.loc 1 44 0
  33 0000 094B     		ldr	r3, .L2
  34 0002 0021     		movs	r1, #0
  35 0004 1980     		strh	r1, [r3, #0]	@ movhi
  45:state.c       ****   state.speed_status = 0;
  36              		.loc 1 45 0
  37 0006 A3F81411 		strh	r1, [r3, #276]	@ movhi
  46:state.c       ****   state.accel_status = 0;
  38              		.loc 1 46 0
  39 000a 83F87011 		strb	r1, [r3, #368]
  47:state.c       ****   state.ned_to_body_orientation.status = 0;
  40              		.loc 1 47 0
  41 000e 83F8A411 		strb	r1, [r3, #420]
  48:state.c       ****   state.rate_status = 0;
  42              		.loc 1 48 0
  43 0012 83F82812 		strb	r1, [r3, #552]
  49:state.c       ****   state.wind_air_status = 0;
  44              		.loc 1 49 0
  45 0016 83F84412 		strb	r1, [r3, #580]
  50:state.c       ****   state.ned_initialized_i = FALSE;
  46              		.loc 1 50 0
  47 001a 83F85C10 		strb	r1, [r3, #92]
  51:state.c       ****   state.ned_initialized_f = FALSE;
  48              		.loc 1 51 0
  49 001e 83F8E410 		strb	r1, [r3, #228]
  52:state.c       ****   state.utm_initialized_f = FALSE;
  50              		.loc 1 52 0
  51 0022 83F8F810 		strb	r1, [r3, #248]
  52 0026 7047     		bx	lr
  53              	.L3:
  54              		.align	2
  55              	.L2:
  56 0028 00000000 		.word	.LANCHOR0
  57              		.cfi_endproc
  58              	.LFE100:
  60              		.global	__aeabi_f2d
  61              		.global	__aeabi_dmul
  62              		.global	__aeabi_d2iz
  63              		.section	.text.stateCalcPositionEcef_i,"ax",%progbits
  64              		.align	1
  65              		.global	stateCalcPositionEcef_i
  66              		.thumb
  67              		.thumb_func
  69              	stateCalcPositionEcef_i:
  70              	.LFB101:
  53:state.c       **** }
  54:state.c       **** 
  55:state.c       **** 
  56:state.c       **** /*******************************************************************************
  57:state.c       ****  *                                                                             *
  58:state.c       ****  * transformation functions for the POSITION representations                   *
  59:state.c       ****  *                                                                             *
  60:state.c       ****  ******************************************************************************/
  61:state.c       **** /** @addtogroup state_position
  62:state.c       ****  *  @{ */
  63:state.c       **** 
  64:state.c       **** void stateCalcPositionEcef_i(void) {
  71              		.loc 1 64 0
  72              		.cfi_startproc
  73              		@ args = 0, pretend = 0, frame = 0
  74              		@ frame_needed = 0, uses_anonymous_args = 0
  75 0000 10B5     		push	{r4, lr}
  76              	.LCFI0:
  77              		.cfi_def_cfa_offset 8
  78              		.cfi_offset 4, -8
  79              		.cfi_offset 14, -4
  65:state.c       ****   if (bit_is_set(state.pos_status, POS_ECEF_I))
  80              		.loc 1 65 0
  81 0002 2B4C     		ldr	r4, .L17
  82 0004 2388     		ldrh	r3, [r4, #0]
  83 0006 D907     		lsls	r1, r3, #31
  84 0008 50D4     		bmi	.L4
  66:state.c       ****     return;
  67:state.c       **** 
  68:state.c       ****   if (bit_is_set(state.pos_status, POS_ECEF_F)) {
  85              		.loc 1 68 0
  86 000a 9A06     		lsls	r2, r3, #26
  87 000c 17D4     		bmi	.L14
  88              	.L6:
  69:state.c       ****     ECEF_BFP_OF_REAL(state.ecef_pos_i, state.ecef_pos_f);
  70:state.c       ****   }
  71:state.c       ****   else if (bit_is_set(state.pos_status, POS_NED_I)) {
  89              		.loc 1 71 0
  90 000e 9807     		lsls	r0, r3, #30
  91 0010 07D5     		bpl	.L8
  72:state.c       ****     ecef_of_ned_pos_i(&state.ecef_pos_i, &state.ned_origin_i, &state.ned_pos_i);
  92              		.loc 1 72 0
  93 0012 201D     		adds	r0, r4, #4
  94 0014 04F11C01 		add	r1, r4, #28
  95 0018 04F16002 		add	r2, r4, #96
  96 001c FFF7FEFF 		bl	ecef_of_ned_pos_i
  97              	.LVL0:
  98 0020 3FE0     		b	.L7
  99              	.L8:
  73:state.c       ****   }
  74:state.c       ****   else if (bit_is_set(state.pos_status, POS_NED_F)) {
 100              		.loc 1 74 0
 101 0022 5906     		lsls	r1, r3, #25
 102 0024 2DD5     		bpl	.L9
  75:state.c       ****     /* transform ned_f to ecef_f, set status bit, then convert to int */
  76:state.c       ****     ecef_of_ned_point_f(&state.ecef_pos_f, &state.ned_origin_f, &state.ned_pos_f);
 103              		.loc 1 76 0
 104 0026 04F19800 		add	r0, r4, #152
 105 002a 04F1A401 		add	r1, r4, #164
 106 002e 04F1FC02 		add	r2, r4, #252
 107 0032 FFF7FEFF 		bl	ecef_of_ned_point_f
 108              	.LVL1:
 109              	.L15:
  77:state.c       ****     SetBit(state.pos_status, POS_ECEF_F);
 110              		.loc 1 77 0
 111 0036 2088     		ldrh	r0, [r4, #0]
 112 0038 40F02001 		orr	r1, r0, #32
 113 003c 2180     		strh	r1, [r4, #0]	@ movhi
 114              	.L14:
  78:state.c       ****     ECEF_BFP_OF_REAL(state.ecef_pos_i, state.ecef_pos_f);
 115              		.loc 1 78 0
 116 003e D4F89800 		ldr	r0, [r4, #152]	@ float
 117 0042 FFF7FEFF 		bl	__aeabi_f2d
 118              	.LVL2:
 119 0046 0022     		movs	r2, #0
 120 0048 1A4B     		ldr	r3, .L17+4
 121 004a FFF7FEFF 		bl	__aeabi_dmul
 122              	.LVL3:
 123 004e FFF7FEFF 		bl	__aeabi_d2iz
 124              	.LVL4:
 125 0052 6060     		str	r0, [r4, #4]
 126 0054 D4F89C00 		ldr	r0, [r4, #156]	@ float
 127 0058 FFF7FEFF 		bl	__aeabi_f2d
 128              	.LVL5:
 129 005c 0022     		movs	r2, #0
 130 005e 154B     		ldr	r3, .L17+4
 131 0060 FFF7FEFF 		bl	__aeabi_dmul
 132              	.LVL6:
 133 0064 FFF7FEFF 		bl	__aeabi_d2iz
 134              	.LVL7:
 135 0068 A060     		str	r0, [r4, #8]
 136 006a D4F8A000 		ldr	r0, [r4, #160]	@ float
 137 006e FFF7FEFF 		bl	__aeabi_f2d
 138              	.LVL8:
 139 0072 0022     		movs	r2, #0
 140 0074 0F4B     		ldr	r3, .L17+4
 141 0076 FFF7FEFF 		bl	__aeabi_dmul
 142              	.LVL9:
 143 007a FFF7FEFF 		bl	__aeabi_d2iz
 144              	.LVL10:
 145 007e E060     		str	r0, [r4, #12]
 146 0080 0FE0     		b	.L7
 147              	.L9:
  79:state.c       ****   }
  80:state.c       ****   else if (bit_is_set(state.pos_status, POS_LLA_F)) {
 148              		.loc 1 80 0
 149 0082 DA05     		lsls	r2, r3, #23
 150 0084 06D5     		bpl	.L10
  81:state.c       ****     /* transform lla_f to ecef_f, set status bit, then convert to int */
  82:state.c       ****     ecef_of_lla_f(&state.ecef_pos_f, &state.lla_pos_f);
 151              		.loc 1 82 0
 152 0086 04F19800 		add	r0, r4, #152
 153 008a 04F18C01 		add	r1, r4, #140
 154 008e FFF7FEFF 		bl	ecef_of_lla_f
 155              	.LVL11:
 156 0092 D0E7     		b	.L15
 157              	.L10:
  83:state.c       ****     SetBit(state.pos_status, POS_ECEF_F);
  84:state.c       ****     ECEF_BFP_OF_REAL(state.ecef_pos_i, state.ecef_pos_f);
  85:state.c       ****   }
  86:state.c       ****   else if (bit_is_set(state.pos_status, POS_LLA_I)) {
 158              		.loc 1 86 0
 159 0094 1B07     		lsls	r3, r3, #28
 160 0096 04D5     		bpl	.L7
  87:state.c       ****     ecef_of_lla_i(&state.ecef_pos_i, &state.lla_pos_i);
 161              		.loc 1 87 0
 162 0098 201D     		adds	r0, r4, #4
 163 009a 04F11001 		add	r1, r4, #16
 164 009e FFF7FEFF 		bl	ecef_of_lla_i
 165              	.LVL12:
 166              	.L7:
  88:state.c       ****   }
  89:state.c       ****   else {
  90:state.c       ****     /* could not get this representation,  set errno */
  91:state.c       ****     //struct EcefCoor_i _ecef_zero = {0};
  92:state.c       ****     //return _ecef_zero;
  93:state.c       ****   }
  94:state.c       ****   /* set bit to indicate this representation is computed */
  95:state.c       ****   SetBit(state.pos_status, POS_ECEF_I);
 167              		.loc 1 95 0
 168 00a2 034B     		ldr	r3, .L17
 169 00a4 1A88     		ldrh	r2, [r3, #0]
 170 00a6 42F00100 		orr	r0, r2, #1
 171 00aa 1880     		strh	r0, [r3, #0]	@ movhi
 172              	.L4:
 173 00ac 10BD     		pop	{r4, pc}
 174              	.L18:
 175 00ae 00BF     		.align	2
 176              	.L17:
 177 00b0 00000000 		.word	.LANCHOR0
 178 00b4 00005940 		.word	1079574528
 179              		.cfi_endproc
 180              	.LFE101:
 182              		.global	__aeabi_fmul
 183              		.global	__aeabi_f2iz
 184              		.global	__aeabi_fsub
 185              		.global	__aeabi_i2d
 186              		.global	__aeabi_ddiv
 187              		.global	__aeabi_d2f
 188              		.section	.text.stateCalcPositionNed_i,"ax",%progbits
 189              		.align	1
 190              		.global	stateCalcPositionNed_i
 191              		.thumb
 192              		.thumb_func
 194              	stateCalcPositionNed_i:
 195              	.LFB102:
  96:state.c       **** }
  97:state.c       **** 
  98:state.c       **** void stateCalcPositionNed_i(void) {
 196              		.loc 1 98 0
 197              		.cfi_startproc
 198              		@ args = 0, pretend = 0, frame = 0
 199              		@ frame_needed = 0, uses_anonymous_args = 0
 200 0000 2DE9F041 		push	{r4, r5, r6, r7, r8, lr}
 201              	.LCFI1:
 202              		.cfi_def_cfa_offset 24
 203              		.cfi_offset 4, -24
 204              		.cfi_offset 5, -20
 205              		.cfi_offset 6, -16
 206              		.cfi_offset 7, -12
 207              		.cfi_offset 8, -8
 208              		.cfi_offset 14, -4
  99:state.c       ****   if (bit_is_set(state.pos_status, POS_NED_I))
 209              		.loc 1 99 0
 210 0004 9A4C     		ldr	r4, .L50+8
 211 0006 2588     		ldrh	r5, [r4, #0]
 212 0008 AB07     		lsls	r3, r5, #30
 213 000a 00F12981 		bmi	.L19
 214              	.LVL13:
 100:state.c       ****     return;
 101:state.c       **** 
 102:state.c       ****   int errno = 0;
 103:state.c       ****   if (state.ned_initialized_i) {
 215              		.loc 1 103 0
 216 000e 94F85C30 		ldrb	r3, [r4, #92]	@ zero_extendqisi2
 217 0012 002B     		cmp	r3, #0
 218 0014 39D0     		beq	.L21
 104:state.c       ****     if (bit_is_set(state.pos_status, POS_NED_F)) {
 219              		.loc 1 104 0
 220 0016 6806     		lsls	r0, r5, #25
 221 0018 3ED4     		bmi	.L47
 222              	.L22:
 105:state.c       ****       NED_BFP_OF_REAL(state.ned_pos_i, state.ned_pos_f);
 106:state.c       ****     }
 107:state.c       ****     else if (bit_is_set(state.pos_status, POS_ENU_I)) {
 223              		.loc 1 107 0
 224 001a 6907     		lsls	r1, r5, #29
 225 001c 53D4     		bmi	.L46
 226              	.L24:
 108:state.c       ****       INT32_VECT3_NED_OF_ENU(state.ned_pos_i, state.enu_pos_i);
 109:state.c       ****     }
 110:state.c       ****     else if (bit_is_set(state.pos_status, POS_ENU_F)) {
 227              		.loc 1 110 0
 228 001e 2A06     		lsls	r2, r5, #24
 229 0020 5BD4     		bmi	.L48
 230              	.L25:
 111:state.c       ****       ENU_BFP_OF_REAL(state.enu_pos_i, state.enu_pos_f);
 112:state.c       ****       SetBit(state.pos_status, POS_ENU_I);
 113:state.c       ****       INT32_VECT3_NED_OF_ENU(state.ned_pos_i, state.enu_pos_i);
 114:state.c       ****     }
 115:state.c       ****     else if (bit_is_set(state.pos_status, POS_ECEF_I)) {
 231              		.loc 1 115 0
 232 0022 EB07     		lsls	r3, r5, #31
 233 0024 07D5     		bpl	.L26
 116:state.c       ****       ned_of_ecef_pos_i(&state.ned_pos_i, &state.ned_origin_i, &state.ecef_pos_i);
 234              		.loc 1 116 0
 235 0026 04F16000 		add	r0, r4, #96
 236 002a 04F11C01 		add	r1, r4, #28
 237 002e 221D     		adds	r2, r4, #4
 238 0030 FFF7FEFF 		bl	ned_of_ecef_pos_i
 239              	.LVL14:
 240 0034 0FE1     		b	.L23
 241              	.L26:
 117:state.c       ****     }
 118:state.c       ****     else if (bit_is_set(state.pos_status, POS_ECEF_F)) {
 242              		.loc 1 118 0
 243 0036 A806     		lsls	r0, r5, #26
 244 0038 02D5     		bpl	.L27
 119:state.c       ****       /* transform ecef_f -> ned_f, set status bit, then convert to int */
 120:state.c       ****       ned_of_ecef_point_f(&state.ned_pos_f, &state.ned_origin_f, &state.ecef_pos_f);
 245              		.loc 1 120 0
 246 003a 04F1FC00 		add	r0, r4, #252
 247 003e 0DE0     		b	.L49
 248              	.L27:
 121:state.c       ****       SetBit(state.pos_status, POS_NED_F);
 122:state.c       ****       NED_BFP_OF_REAL(state.ned_pos_i, state.ned_pos_f);
 123:state.c       ****     }
 124:state.c       ****     else if (bit_is_set(state.pos_status, POS_LLA_F)) {
 249              		.loc 1 124 0
 250 0040 E905     		lsls	r1, r5, #23
 251 0042 16D5     		bpl	.L28
 125:state.c       ****       /* transform lla_f -> ecef_f -> ned_f, set status bits, then convert to int */
 126:state.c       ****       ecef_of_lla_f(&state.ecef_pos_f, &state.lla_pos_f);
 252              		.loc 1 126 0
 253 0044 04F19800 		add	r0, r4, #152
 254 0048 04F18C01 		add	r1, r4, #140
 255 004c FFF7FEFF 		bl	ecef_of_lla_f
 256              	.LVL15:
 127:state.c       ****       SetBit(state.pos_status, POS_ECEF_F);
 257              		.loc 1 127 0
 258 0050 2188     		ldrh	r1, [r4, #0]
 259 0052 2046     		mov	r0, r4
 260 0054 41F02002 		orr	r2, r1, #32
 261 0058 20F8FC2B 		strh	r2, [r0], #252	@ movhi
 262              	.L49:
 128:state.c       ****       ned_of_ecef_point_f(&state.ned_pos_f, &state.ned_origin_f, &state.ecef_pos_f);
 263              		.loc 1 128 0
 264 005c 04F1A401 		add	r1, r4, #164
 265 0060 04F19802 		add	r2, r4, #152
 266 0064 FFF7FEFF 		bl	ned_of_ecef_point_f
 267              	.LVL16:
 129:state.c       ****       SetBit(state.pos_status, POS_NED_F);
 268              		.loc 1 129 0
 269 0068 2388     		ldrh	r3, [r4, #0]
 270 006a 43F04000 		orr	r0, r3, #64
 271 006e 2080     		strh	r0, [r4, #0]	@ movhi
 272 0070 12E0     		b	.L47
 273              	.L28:
 130:state.c       ****       NED_BFP_OF_REAL(state.ned_pos_i, state.ned_pos_f);
 131:state.c       ****     }
 132:state.c       ****     else if (bit_is_set(state.pos_status, POS_LLA_I)) {
 274              		.loc 1 132 0
 275 0072 2A07     		lsls	r2, r5, #28
 276 0074 40F1EF80 		bpl	.L23
 133:state.c       ****       ned_of_lla_point_i(&state.ned_pos_i, &state.ned_origin_i, &state.lla_pos_i);
 277              		.loc 1 133 0
 278 0078 04F16000 		add	r0, r4, #96
 279 007c 04F11C01 		add	r1, r4, #28
 280 0080 04F11002 		add	r2, r4, #16
 281 0084 FFF7FEFF 		bl	ned_of_lla_point_i
 282              	.LVL17:
 283 0088 E5E0     		b	.L23
 284              	.L21:
 134:state.c       ****     }
 135:state.c       ****     else { /* could not get this representation,  set errno */
 136:state.c       ****       errno = 1;
 137:state.c       ****     }
 138:state.c       ****   }
 139:state.c       ****   else if (state.utm_initialized_f) {
 285              		.loc 1 139 0
 286 008a 94F8F800 		ldrb	r0, [r4, #248]	@ zero_extendqisi2
 287 008e 0028     		cmp	r0, #0
 288 0090 00F0E180 		beq	.L23
 140:state.c       ****     if (bit_is_set(state.pos_status, POS_NED_F)) {
 289              		.loc 1 140 0
 290 0094 6B06     		lsls	r3, r5, #25
 291 0096 14D5     		bpl	.L29
 292              	.L47:
 141:state.c       ****       NED_BFP_OF_REAL(state.ned_pos_i, state.ned_pos_f);
 293              		.loc 1 141 0
 294 0098 4FF08741 		mov	r1, #1132462080
 295 009c D4F8FC00 		ldr	r0, [r4, #252]	@ float
 296 00a0 FFF7FEFF 		bl	__aeabi_fmul
 297              	.LVL18:
 298 00a4 FFF7FEFF 		bl	__aeabi_f2iz
 299              	.LVL19:
 300 00a8 4FF08741 		mov	r1, #1132462080
 301 00ac 2066     		str	r0, [r4, #96]
 302 00ae D4F80001 		ldr	r0, [r4, #256]	@ float
 303 00b2 FFF7FEFF 		bl	__aeabi_fmul
 304              	.LVL20:
 305 00b6 FFF7FEFF 		bl	__aeabi_f2iz
 306              	.LVL21:
 307 00ba 6066     		str	r0, [r4, #100]
 308 00bc D4F80401 		ldr	r0, [r4, #260]	@ float
 309 00c0 C2E0     		b	.L43
 310              	.L29:
 142:state.c       ****     }
 143:state.c       ****     else if (bit_is_set(state.pos_status, POS_ENU_I)) {
 311              		.loc 1 143 0
 312 00c2 6807     		lsls	r0, r5, #29
 313 00c4 07D5     		bpl	.L30
 314              	.L46:
 144:state.c       ****       INT32_VECT3_NED_OF_ENU(state.ned_pos_i, state.enu_pos_i);
 315              		.loc 1 144 0
 316 00c6 636F     		ldr	r3, [r4, #116]
 317 00c8 216F     		ldr	r1, [r4, #112]
 318 00ca E26E     		ldr	r2, [r4, #108]
 319 00cc 5842     		negs	r0, r3
 320 00ce 2166     		str	r1, [r4, #96]
 321 00d0 6266     		str	r2, [r4, #100]
 322 00d2 A066     		str	r0, [r4, #104]
 323 00d4 BFE0     		b	.L23
 324              	.L30:
 145:state.c       ****     }
 146:state.c       ****     else if (bit_is_set(state.pos_status, POS_ENU_F)) {
 325              		.loc 1 146 0
 326 00d6 2906     		lsls	r1, r5, #24
 327 00d8 23D5     		bpl	.L31
 328              	.L48:
 147:state.c       ****       ENU_BFP_OF_REAL(state.enu_pos_i, state.enu_pos_f);
 329              		.loc 1 147 0
 330 00da 4FF08741 		mov	r1, #1132462080
 331 00de D4F80801 		ldr	r0, [r4, #264]	@ float
 332 00e2 FFF7FEFF 		bl	__aeabi_fmul
 333              	.LVL22:
 334 00e6 FFF7FEFF 		bl	__aeabi_f2iz
 335              	.LVL23:
 336 00ea 4FF08741 		mov	r1, #1132462080
 337 00ee 0646     		mov	r6, r0
 338 00f0 E066     		str	r0, [r4, #108]
 339 00f2 D4F80C01 		ldr	r0, [r4, #268]	@ float
 340 00f6 FFF7FEFF 		bl	__aeabi_fmul
 341              	.LVL24:
 342 00fa FFF7FEFF 		bl	__aeabi_f2iz
 343              	.LVL25:
 344 00fe 4FF08741 		mov	r1, #1132462080
 345 0102 0746     		mov	r7, r0
 346 0104 2067     		str	r0, [r4, #112]
 347 0106 D4F81001 		ldr	r0, [r4, #272]	@ float
 348 010a FFF7FEFF 		bl	__aeabi_fmul
 349              	.LVL26:
 350 010e FFF7FEFF 		bl	__aeabi_f2iz
 351              	.LVL27:
 148:state.c       ****       SetBit(state.pos_status, POS_ENU_I);
 352              		.loc 1 148 0
 353 0112 45F00405 		orr	r5, r5, #4
 147:state.c       ****       ENU_BFP_OF_REAL(state.enu_pos_i, state.enu_pos_f);
 354              		.loc 1 147 0
 355 0116 6067     		str	r0, [r4, #116]
 356              		.loc 1 148 0
 357 0118 2580     		strh	r5, [r4, #0]	@ movhi
 149:state.c       ****       INT32_VECT3_NED_OF_ENU(state.ned_pos_i, state.enu_pos_i);
 358              		.loc 1 149 0
 359 011a 2766     		str	r7, [r4, #96]
 360 011c 6666     		str	r6, [r4, #100]
 361 011e 4042     		negs	r0, r0
 362 0120 98E0     		b	.L45
 363              	.L31:
 150:state.c       ****     }
 151:state.c       ****     else if (bit_is_set(state.pos_status, POS_UTM_F)) {
 364              		.loc 1 151 0
 365 0122 AA05     		lsls	r2, r5, #22
 366 0124 2DD5     		bpl	.L32
 152:state.c       ****       /* transform utm_f -> ned_f -> ned_i, set status bits */
 153:state.c       ****       NED_OF_UTM_DIFF(state.ned_pos_f, state.utm_pos_f, state.utm_origin_f);
 367              		.loc 1 153 0
 368 0126 D4F8E810 		ldr	r1, [r4, #232]	@ float
 369 012a A06F     		ldr	r0, [r4, #120]	@ float
 370 012c FFF7FEFF 		bl	__aeabi_fsub
 371              	.LVL28:
 372 0130 D4F8EC10 		ldr	r1, [r4, #236]	@ float
 373 0134 8046     		mov	r8, r0
 374 0136 C4F8FC00 		str	r0, [r4, #252]	@ float
 375 013a E06F     		ldr	r0, [r4, #124]	@ float
 376 013c FFF7FEFF 		bl	__aeabi_fsub
 377              	.LVL29:
 378 0140 D4F88010 		ldr	r1, [r4, #128]	@ float
 379 0144 0746     		mov	r7, r0
 380 0146 C4F80001 		str	r0, [r4, #256]	@ float
 381 014a D4F8F000 		ldr	r0, [r4, #240]	@ float
 382 014e FFF7FEFF 		bl	__aeabi_fsub
 383              	.LVL30:
 154:state.c       ****       SetBit(state.pos_status, POS_NED_F);
 384              		.loc 1 154 0
 385 0152 45F04005 		orr	r5, r5, #64
 155:state.c       ****       NED_BFP_OF_REAL(state.ned_pos_i, state.ned_pos_f);
 386              		.loc 1 155 0
 387 0156 4FF08741 		mov	r1, #1132462080
 153:state.c       ****       NED_OF_UTM_DIFF(state.ned_pos_f, state.utm_pos_f, state.utm_origin_f);
 388              		.loc 1 153 0
 389 015a 0646     		mov	r6, r0
 390 015c C4F80401 		str	r0, [r4, #260]	@ float
 391              		.loc 1 155 0
 392 0160 4046     		mov	r0, r8
 154:state.c       ****       SetBit(state.pos_status, POS_NED_F);
 393              		.loc 1 154 0
 394 0162 2580     		strh	r5, [r4, #0]	@ movhi
 395              		.loc 1 155 0
 396 0164 FFF7FEFF 		bl	__aeabi_fmul
 397              	.LVL31:
 398 0168 FFF7FEFF 		bl	__aeabi_f2iz
 399              	.LVL32:
 400 016c 4FF08741 		mov	r1, #1132462080
 401 0170 2066     		str	r0, [r4, #96]
 402 0172 3846     		mov	r0, r7
 403 0174 FFF7FEFF 		bl	__aeabi_fmul
 404              	.LVL33:
 405 0178 FFF7FEFF 		bl	__aeabi_f2iz
 406              	.LVL34:
 407 017c 6066     		str	r0, [r4, #100]
 408 017e 3046     		mov	r0, r6
 409 0180 62E0     		b	.L43
 410              	.L32:
 156:state.c       ****     }
 157:state.c       ****     else if (bit_is_set(state.pos_status, POS_LLA_F)) {
 411              		.loc 1 157 0
 412 0182 EB05     		lsls	r3, r5, #23
 413 0184 02D5     		bpl	.L33
 158:state.c       ****       /* transform lla_f -> utm_f -> ned_f -> ned_i, set status bits */
 159:state.c       ****       utm_of_lla_f(&state.utm_pos_f, &state.lla_pos_f);
 414              		.loc 1 159 0
 415 0186 04F17800 		add	r0, r4, #120
 416 018a 29E0     		b	.L44
 417              	.L33:
 160:state.c       ****       SetBit(state.pos_status, POS_UTM_F);
 161:state.c       ****       NED_OF_UTM_DIFF(state.ned_pos_f, state.utm_pos_f, state.utm_origin_f);
 162:state.c       ****       SetBit(state.pos_status, POS_NED_F);
 163:state.c       ****       NED_BFP_OF_REAL(state.ned_pos_i, state.ned_pos_f);
 164:state.c       ****     }
 165:state.c       ****     else if (bit_is_set(state.pos_status, POS_LLA_I)) {
 418              		.loc 1 165 0
 419 018c 2807     		lsls	r0, r5, #28
 420 018e 62D5     		bpl	.L23
 166:state.c       ****       /* transform lla_i -> lla_f -> utm_f -> ned_f -> ned_i, set status bits */
 167:state.c       ****       LLA_FLOAT_OF_BFP(state.lla_pos_f, state.lla_pos_i);
 421              		.loc 1 167 0
 422 0190 6069     		ldr	r0, [r4, #20]
 423 0192 FFF7FEFF 		bl	__aeabi_i2d
 424              	.LVL35:
 425 0196 34A3     		adr	r3, .L50
 426 0198 D3E90023 		ldrd	r2, [r3]
 427 019c FFF7FEFF 		bl	__aeabi_ddiv
 428              	.LVL36:
 429 01a0 FFF7FEFF 		bl	__aeabi_d2f
 430              	.LVL37:
 431 01a4 C4F89000 		str	r0, [r4, #144]	@ float
 432 01a8 2069     		ldr	r0, [r4, #16]
 433 01aa FFF7FEFF 		bl	__aeabi_i2d
 434              	.LVL38:
 435 01ae 2EA3     		adr	r3, .L50
 436 01b0 D3E90023 		ldrd	r2, [r3]
 437 01b4 FFF7FEFF 		bl	__aeabi_ddiv
 438              	.LVL39:
 439 01b8 FFF7FEFF 		bl	__aeabi_d2f
 440              	.LVL40:
 441 01bc C4F88C00 		str	r0, [r4, #140]	@ float
 442 01c0 A069     		ldr	r0, [r4, #24]
 443 01c2 FFF7FEFF 		bl	__aeabi_i2d
 444              	.LVL41:
 445 01c6 0022     		movs	r2, #0
 446 01c8 2A4B     		ldr	r3, .L50+12
 447 01ca FFF7FEFF 		bl	__aeabi_ddiv
 448              	.LVL42:
 449 01ce FFF7FEFF 		bl	__aeabi_d2f
 450              	.LVL43:
 168:state.c       ****       SetBit(state.pos_status, POS_LLA_F);
 451              		.loc 1 168 0
 452 01d2 45F48075 		orr	r5, r5, #256
 167:state.c       ****       LLA_FLOAT_OF_BFP(state.lla_pos_f, state.lla_pos_i);
 453              		.loc 1 167 0
 454 01d6 C4F89400 		str	r0, [r4, #148]	@ float
 455              		.loc 1 168 0
 456 01da 2046     		mov	r0, r4
 457 01dc 20F8785B 		strh	r5, [r0], #120	@ movhi
 458              	.L44:
 169:state.c       ****       utm_of_lla_f(&state.utm_pos_f, &state.lla_pos_f);
 459              		.loc 1 169 0
 460 01e0 04F18C01 		add	r1, r4, #140
 461 01e4 FFF7FEFF 		bl	utm_of_lla_f
 462              	.LVL44:
 170:state.c       ****       SetBit(state.pos_status, POS_UTM_F);
 171:state.c       ****       NED_OF_UTM_DIFF(state.ned_pos_f, state.utm_pos_f, state.utm_origin_f);
 463              		.loc 1 171 0
 464 01e8 D4F8E810 		ldr	r1, [r4, #232]	@ float
 465 01ec A06F     		ldr	r0, [r4, #120]	@ float
 466 01ee FFF7FEFF 		bl	__aeabi_fsub
 467              	.LVL45:
 468 01f2 D4F8EC10 		ldr	r1, [r4, #236]	@ float
 469 01f6 0746     		mov	r7, r0
 470 01f8 C4F8FC00 		str	r0, [r4, #252]	@ float
 471 01fc E06F     		ldr	r0, [r4, #124]	@ float
 472 01fe FFF7FEFF 		bl	__aeabi_fsub
 473              	.LVL46:
 474 0202 D4F88010 		ldr	r1, [r4, #128]	@ float
 475 0206 0646     		mov	r6, r0
 476 0208 C4F80001 		str	r0, [r4, #256]	@ float
 477 020c D4F8F000 		ldr	r0, [r4, #240]	@ float
 478 0210 FFF7FEFF 		bl	__aeabi_fsub
 479              	.LVL47:
 170:state.c       ****       SetBit(state.pos_status, POS_UTM_F);
 480              		.loc 1 170 0
 481 0214 B4F80080 		ldrh	r8, [r4, #0]
 172:state.c       ****       SetBit(state.pos_status, POS_NED_F);
 173:state.c       ****       NED_BFP_OF_REAL(state.ned_pos_i, state.ned_pos_f);
 482              		.loc 1 173 0
 483 0218 4FF08741 		mov	r1, #1132462080
 171:state.c       ****       NED_OF_UTM_DIFF(state.ned_pos_f, state.utm_pos_f, state.utm_origin_f);
 484              		.loc 1 171 0
 485 021c 0546     		mov	r5, r0
 486 021e C4F80401 		str	r0, [r4, #260]	@ float
 172:state.c       ****       SetBit(state.pos_status, POS_NED_F);
 487              		.loc 1 172 0
 488 0222 48F41078 		orr	r8, r8, #576
 489              		.loc 1 173 0
 490 0226 3846     		mov	r0, r7
 172:state.c       ****       SetBit(state.pos_status, POS_NED_F);
 491              		.loc 1 172 0
 492 0228 A4F80080 		strh	r8, [r4, #0]	@ movhi
 493              		.loc 1 173 0
 494 022c FFF7FEFF 		bl	__aeabi_fmul
 495              	.LVL48:
 496 0230 FFF7FEFF 		bl	__aeabi_f2iz
 497              	.LVL49:
 498 0234 4FF08741 		mov	r1, #1132462080
 499 0238 2066     		str	r0, [r4, #96]
 500 023a 3046     		mov	r0, r6
 501 023c FFF7FEFF 		bl	__aeabi_fmul
 502              	.LVL50:
 503 0240 FFF7FEFF 		bl	__aeabi_f2iz
 504              	.LVL51:
 505 0244 6066     		str	r0, [r4, #100]
 506 0246 2846     		mov	r0, r5
 507              	.L43:
 508 0248 4FF08741 		mov	r1, #1132462080
 509 024c FFF7FEFF 		bl	__aeabi_fmul
 510              	.LVL52:
 511 0250 FFF7FEFF 		bl	__aeabi_f2iz
 512              	.LVL53:
 513              	.L45:
 514 0254 A066     		str	r0, [r4, #104]
 515              	.L23:
 174:state.c       ****     }
 175:state.c       ****     else { /* could not get this representation,  set errno */
 176:state.c       ****       errno = 2;
 177:state.c       ****     }
 178:state.c       ****   }
 179:state.c       ****   else { /* ned coordinate system not initialized,  set errno */
 180:state.c       ****     errno = 3;
 181:state.c       ****   }
 182:state.c       ****   if (errno) {
 183:state.c       ****     //struct NedCoor_i _ned_zero = {0};
 184:state.c       ****     //return _ned_zero;
 185:state.c       ****   }
 186:state.c       ****   /* set bit to indicate this representation is computed */
 187:state.c       ****   SetBit(state.pos_status, POS_NED_I);
 516              		.loc 1 187 0
 517 0256 0649     		ldr	r1, .L50+8
 518 0258 0A88     		ldrh	r2, [r1, #0]
 519 025a 42F00203 		orr	r3, r2, #2
 520 025e 0B80     		strh	r3, [r1, #0]	@ movhi
 521              	.LVL54:
 522              	.L19:
 523 0260 BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 524              	.L51:
 525 0264 AFF30080 		.align	3
 526              	.L50:
 527 0268 00000000 		.word	0
 528 026c D0126341 		.word	1097011920
 529 0270 00000000 		.word	.LANCHOR0
 530 0274 00408F40 		.word	1083129856
 531              		.cfi_endproc
 532              	.LFE102:
 534              		.section	.text.stateCalcPositionEnu_i,"ax",%progbits
 535              		.align	1
 536              		.global	stateCalcPositionEnu_i
 537              		.thumb
 538              		.thumb_func
 540              	stateCalcPositionEnu_i:
 541              	.LFB103:
 188:state.c       **** }
 189:state.c       **** 
 190:state.c       **** void stateCalcPositionEnu_i(void) {
 542              		.loc 1 190 0
 543              		.cfi_startproc
 544              		@ args = 0, pretend = 0, frame = 0
 545              		@ frame_needed = 0, uses_anonymous_args = 0
 546 0000 2DE9F041 		push	{r4, r5, r6, r7, r8, lr}
 547              	.LCFI2:
 548              		.cfi_def_cfa_offset 24
 549              		.cfi_offset 4, -24
 550              		.cfi_offset 5, -20
 551              		.cfi_offset 6, -16
 552              		.cfi_offset 7, -12
 553              		.cfi_offset 8, -8
 554              		.cfi_offset 14, -4
 191:state.c       ****   if (bit_is_set(state.pos_status, POS_ENU_I))
 555              		.loc 1 191 0
 556 0004 984C     		ldr	r4, .L83+8
 557 0006 2588     		ldrh	r5, [r4, #0]
 558 0008 6907     		lsls	r1, r5, #29
 559 000a 00F12681 		bmi	.L52
 560              	.LVL55:
 192:state.c       ****     return;
 193:state.c       **** 
 194:state.c       ****   int errno = 0;
 195:state.c       ****   if (state.ned_initialized_i) {
 561              		.loc 1 195 0
 562 000e 94F85C30 		ldrb	r3, [r4, #92]	@ zero_extendqisi2
 563 0012 002B     		cmp	r3, #0
 564 0014 36D0     		beq	.L54
 196:state.c       ****     if (bit_is_set(state.pos_status, POS_NED_I)) {
 565              		.loc 1 196 0
 566 0016 AA07     		lsls	r2, r5, #30
 567 0018 52D4     		bmi	.L78
 568              	.L55:
 197:state.c       ****       INT32_VECT3_ENU_OF_NED(state.enu_pos_i, state.ned_pos_i);
 198:state.c       ****     }
 199:state.c       ****     else if (bit_is_set(state.pos_status, POS_ENU_F)) {
 569              		.loc 1 199 0
 570 001a 2B06     		lsls	r3, r5, #24
 571 001c 39D4     		bmi	.L80
 572              	.L57:
 200:state.c       ****       ENU_BFP_OF_REAL(state.enu_pos_i, state.enu_pos_f);
 201:state.c       ****     }
 202:state.c       ****     else if (bit_is_set(state.pos_status, POS_NED_F)) {
 573              		.loc 1 202 0
 574 001e 6806     		lsls	r0, r5, #25
 575 0020 58D4     		bmi	.L81
 576              	.L58:
 203:state.c       ****       NED_BFP_OF_REAL(state.ned_pos_i, state.ned_pos_f);
 204:state.c       ****       SetBit(state.pos_status, POS_NED_I);
 205:state.c       ****       INT32_VECT3_ENU_OF_NED(state.enu_pos_i, state.ned_pos_i);
 206:state.c       ****     }
 207:state.c       ****     else if (bit_is_set(state.pos_status, POS_ECEF_I)) {
 577              		.loc 1 207 0
 578 0022 E907     		lsls	r1, r5, #31
 579 0024 07D5     		bpl	.L59
 208:state.c       ****       enu_of_ecef_pos_i(&state.enu_pos_i, &state.ned_origin_i, &state.ecef_pos_i);
 580              		.loc 1 208 0
 581 0026 04F16C00 		add	r0, r4, #108
 582 002a 04F11C01 		add	r1, r4, #28
 583 002e 221D     		adds	r2, r4, #4
 584 0030 FFF7FEFF 		bl	enu_of_ecef_pos_i
 585              	.LVL56:
 586 0034 0CE1     		b	.L56
 587              	.L59:
 209:state.c       ****     }
 210:state.c       ****     else if (bit_is_set(state.pos_status, POS_ECEF_F)) {
 588              		.loc 1 210 0
 589 0036 AA06     		lsls	r2, r5, #26
 590 0038 0BD4     		bmi	.L82
 591              	.L60:
 211:state.c       ****       /* transform ecef_f -> enu_f, set status bit, then convert to int */
 212:state.c       ****       enu_of_ecef_point_f(&state.enu_pos_f, &state.ned_origin_f, &state.ecef_pos_f);
 213:state.c       ****       SetBit(state.pos_status, POS_ENU_F);
 214:state.c       ****       ENU_BFP_OF_REAL(state.enu_pos_i, state.enu_pos_f);
 215:state.c       ****     }
 216:state.c       ****     else if (bit_is_set(state.pos_status, POS_LLA_F)) {
 592              		.loc 1 216 0
 593 003a EB05     		lsls	r3, r5, #23
 594 003c 16D5     		bpl	.L61
 217:state.c       ****       /* transform lla_f -> ecef_f -> enu_f, set status bits, then convert to int */
 218:state.c       ****       ecef_of_lla_f(&state.ecef_pos_f, &state.lla_pos_f);
 595              		.loc 1 218 0
 596 003e 04F18C01 		add	r1, r4, #140
 597 0042 04F19800 		add	r0, r4, #152
 598 0046 FFF7FEFF 		bl	ecef_of_lla_f
 599              	.LVL57:
 219:state.c       ****       SetBit(state.pos_status, POS_ECEF_F);
 600              		.loc 1 219 0
 601 004a 2188     		ldrh	r1, [r4, #0]
 602 004c 41F02002 		orr	r2, r1, #32
 603 0050 2280     		strh	r2, [r4, #0]	@ movhi
 604              	.L82:
 220:state.c       ****       enu_of_ecef_point_f(&state.enu_pos_f, &state.ned_origin_f, &state.ecef_pos_f);
 605              		.loc 1 220 0
 606 0052 04F58470 		add	r0, r4, #264
 607 0056 04F1A401 		add	r1, r4, #164
 608 005a 04F19802 		add	r2, r4, #152
 609 005e FFF7FEFF 		bl	enu_of_ecef_point_f
 610              	.LVL58:
 221:state.c       ****       SetBit(state.pos_status, POS_ENU_F);
 611              		.loc 1 221 0
 612 0062 2388     		ldrh	r3, [r4, #0]
 613 0064 43F08000 		orr	r0, r3, #128
 614 0068 2080     		strh	r0, [r4, #0]	@ movhi
 615 006a 12E0     		b	.L80
 616              	.L61:
 222:state.c       ****       ENU_BFP_OF_REAL(state.enu_pos_i, state.enu_pos_f);
 223:state.c       ****     }
 224:state.c       ****     else if (bit_is_set(state.pos_status, POS_LLA_I)) {
 617              		.loc 1 224 0
 618 006c 2807     		lsls	r0, r5, #28
 619 006e 40F1EF80 		bpl	.L56
 225:state.c       ****       enu_of_lla_point_i(&state.enu_pos_i, &state.ned_origin_i, &state.lla_pos_i);
 620              		.loc 1 225 0
 621 0072 04F16C00 		add	r0, r4, #108
 622 0076 04F11C01 		add	r1, r4, #28
 623 007a 04F11002 		add	r2, r4, #16
 624 007e FFF7FEFF 		bl	enu_of_lla_point_i
 625              	.LVL59:
 626 0082 E5E0     		b	.L56
 627              	.L54:
 226:state.c       ****     }
 227:state.c       ****     else { /* could not get this representation,  set errno */
 228:state.c       ****       errno = 1;
 229:state.c       ****     }
 230:state.c       ****   }
 231:state.c       ****   else if (state.utm_initialized_f) {
 628              		.loc 1 231 0
 629 0084 94F8F800 		ldrb	r0, [r4, #248]	@ zero_extendqisi2
 630 0088 0028     		cmp	r0, #0
 631 008a 00F0E180 		beq	.L56
 232:state.c       ****     if (bit_is_set(state.pos_status, POS_ENU_F)) {
 632              		.loc 1 232 0
 633 008e 2906     		lsls	r1, r5, #24
 634 0090 14D5     		bpl	.L62
 635              	.L80:
 233:state.c       ****       ENU_BFP_OF_REAL(state.enu_pos_i, state.enu_pos_f);
 636              		.loc 1 233 0
 637 0092 4FF08741 		mov	r1, #1132462080
 638 0096 D4F80801 		ldr	r0, [r4, #264]	@ float
 639 009a FFF7FEFF 		bl	__aeabi_fmul
 640              	.LVL60:
 641 009e FFF7FEFF 		bl	__aeabi_f2iz
 642              	.LVL61:
 643 00a2 4FF08741 		mov	r1, #1132462080
 644 00a6 E066     		str	r0, [r4, #108]
 645 00a8 D4F80C01 		ldr	r0, [r4, #268]	@ float
 646 00ac FFF7FEFF 		bl	__aeabi_fmul
 647              	.LVL62:
 648 00b0 FFF7FEFF 		bl	__aeabi_f2iz
 649              	.LVL63:
 650 00b4 2067     		str	r0, [r4, #112]
 651 00b6 D4F81001 		ldr	r0, [r4, #272]	@ float
 652 00ba C2E0     		b	.L76
 653              	.L62:
 234:state.c       ****     }
 235:state.c       ****     else if (bit_is_set(state.pos_status, POS_NED_I)) {
 654              		.loc 1 235 0
 655 00bc AA07     		lsls	r2, r5, #30
 656 00be 07D5     		bpl	.L63
 657              	.L78:
 236:state.c       ****       INT32_VECT3_ENU_OF_NED(state.enu_pos_i, state.ned_pos_i);
 658              		.loc 1 236 0
 659 00c0 A36E     		ldr	r3, [r4, #104]
 660 00c2 616E     		ldr	r1, [r4, #100]
 661 00c4 226E     		ldr	r2, [r4, #96]
 662 00c6 5842     		negs	r0, r3
 663 00c8 E166     		str	r1, [r4, #108]
 664 00ca 2267     		str	r2, [r4, #112]
 665 00cc 6067     		str	r0, [r4, #116]
 666 00ce BFE0     		b	.L56
 667              	.L63:
 237:state.c       ****     }
 238:state.c       ****     else if (bit_is_set(state.pos_status, POS_NED_F)) {
 668              		.loc 1 238 0
 669 00d0 6B06     		lsls	r3, r5, #25
 670 00d2 23D5     		bpl	.L64
 671              	.L81:
 239:state.c       ****       NED_BFP_OF_REAL(state.ned_pos_i, state.ned_pos_f);
 672              		.loc 1 239 0
 673 00d4 4FF08741 		mov	r1, #1132462080
 674 00d8 D4F8FC00 		ldr	r0, [r4, #252]	@ float
 675 00dc FFF7FEFF 		bl	__aeabi_fmul
 676              	.LVL64:
 677 00e0 FFF7FEFF 		bl	__aeabi_f2iz
 678              	.LVL65:
 679 00e4 4FF08741 		mov	r1, #1132462080
 680 00e8 0646     		mov	r6, r0
 681 00ea 2066     		str	r0, [r4, #96]
 682 00ec D4F80001 		ldr	r0, [r4, #256]	@ float
 683 00f0 FFF7FEFF 		bl	__aeabi_fmul
 684              	.LVL66:
 685 00f4 FFF7FEFF 		bl	__aeabi_f2iz
 686              	.LVL67:
 687 00f8 4FF08741 		mov	r1, #1132462080
 688 00fc 0746     		mov	r7, r0
 689 00fe 6066     		str	r0, [r4, #100]
 690 0100 D4F80401 		ldr	r0, [r4, #260]	@ float
 691 0104 FFF7FEFF 		bl	__aeabi_fmul
 692              	.LVL68:
 693 0108 FFF7FEFF 		bl	__aeabi_f2iz
 694              	.LVL69:
 240:state.c       ****       SetBit(state.pos_status, POS_NED_I);
 695              		.loc 1 240 0
 696 010c 45F00205 		orr	r5, r5, #2
 239:state.c       ****       NED_BFP_OF_REAL(state.ned_pos_i, state.ned_pos_f);
 697              		.loc 1 239 0
 698 0110 A066     		str	r0, [r4, #104]
 699              		.loc 1 240 0
 700 0112 2580     		strh	r5, [r4, #0]	@ movhi
 241:state.c       ****       INT32_VECT3_ENU_OF_NED(state.enu_pos_i, state.ned_pos_i);
 701              		.loc 1 241 0
 702 0114 E766     		str	r7, [r4, #108]
 703 0116 2667     		str	r6, [r4, #112]
 704 0118 4042     		negs	r0, r0
 705 011a 98E0     		b	.L79
 706              	.L64:
 242:state.c       ****     }
 243:state.c       ****     else if (bit_is_set(state.pos_status, POS_UTM_F)) {
 707              		.loc 1 243 0
 708 011c A805     		lsls	r0, r5, #22
 709 011e 2DD5     		bpl	.L65
 244:state.c       ****       /* transform utm_f -> enu_f -> enu_i , set status bits */
 245:state.c       ****       ENU_OF_UTM_DIFF(state.enu_pos_f, state.utm_pos_f, state.utm_origin_f);
 710              		.loc 1 245 0
 711 0120 D4F8EC10 		ldr	r1, [r4, #236]	@ float
 712 0124 E06F     		ldr	r0, [r4, #124]	@ float
 713 0126 FFF7FEFF 		bl	__aeabi_fsub
 714              	.LVL70:
 715 012a D4F8E810 		ldr	r1, [r4, #232]	@ float
 716 012e 8046     		mov	r8, r0
 717 0130 C4F80801 		str	r0, [r4, #264]	@ float
 718 0134 A06F     		ldr	r0, [r4, #120]	@ float
 719 0136 FFF7FEFF 		bl	__aeabi_fsub
 720              	.LVL71:
 721 013a D4F8F010 		ldr	r1, [r4, #240]	@ float
 722 013e 0746     		mov	r7, r0
 723 0140 C4F80C01 		str	r0, [r4, #268]	@ float
 724 0144 D4F88000 		ldr	r0, [r4, #128]	@ float
 725 0148 FFF7FEFF 		bl	__aeabi_fsub
 726              	.LVL72:
 246:state.c       ****       SetBit(state.pos_status, POS_ENU_F);
 727              		.loc 1 246 0
 728 014c 45F08005 		orr	r5, r5, #128
 247:state.c       ****       ENU_BFP_OF_REAL(state.enu_pos_i, state.enu_pos_f);
 729              		.loc 1 247 0
 730 0150 4FF08741 		mov	r1, #1132462080
 245:state.c       ****       ENU_OF_UTM_DIFF(state.enu_pos_f, state.utm_pos_f, state.utm_origin_f);
 731              		.loc 1 245 0
 732 0154 0646     		mov	r6, r0
 733 0156 C4F81001 		str	r0, [r4, #272]	@ float
 734              		.loc 1 247 0
 735 015a 4046     		mov	r0, r8
 246:state.c       ****       SetBit(state.pos_status, POS_ENU_F);
 736              		.loc 1 246 0
 737 015c 2580     		strh	r5, [r4, #0]	@ movhi
 738              		.loc 1 247 0
 739 015e FFF7FEFF 		bl	__aeabi_fmul
 740              	.LVL73:
 741 0162 FFF7FEFF 		bl	__aeabi_f2iz
 742              	.LVL74:
 743 0166 4FF08741 		mov	r1, #1132462080
 744 016a E066     		str	r0, [r4, #108]
 745 016c 3846     		mov	r0, r7
 746 016e FFF7FEFF 		bl	__aeabi_fmul
 747              	.LVL75:
 748 0172 FFF7FEFF 		bl	__aeabi_f2iz
 749              	.LVL76:
 750 0176 2067     		str	r0, [r4, #112]
 751 0178 3046     		mov	r0, r6
 752 017a 62E0     		b	.L76
 753              	.L65:
 248:state.c       ****     }
 249:state.c       ****     else if (bit_is_set(state.pos_status, POS_LLA_F)) {
 754              		.loc 1 249 0
 755 017c E905     		lsls	r1, r5, #23
 756 017e 02D5     		bpl	.L66
 250:state.c       ****       /* transform lla_f -> utm_f -> enu_f -> enu_i , set status bits */
 251:state.c       ****       utm_of_lla_f(&state.utm_pos_f, &state.lla_pos_f);
 757              		.loc 1 251 0
 758 0180 04F17800 		add	r0, r4, #120
 759 0184 29E0     		b	.L77
 760              	.L66:
 252:state.c       ****       SetBit(state.pos_status, POS_UTM_F);
 253:state.c       ****       ENU_OF_UTM_DIFF(state.enu_pos_f, state.utm_pos_f, state.utm_origin_f);
 254:state.c       ****       SetBit(state.pos_status, POS_ENU_F);
 255:state.c       ****       ENU_BFP_OF_REAL(state.enu_pos_i, state.enu_pos_f);
 256:state.c       ****     }
 257:state.c       ****     else if (bit_is_set(state.pos_status, POS_LLA_I)) {
 761              		.loc 1 257 0
 762 0186 2A07     		lsls	r2, r5, #28
 763 0188 62D5     		bpl	.L56
 258:state.c       ****       /* transform lla_i -> lla_f -> utm_f -> enu_f -> enu_i , set status bits */
 259:state.c       ****       LLA_FLOAT_OF_BFP(state.lla_pos_f, state.lla_pos_i);
 764              		.loc 1 259 0
 765 018a 6069     		ldr	r0, [r4, #20]
 766 018c FFF7FEFF 		bl	__aeabi_i2d
 767              	.LVL77:
 768 0190 33A3     		adr	r3, .L83
 769 0192 D3E90023 		ldrd	r2, [r3]
 770 0196 FFF7FEFF 		bl	__aeabi_ddiv
 771              	.LVL78:
 772 019a FFF7FEFF 		bl	__aeabi_d2f
 773              	.LVL79:
 774 019e C4F89000 		str	r0, [r4, #144]	@ float
 775 01a2 2069     		ldr	r0, [r4, #16]
 776 01a4 FFF7FEFF 		bl	__aeabi_i2d
 777              	.LVL80:
 778 01a8 2DA3     		adr	r3, .L83
 779 01aa D3E90023 		ldrd	r2, [r3]
 780 01ae FFF7FEFF 		bl	__aeabi_ddiv
 781              	.LVL81:
 782 01b2 FFF7FEFF 		bl	__aeabi_d2f
 783              	.LVL82:
 784 01b6 C4F88C00 		str	r0, [r4, #140]	@ float
 785 01ba A069     		ldr	r0, [r4, #24]
 786 01bc FFF7FEFF 		bl	__aeabi_i2d
 787              	.LVL83:
 788 01c0 0022     		movs	r2, #0
 789 01c2 2A4B     		ldr	r3, .L83+12
 790 01c4 FFF7FEFF 		bl	__aeabi_ddiv
 791              	.LVL84:
 792 01c8 FFF7FEFF 		bl	__aeabi_d2f
 793              	.LVL85:
 260:state.c       ****       SetBit(state.pos_status, POS_LLA_F);
 794              		.loc 1 260 0
 795 01cc 45F48075 		orr	r5, r5, #256
 259:state.c       ****       LLA_FLOAT_OF_BFP(state.lla_pos_f, state.lla_pos_i);
 796              		.loc 1 259 0
 797 01d0 C4F89400 		str	r0, [r4, #148]	@ float
 798              		.loc 1 260 0
 799 01d4 2046     		mov	r0, r4
 800 01d6 20F8785B 		strh	r5, [r0], #120	@ movhi
 801              	.L77:
 261:state.c       ****       utm_of_lla_f(&state.utm_pos_f, &state.lla_pos_f);
 802              		.loc 1 261 0
 803 01da 04F18C01 		add	r1, r4, #140
 804 01de FFF7FEFF 		bl	utm_of_lla_f
 805              	.LVL86:
 262:state.c       ****       SetBit(state.pos_status, POS_UTM_F);
 263:state.c       ****       ENU_OF_UTM_DIFF(state.enu_pos_f, state.utm_pos_f, state.utm_origin_f);
 806              		.loc 1 263 0
 807 01e2 D4F8EC10 		ldr	r1, [r4, #236]	@ float
 808 01e6 E06F     		ldr	r0, [r4, #124]	@ float
 809 01e8 FFF7FEFF 		bl	__aeabi_fsub
 810              	.LVL87:
 811 01ec D4F8E810 		ldr	r1, [r4, #232]	@ float
 812 01f0 0746     		mov	r7, r0
 813 01f2 C4F80801 		str	r0, [r4, #264]	@ float
 814 01f6 A06F     		ldr	r0, [r4, #120]	@ float
 815 01f8 FFF7FEFF 		bl	__aeabi_fsub
 816              	.LVL88:
 817 01fc D4F8F010 		ldr	r1, [r4, #240]	@ float
 818 0200 0646     		mov	r6, r0
 819 0202 C4F80C01 		str	r0, [r4, #268]	@ float
 820 0206 D4F88000 		ldr	r0, [r4, #128]	@ float
 821 020a FFF7FEFF 		bl	__aeabi_fsub
 822              	.LVL89:
 262:state.c       ****       SetBit(state.pos_status, POS_UTM_F);
 823              		.loc 1 262 0
 824 020e B4F80080 		ldrh	r8, [r4, #0]
 264:state.c       ****       SetBit(state.pos_status, POS_ENU_F);
 265:state.c       ****       ENU_BFP_OF_REAL(state.enu_pos_i, state.enu_pos_f);
 825              		.loc 1 265 0
 826 0212 4FF08741 		mov	r1, #1132462080
 263:state.c       ****       ENU_OF_UTM_DIFF(state.enu_pos_f, state.utm_pos_f, state.utm_origin_f);
 827              		.loc 1 263 0
 828 0216 0546     		mov	r5, r0
 829 0218 C4F81001 		str	r0, [r4, #272]	@ float
 264:state.c       ****       SetBit(state.pos_status, POS_ENU_F);
 830              		.loc 1 264 0
 831 021c 48F42078 		orr	r8, r8, #640
 832              		.loc 1 265 0
 833 0220 3846     		mov	r0, r7
 264:state.c       ****       SetBit(state.pos_status, POS_ENU_F);
 834              		.loc 1 264 0
 835 0222 A4F80080 		strh	r8, [r4, #0]	@ movhi
 836              		.loc 1 265 0
 837 0226 FFF7FEFF 		bl	__aeabi_fmul
 838              	.LVL90:
 839 022a FFF7FEFF 		bl	__aeabi_f2iz
 840              	.LVL91:
 841 022e 4FF08741 		mov	r1, #1132462080
 842 0232 E066     		str	r0, [r4, #108]
 843 0234 3046     		mov	r0, r6
 844 0236 FFF7FEFF 		bl	__aeabi_fmul
 845              	.LVL92:
 846 023a FFF7FEFF 		bl	__aeabi_f2iz
 847              	.LVL93:
 848 023e 2067     		str	r0, [r4, #112]
 849 0240 2846     		mov	r0, r5
 850              	.L76:
 851 0242 4FF08741 		mov	r1, #1132462080
 852 0246 FFF7FEFF 		bl	__aeabi_fmul
 853              	.LVL94:
 854 024a FFF7FEFF 		bl	__aeabi_f2iz
 855              	.LVL95:
 856              	.L79:
 857 024e 6067     		str	r0, [r4, #116]
 858              	.L56:
 266:state.c       ****     }
 267:state.c       ****     else { /* could not get this representation,  set errno */
 268:state.c       ****       errno = 2;
 269:state.c       ****     }
 270:state.c       ****   }
 271:state.c       ****   else { /* ned coordinate system not initialized,  set errno */
 272:state.c       ****     errno = 3;
 273:state.c       ****   }
 274:state.c       ****   if (errno) {
 275:state.c       ****     //struct EnuCoor_i _enu_zero = {0};
 276:state.c       ****     //return _enu_zero;
 277:state.c       ****   }
 278:state.c       ****   /* set bit to indicate this representation is computed */
 279:state.c       ****   SetBit(state.pos_status, POS_ENU_I);
 859              		.loc 1 279 0
 860 0250 0549     		ldr	r1, .L83+8
 861 0252 0A88     		ldrh	r2, [r1, #0]
 862 0254 42F00403 		orr	r3, r2, #4
 863 0258 0B80     		strh	r3, [r1, #0]	@ movhi
 864              	.LVL96:
 865              	.L52:
 866 025a BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 867              	.L84:
 868 025e 00BF     		.align	3
 869              	.L83:
 870 0260 00000000 		.word	0
 871 0264 D0126341 		.word	1097011920
 872 0268 00000000 		.word	.LANCHOR0
 873 026c 00408F40 		.word	1083129856
 874              		.cfi_endproc
 875              	.LFE103:
 877              		.section	.text.stateCalcPositionLla_i,"ax",%progbits
 878              		.align	1
 879              		.global	stateCalcPositionLla_i
 880              		.thumb
 881              		.thumb_func
 883              	stateCalcPositionLla_i:
 884              	.LFB104:
 280:state.c       **** }
 281:state.c       **** 
 282:state.c       **** void stateCalcPositionLla_i(void) {
 885              		.loc 1 282 0
 886              		.cfi_startproc
 887              		@ args = 0, pretend = 0, frame = 0
 888              		@ frame_needed = 0, uses_anonymous_args = 0
 889 0000 10B5     		push	{r4, lr}
 890              	.LCFI3:
 891              		.cfi_def_cfa_offset 8
 892              		.cfi_offset 4, -8
 893              		.cfi_offset 14, -4
 283:state.c       ****   if (bit_is_set(state.pos_status, POS_LLA_I))
 894              		.loc 1 283 0
 895 0002 394C     		ldr	r4, .L100+8
 896 0004 2388     		ldrh	r3, [r4, #0]
 897 0006 1807     		lsls	r0, r3, #28
 898 0008 67D4     		bmi	.L85
 284:state.c       ****     return;
 285:state.c       **** 
 286:state.c       ****   if (bit_is_set(state.pos_status, POS_LLA_F)) {
 899              		.loc 1 286 0
 900 000a D905     		lsls	r1, r3, #23
 901 000c 3DD4     		bmi	.L96
 902              	.L87:
 287:state.c       ****     LLA_BFP_OF_REAL(state.lla_pos_i, state.lla_pos_f);
 288:state.c       ****   }
 289:state.c       ****   else if (bit_is_set(state.pos_status, POS_ECEF_I)) {
 903              		.loc 1 289 0
 904 000e DA07     		lsls	r2, r3, #31
 905 0010 02D5     		bpl	.L89
 290:state.c       ****     lla_of_ecef_i(&state.lla_pos_i, &state.ecef_pos_i);
 906              		.loc 1 290 0
 907 0012 04F11000 		add	r0, r4, #16
 908 0016 28E0     		b	.L97
 909              	.L89:
 291:state.c       ****   }
 292:state.c       ****   else if (bit_is_set(state.pos_status, POS_ECEF_F)) {
 910              		.loc 1 292 0
 911 0018 9806     		lsls	r0, r3, #26
 912 001a 02D5     		bpl	.L90
 293:state.c       ****     /* transform ecef_f -> lla_f, set status bit, then convert to int */
 294:state.c       ****     lla_of_ecef_f(&state.lla_pos_f, &state.ecef_pos_f);
 913              		.loc 1 294 0
 914 001c 04F18C00 		add	r0, r4, #140
 915 0020 0FE0     		b	.L99
 916              	.L90:
 295:state.c       ****     SetBit(state.pos_status, POS_LLA_F);
 296:state.c       ****     LLA_BFP_OF_REAL(state.lla_pos_i, state.lla_pos_f);
 297:state.c       ****   }
 298:state.c       ****   else if (bit_is_set(state.pos_status, POS_NED_F)) {
 917              		.loc 1 298 0
 918 0022 5906     		lsls	r1, r3, #25
 919 0024 12D5     		bpl	.L91
 299:state.c       ****     /* transform ned_f -> ecef_f -> lla_f -> lla_i, set status bits */
 300:state.c       ****     ecef_of_ned_point_f(&state.ecef_pos_f, &state.ned_origin_f, &state.ned_pos_f);
 920              		.loc 1 300 0
 921 0026 04F19800 		add	r0, r4, #152
 922 002a 04F1FC02 		add	r2, r4, #252
 923 002e 04F1A401 		add	r1, r4, #164
 924 0032 FFF7FEFF 		bl	ecef_of_ned_point_f
 925              	.LVL97:
 301:state.c       ****     SetBit(state.pos_status, POS_ECEF_F);
 926              		.loc 1 301 0
 927 0036 2288     		ldrh	r2, [r4, #0]
 928 0038 2046     		mov	r0, r4
 929 003a 42F02003 		orr	r3, r2, #32
 930 003e 20F88C3B 		strh	r3, [r0], #140	@ movhi
 931              	.L99:
 302:state.c       ****     lla_of_ecef_f(&state.lla_pos_f, &state.ecef_pos_f);
 932              		.loc 1 302 0
 933 0042 04F19801 		add	r1, r4, #152
 934 0046 FFF7FEFF 		bl	lla_of_ecef_f
 935              	.LVL98:
 936 004a 1AE0     		b	.L98
 937              	.L91:
 303:state.c       ****     SetBit(state.pos_status, POS_LLA_F);
 304:state.c       ****     LLA_BFP_OF_REAL(state.lla_pos_i, state.lla_pos_f);
 305:state.c       ****   }
 306:state.c       ****   else if (bit_is_set(state.pos_status, POS_NED_I)) {
 938              		.loc 1 306 0
 939 004c 9A07     		lsls	r2, r3, #30
 940 004e 10D5     		bpl	.L92
 307:state.c       ****     /* transform ned_i -> ecef_i -> lla_i, set status bits */
 308:state.c       ****     ecef_of_ned_pos_i(&state.ecef_pos_i, &state.ned_origin_i, &state.ned_pos_i);
 941              		.loc 1 308 0
 942 0050 201D     		adds	r0, r4, #4
 943 0052 04F11C01 		add	r1, r4, #28
 944 0056 04F16002 		add	r2, r4, #96
 945 005a FFF7FEFF 		bl	ecef_of_ned_pos_i
 946              	.LVL99:
 309:state.c       ****     SetBit(state.pos_status, POS_ECEF_I);
 947              		.loc 1 309 0
 948 005e 2088     		ldrh	r0, [r4, #0]
 949 0060 40F00101 		orr	r1, r0, #1
 950 0064 2046     		mov	r0, r4
 951 0066 20F8101B 		strh	r1, [r0], #16	@ movhi
 952              	.L97:
 310:state.c       ****     lla_of_ecef_i(&state.lla_pos_i, &state.ecef_pos_i); /* uses double version internally */
 953              		.loc 1 310 0
 954 006a 211D     		adds	r1, r4, #4
 955 006c FFF7FEFF 		bl	lla_of_ecef_i
 956              	.LVL100:
 957 0070 2EE0     		b	.L88
 958              	.L92:
 311:state.c       ****   }
 312:state.c       ****   else if (bit_is_set(state.pos_status, POS_UTM_F)) {
 959              		.loc 1 312 0
 960 0072 9805     		lsls	r0, r3, #22
 961 0074 2CD5     		bpl	.L88
 313:state.c       ****     /* transform utm_f -> lla_f -> lla_i, set status bits */
 314:state.c       ****     lla_of_utm_f(&state.lla_pos_f, &state.utm_pos_f);
 962              		.loc 1 314 0
 963 0076 04F18C00 		add	r0, r4, #140
 964 007a 04F17801 		add	r1, r4, #120
 965 007e FFF7FEFF 		bl	lla_of_utm_f
 966              	.LVL101:
 967              	.L98:
 315:state.c       ****     SetBit(state.pos_status, POS_LLA_F);
 968              		.loc 1 315 0
 969 0082 2088     		ldrh	r0, [r4, #0]
 970 0084 40F48071 		orr	r1, r0, #256
 971 0088 2180     		strh	r1, [r4, #0]	@ movhi
 972              	.L96:
 316:state.c       ****     LLA_BFP_OF_REAL(state.lla_pos_i, state.lla_pos_f);
 973              		.loc 1 316 0
 974 008a D4F89000 		ldr	r0, [r4, #144]	@ float
 975 008e FFF7FEFF 		bl	__aeabi_f2d
 976              	.LVL102:
 977 0092 13A3     		adr	r3, .L100
 978 0094 D3E90023 		ldrd	r2, [r3]
 979 0098 FFF7FEFF 		bl	__aeabi_dmul
 980              	.LVL103:
 981 009c FFF7FEFF 		bl	__aeabi_d2iz
 982              	.LVL104:
 983 00a0 6061     		str	r0, [r4, #20]
 984 00a2 D4F88C00 		ldr	r0, [r4, #140]	@ float
 985 00a6 FFF7FEFF 		bl	__aeabi_f2d
 986              	.LVL105:
 987 00aa 0DA3     		adr	r3, .L100
 988 00ac D3E90023 		ldrd	r2, [r3]
 989 00b0 FFF7FEFF 		bl	__aeabi_dmul
 990              	.LVL106:
 991 00b4 FFF7FEFF 		bl	__aeabi_d2iz
 992              	.LVL107:
 993 00b8 2061     		str	r0, [r4, #16]
 994 00ba D4F89400 		ldr	r0, [r4, #148]	@ float
 995 00be FFF7FEFF 		bl	__aeabi_f2d
 996              	.LVL108:
 997 00c2 0022     		movs	r2, #0
 998 00c4 094B     		ldr	r3, .L100+12
 999 00c6 FFF7FEFF 		bl	__aeabi_dmul
 1000              	.LVL109:
 1001 00ca FFF7FEFF 		bl	__aeabi_d2iz
 1002              	.LVL110:
 1003 00ce A061     		str	r0, [r4, #24]
 1004              	.L88:
 317:state.c       ****   }
 318:state.c       ****   else {
 319:state.c       ****     /* could not get this representation,  set errno */
 320:state.c       ****     //struct LlaCoor_i _lla_zero = {0};
 321:state.c       ****     //return _lla_zero;
 322:state.c       ****   }
 323:state.c       ****   /* set bit to indicate this representation is computed */
 324:state.c       ****   SetBit(state.pos_status, POS_LLA_I);
 1005              		.loc 1 324 0
 1006 00d0 054B     		ldr	r3, .L100+8
 1007 00d2 1A88     		ldrh	r2, [r3, #0]
 1008 00d4 42F00800 		orr	r0, r2, #8
 1009 00d8 1880     		strh	r0, [r3, #0]	@ movhi
 1010              	.L85:
 1011 00da 10BD     		pop	{r4, pc}
 1012              	.L101:
 1013 00dc AFF30080 		.align	3
 1014              	.L100:
 1015 00e0 00000000 		.word	0
 1016 00e4 D0126341 		.word	1097011920
 1017 00e8 00000000 		.word	.LANCHOR0
 1018 00ec 00408F40 		.word	1083129856
 1019              		.cfi_endproc
 1020              	.LFE104:
 1022              		.section	.text.stateCalcPositionUtm_f,"ax",%progbits
 1023              		.align	1
 1024              		.global	stateCalcPositionUtm_f
 1025              		.thumb
 1026              		.thumb_func
 1028              	stateCalcPositionUtm_f:
 1029              	.LFB105:
 325:state.c       **** }
 326:state.c       **** 
 327:state.c       **** void stateCalcPositionUtm_f(void) {
 1030              		.loc 1 327 0
 1031              		.cfi_startproc
 1032              		@ args = 0, pretend = 0, frame = 0
 1033              		@ frame_needed = 0, uses_anonymous_args = 0
 1034 0000 38B5     		push	{r3, r4, r5, lr}
 1035              	.LCFI4:
 1036              		.cfi_def_cfa_offset 16
 1037              		.cfi_offset 3, -16
 1038              		.cfi_offset 4, -12
 1039              		.cfi_offset 5, -8
 1040              		.cfi_offset 14, -4
 328:state.c       ****   if (bit_is_set(state.pos_status, POS_UTM_F))
 1041              		.loc 1 328 0
 1042 0002 214C     		ldr	r4, .L110+8
 1043 0004 2588     		ldrh	r5, [r4, #0]
 1044 0006 A905     		lsls	r1, r5, #22
 1045 0008 37D4     		bmi	.L102
 329:state.c       ****     return;
 330:state.c       **** 
 331:state.c       ****   if (bit_is_set(state.pos_status, POS_LLA_F)) {
 1046              		.loc 1 331 0
 1047 000a EA05     		lsls	r2, r5, #23
 1048 000c 02D5     		bpl	.L104
 332:state.c       ****     utm_of_lla_f(&state.utm_pos_f, &state.lla_pos_f);
 1049              		.loc 1 332 0
 1050 000e 04F17800 		add	r0, r4, #120
 1051 0012 29E0     		b	.L109
 1052              	.L104:
 333:state.c       ****   }
 334:state.c       ****   else if (bit_is_set(state.pos_status, POS_LLA_I)) {
 1053              		.loc 1 334 0
 1054 0014 2B07     		lsls	r3, r5, #28
 1055 0016 2BD5     		bpl	.L105
 335:state.c       ****     /* transform lla_i -> lla_f -> utm_f, set status bits */
 336:state.c       ****     LLA_FLOAT_OF_BFP(state.lla_pos_f, state.lla_pos_i);
 1056              		.loc 1 336 0
 1057 0018 6069     		ldr	r0, [r4, #20]
 1058 001a FFF7FEFF 		bl	__aeabi_i2d
 1059              	.LVL111:
 1060 001e 18A3     		adr	r3, .L110
 1061 0020 D3E90023 		ldrd	r2, [r3]
 1062 0024 FFF7FEFF 		bl	__aeabi_ddiv
 1063              	.LVL112:
 1064 0028 FFF7FEFF 		bl	__aeabi_d2f
 1065              	.LVL113:
 1066 002c C4F89000 		str	r0, [r4, #144]	@ float
 1067 0030 2069     		ldr	r0, [r4, #16]
 1068 0032 FFF7FEFF 		bl	__aeabi_i2d
 1069              	.LVL114:
 1070 0036 12A3     		adr	r3, .L110
 1071 0038 D3E90023 		ldrd	r2, [r3]
 1072 003c FFF7FEFF 		bl	__aeabi_ddiv
 1073              	.LVL115:
 1074 0040 FFF7FEFF 		bl	__aeabi_d2f
 1075              	.LVL116:
 1076 0044 C4F88C00 		str	r0, [r4, #140]	@ float
 1077 0048 A069     		ldr	r0, [r4, #24]
 1078 004a FFF7FEFF 		bl	__aeabi_i2d
 1079              	.LVL117:
 1080 004e 0022     		movs	r2, #0
 1081 0050 0E4B     		ldr	r3, .L110+12
 1082 0052 FFF7FEFF 		bl	__aeabi_ddiv
 1083              	.LVL118:
 1084 0056 FFF7FEFF 		bl	__aeabi_d2f
 1085              	.LVL119:
 337:state.c       ****     SetBit(state.pos_status, POS_LLA_F);
 1086              		.loc 1 337 0
 1087 005a 45F48075 		orr	r5, r5, #256
 336:state.c       ****     LLA_FLOAT_OF_BFP(state.lla_pos_f, state.lla_pos_i);
 1088              		.loc 1 336 0
 1089 005e C4F89400 		str	r0, [r4, #148]	@ float
 1090              		.loc 1 337 0
 1091 0062 2046     		mov	r0, r4
 1092 0064 20F8785B 		strh	r5, [r0], #120	@ movhi
 1093              	.L109:
 338:state.c       ****     utm_of_lla_f(&state.utm_pos_f, &state.lla_pos_f);
 1094              		.loc 1 338 0
 1095 0068 04F18C01 		add	r1, r4, #140
 1096 006c FFF7FEFF 		bl	utm_of_lla_f
 1097              	.LVL120:
 1098              	.L105:
 339:state.c       ****   }
 340:state.c       ****   else {
 341:state.c       ****     /* could not get this representation,  set errno */
 342:state.c       ****     //struct EcefCoor_f _ecef_zero = {0.0f};
 343:state.c       ****     //return _ecef_zero;
 344:state.c       ****   }
 345:state.c       ****   /* set bit to indicate this representation is computed */
 346:state.c       ****   SetBit(state.pos_status, POS_UTM_F);
 1099              		.loc 1 346 0
 1100 0070 054B     		ldr	r3, .L110+8
 1101 0072 1A88     		ldrh	r2, [r3, #0]
 1102 0074 42F40070 		orr	r0, r2, #512
 1103 0078 1880     		strh	r0, [r3, #0]	@ movhi
 1104              	.L102:
 1105 007a 38BD     		pop	{r3, r4, r5, pc}
 1106              	.L111:
 1107 007c AFF30080 		.align	3
 1108              	.L110:
 1109 0080 00000000 		.word	0
 1110 0084 D0126341 		.word	1097011920
 1111 0088 00000000 		.word	.LANCHOR0
 1112 008c 00408F40 		.word	1083129856
 1113              		.cfi_endproc
 1114              	.LFE105:
 1116              		.section	.text.stateCalcPositionEcef_f,"ax",%progbits
 1117              		.align	1
 1118              		.global	stateCalcPositionEcef_f
 1119              		.thumb
 1120              		.thumb_func
 1122              	stateCalcPositionEcef_f:
 1123              	.LFB106:
 347:state.c       **** }
 348:state.c       **** 
 349:state.c       **** void stateCalcPositionEcef_f(void) {
 1124              		.loc 1 349 0
 1125              		.cfi_startproc
 1126              		@ args = 0, pretend = 0, frame = 0
 1127              		@ frame_needed = 0, uses_anonymous_args = 0
 1128 0000 38B5     		push	{r3, r4, r5, lr}
 1129              	.LCFI5:
 1130              		.cfi_def_cfa_offset 16
 1131              		.cfi_offset 3, -16
 1132              		.cfi_offset 4, -12
 1133              		.cfi_offset 5, -8
 1134              		.cfi_offset 14, -4
 350:state.c       ****   if (bit_is_set(state.pos_status, POS_ECEF_F))
 1135              		.loc 1 350 0
 1136 0002 3F4C     		ldr	r4, .L124+8
 1137 0004 2588     		ldrh	r5, [r4, #0]
 1138 0006 AB06     		lsls	r3, r5, #26
 1139 0008 73D4     		bmi	.L112
 351:state.c       ****     return;
 352:state.c       **** 
 353:state.c       ****   if (bit_is_set(state.pos_status, POS_ECEF_I)) {
 1140              		.loc 1 353 0
 1141 000a E807     		lsls	r0, r5, #31
 1142 000c 17D4     		bmi	.L122
 1143              	.L114:
 354:state.c       ****     ECEF_FLOAT_OF_BFP(state.ecef_pos_f, state.ecef_pos_i);
 355:state.c       ****   }
 356:state.c       ****   else if (bit_is_set(state.pos_status, POS_NED_F)) {
 1144              		.loc 1 356 0
 1145 000e 6906     		lsls	r1, r5, #25
 1146 0010 08D5     		bpl	.L116
 357:state.c       ****     ecef_of_ned_point_f(&state.ecef_pos_f, &state.ned_origin_f, &state.ned_pos_f);
 1147              		.loc 1 357 0
 1148 0012 04F19800 		add	r0, r4, #152
 1149 0016 04F1A401 		add	r1, r4, #164
 1150 001a 04F1FC02 		add	r2, r4, #252
 1151 001e FFF7FEFF 		bl	ecef_of_ned_point_f
 1152              	.LVL121:
 1153 0022 61E0     		b	.L115
 1154              	.L116:
 358:state.c       ****   }
 359:state.c       ****   else if (bit_is_set(state.pos_status, POS_NED_I)) {
 1155              		.loc 1 359 0
 1156 0024 AA07     		lsls	r2, r5, #30
 1157 0026 2CD5     		bpl	.L117
 360:state.c       ****     /* transform ned_i -> ecef_i -> ecef_f, set status bits */
 361:state.c       ****     ecef_of_ned_pos_i(&state.ecef_pos_i, &state.ned_origin_i, &state.ned_pos_i);
 1158              		.loc 1 361 0
 1159 0028 201D     		adds	r0, r4, #4
 1160 002a 04F11C01 		add	r1, r4, #28
 1161 002e 04F16002 		add	r2, r4, #96
 1162 0032 FFF7FEFF 		bl	ecef_of_ned_pos_i
 1163              	.LVL122:
 362:state.c       ****     SetBit(state.pos_status, POS_ECEF_F);
 1164              		.loc 1 362 0
 1165 0036 2388     		ldrh	r3, [r4, #0]
 1166 0038 43F02000 		orr	r0, r3, #32
 1167 003c 2080     		strh	r0, [r4, #0]	@ movhi
 1168              	.L122:
 363:state.c       ****     ECEF_FLOAT_OF_BFP(state.ecef_pos_f, state.ecef_pos_i);
 1169              		.loc 1 363 0
 1170 003e 6068     		ldr	r0, [r4, #4]
 1171 0040 FFF7FEFF 		bl	__aeabi_i2d
 1172              	.LVL123:
 1173 0044 0022     		movs	r2, #0
 1174 0046 2F4B     		ldr	r3, .L124+12
 1175 0048 FFF7FEFF 		bl	__aeabi_ddiv
 1176              	.LVL124:
 1177 004c FFF7FEFF 		bl	__aeabi_d2f
 1178              	.LVL125:
 1179 0050 C4F89800 		str	r0, [r4, #152]	@ float
 1180 0054 A068     		ldr	r0, [r4, #8]
 1181 0056 FFF7FEFF 		bl	__aeabi_i2d
 1182              	.LVL126:
 1183 005a 0022     		movs	r2, #0
 1184 005c 294B     		ldr	r3, .L124+12
 1185 005e FFF7FEFF 		bl	__aeabi_ddiv
 1186              	.LVL127:
 1187 0062 FFF7FEFF 		bl	__aeabi_d2f
 1188              	.LVL128:
 1189 0066 C4F89C00 		str	r0, [r4, #156]	@ float
 1190 006a E068     		ldr	r0, [r4, #12]
 1191 006c FFF7FEFF 		bl	__aeabi_i2d
 1192              	.LVL129:
 1193 0070 0022     		movs	r2, #0
 1194 0072 244B     		ldr	r3, .L124+12
 1195 0074 FFF7FEFF 		bl	__aeabi_ddiv
 1196              	.LVL130:
 1197 0078 FFF7FEFF 		bl	__aeabi_d2f
 1198              	.LVL131:
 1199 007c C4F8A000 		str	r0, [r4, #160]	@ float
 1200 0080 32E0     		b	.L115
 1201              	.L117:
 364:state.c       ****   }
 365:state.c       ****   else if (bit_is_set(state.pos_status, POS_LLA_F)) {
 1202              		.loc 1 365 0
 1203 0082 EB05     		lsls	r3, r5, #23
 1204 0084 02D5     		bpl	.L118
 366:state.c       ****     ecef_of_lla_f(&state.ecef_pos_f, &state.lla_pos_f);
 1205              		.loc 1 366 0
 1206 0086 04F19800 		add	r0, r4, #152
 1207 008a 29E0     		b	.L123
 1208              	.L118:
 367:state.c       ****   }
 368:state.c       ****   else if (bit_is_set(state.pos_status, POS_LLA_I)) {
 1209              		.loc 1 368 0
 1210 008c 2807     		lsls	r0, r5, #28
 1211 008e 2BD5     		bpl	.L115
 369:state.c       ****     LLA_FLOAT_OF_BFP(state.lla_pos_f, state.lla_pos_i);
 1212              		.loc 1 369 0
 1213 0090 6069     		ldr	r0, [r4, #20]
 1214 0092 FFF7FEFF 		bl	__aeabi_i2d
 1215              	.LVL132:
 1216 0096 18A3     		adr	r3, .L124
 1217 0098 D3E90023 		ldrd	r2, [r3]
 1218 009c FFF7FEFF 		bl	__aeabi_ddiv
 1219              	.LVL133:
 1220 00a0 FFF7FEFF 		bl	__aeabi_d2f
 1221              	.LVL134:
 1222 00a4 C4F89000 		str	r0, [r4, #144]	@ float
 1223 00a8 2069     		ldr	r0, [r4, #16]
 1224 00aa FFF7FEFF 		bl	__aeabi_i2d
 1225              	.LVL135:
 1226 00ae 12A3     		adr	r3, .L124
 1227 00b0 D3E90023 		ldrd	r2, [r3]
 1228 00b4 FFF7FEFF 		bl	__aeabi_ddiv
 1229              	.LVL136:
 1230 00b8 FFF7FEFF 		bl	__aeabi_d2f
 1231              	.LVL137:
 1232 00bc C4F88C00 		str	r0, [r4, #140]	@ float
 1233 00c0 A069     		ldr	r0, [r4, #24]
 1234 00c2 FFF7FEFF 		bl	__aeabi_i2d
 1235              	.LVL138:
 1236 00c6 0022     		movs	r2, #0
 1237 00c8 0F4B     		ldr	r3, .L124+16
 1238 00ca FFF7FEFF 		bl	__aeabi_ddiv
 1239              	.LVL139:
 1240 00ce FFF7FEFF 		bl	__aeabi_d2f
 1241              	.LVL140:
 370:state.c       ****     SetBit(state.pos_status, POS_LLA_F);
 1242              		.loc 1 370 0
 1243 00d2 45F48075 		orr	r5, r5, #256
 369:state.c       ****     LLA_FLOAT_OF_BFP(state.lla_pos_f, state.lla_pos_i);
 1244              		.loc 1 369 0
 1245 00d6 C4F89400 		str	r0, [r4, #148]	@ float
 1246              		.loc 1 370 0
 1247 00da 2046     		mov	r0, r4
 1248 00dc 20F8985B 		strh	r5, [r0], #152	@ movhi
 1249              	.L123:
 371:state.c       ****     ecef_of_lla_f(&state.ecef_pos_f, &state.lla_pos_f);
 1250              		.loc 1 371 0
 1251 00e0 04F18C01 		add	r1, r4, #140
 1252 00e4 FFF7FEFF 		bl	ecef_of_lla_f
 1253              	.LVL141:
 1254              	.L115:
 372:state.c       ****   }
 373:state.c       ****   else {
 374:state.c       ****     /* could not get this representation,  set errno */
 375:state.c       ****     //struct EcefCoor_f _ecef_zero = {0.0f};
 376:state.c       ****     //return _ecef_zero;
 377:state.c       ****   }
 378:state.c       ****   /* set bit to indicate this representation is computed */
 379:state.c       ****   SetBit(state.pos_status, POS_ECEF_F);
 1255              		.loc 1 379 0
 1256 00e8 0549     		ldr	r1, .L124+8
 1257 00ea 0A88     		ldrh	r2, [r1, #0]
 1258 00ec 42F02003 		orr	r3, r2, #32
 1259 00f0 0B80     		strh	r3, [r1, #0]	@ movhi
 1260              	.L112:
 1261 00f2 38BD     		pop	{r3, r4, r5, pc}
 1262              	.L125:
 1263 00f4 AFF30080 		.align	3
 1264              	.L124:
 1265 00f8 00000000 		.word	0
 1266 00fc D0126341 		.word	1097011920
 1267 0100 00000000 		.word	.LANCHOR0
 1268 0104 00005940 		.word	1079574528
 1269 0108 00408F40 		.word	1083129856
 1270              		.cfi_endproc
 1271              	.LFE106:
 1273              		.global	__aeabi_i2f
 1274 010c AFF30080 		.section	.text.stateCalcPositionNed_f,"ax",%progbits
 1275              		.align	1
 1276              		.global	stateCalcPositionNed_f
 1277              		.thumb
 1278              		.thumb_func
 1280              	stateCalcPositionNed_f:
 1281              	.LFB107:
 380:state.c       **** }
 381:state.c       **** 
 382:state.c       **** void stateCalcPositionNed_f(void) {
 1282              		.loc 1 382 0
 1283              		.cfi_startproc
 1284              		@ args = 0, pretend = 0, frame = 0
 1285              		@ frame_needed = 0, uses_anonymous_args = 0
 1286 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 1287              	.LCFI6:
 1288              		.cfi_def_cfa_offset 24
 1289              		.cfi_offset 3, -24
 1290              		.cfi_offset 4, -20
 1291              		.cfi_offset 5, -16
 1292              		.cfi_offset 6, -12
 1293              		.cfi_offset 7, -8
 1294              		.cfi_offset 14, -4
 383:state.c       ****   if (bit_is_set(state.pos_status, POS_NED_F))
 1295              		.loc 1 383 0
 1296 0002 794C     		ldr	r4, .L153+8
 1297 0004 2588     		ldrh	r5, [r4, #0]
 1298 0006 6B06     		lsls	r3, r5, #25
 1299 0008 00F1E780 		bmi	.L126
 1300              	.LVL142:
 384:state.c       ****     return;
 385:state.c       **** 
 386:state.c       ****   int errno = 0;
 387:state.c       ****   if (state.ned_initialized_f) {
 1301              		.loc 1 387 0
 1302 000c 94F8E430 		ldrb	r3, [r4, #228]	@ zero_extendqisi2
 1303 0010 A3B3     		cbz	r3, .L128
 388:state.c       ****     if (bit_is_set(state.pos_status, POS_NED_I)) {
 1304              		.loc 1 388 0
 1305 0012 A807     		lsls	r0, r5, #30
 1306 0014 39D4     		bmi	.L151
 1307              	.L129:
 389:state.c       ****       NED_FLOAT_OF_BFP(state.ned_pos_f, state.ned_pos_i);
 390:state.c       ****     }
 391:state.c       ****     else if (bit_is_set(state.pos_status, POS_ECEF_F)) {
 1308              		.loc 1 391 0
 1309 0016 A906     		lsls	r1, r5, #26
 1310 0018 08D5     		bpl	.L131
 392:state.c       ****       ned_of_ecef_point_f(&state.ned_pos_f, &state.ned_origin_f, &state.ecef_pos_f);
 1311              		.loc 1 392 0
 1312 001a 04F1FC00 		add	r0, r4, #252
 1313 001e 04F1A401 		add	r1, r4, #164
 1314 0022 04F19802 		add	r2, r4, #152
 1315 0026 FFF7FEFF 		bl	ned_of_ecef_point_f
 1316              	.LVL143:
 1317 002a D1E0     		b	.L130
 1318              	.L131:
 393:state.c       ****     }
 394:state.c       ****     else if (bit_is_set(state.pos_status, POS_ECEF_I)) {
 1319              		.loc 1 394 0
 1320 002c EA07     		lsls	r2, r5, #31
 1321 002e 02D5     		bpl	.L132
 395:state.c       ****       /* transform ecef_i -> ned_i -> ned_f, set status bits */
 396:state.c       ****       ned_of_ecef_pos_i(&state.ned_pos_i, &state.ned_origin_i, &state.ecef_pos_i);
 1322              		.loc 1 396 0
 1323 0030 04F16000 		add	r0, r4, #96
 1324 0034 18E0     		b	.L152
 1325              	.L132:
 397:state.c       ****       SetBit(state.pos_status, POS_NED_I);
 398:state.c       ****       NED_FLOAT_OF_BFP(state.ned_pos_f, state.ned_pos_i);
 399:state.c       ****     }
 400:state.c       ****     else if (bit_is_set(state.pos_status, POS_LLA_F)) {
 1326              		.loc 1 400 0
 1327 0036 EB05     		lsls	r3, r5, #23
 1328 0038 08D5     		bpl	.L133
 401:state.c       ****       ned_of_lla_point_f(&state.ned_pos_f, &state.ned_origin_f, &state.lla_pos_f);
 1329              		.loc 1 401 0
 1330 003a 04F1FC00 		add	r0, r4, #252
 1331 003e 04F1A401 		add	r1, r4, #164
 1332 0042 04F18C02 		add	r2, r4, #140
 1333 0046 FFF7FEFF 		bl	ned_of_lla_point_f
 1334              	.LVL144:
 1335 004a C1E0     		b	.L130
 1336              	.L133:
 402:state.c       ****     }
 403:state.c       ****     else if (bit_is_set(state.pos_status, POS_LLA_I)) {
 1337              		.loc 1 403 0
 1338 004c 2807     		lsls	r0, r5, #28
 1339 004e 40F1BF80 		bpl	.L130
 404:state.c       ****       /* transform lla_i -> ecef_i -> ned_i -> ned_f, set status bits */
 405:state.c       ****       ecef_of_lla_i(&state.ecef_pos_i, &state.lla_pos_i); /* converts to doubles internally */
 1340              		.loc 1 405 0
 1341 0052 201D     		adds	r0, r4, #4
 1342 0054 04F11001 		add	r1, r4, #16
 1343 0058 FFF7FEFF 		bl	ecef_of_lla_i
 1344              	.LVL145:
 406:state.c       ****       SetBit(state.pos_status, POS_ECEF_I);
 1345              		.loc 1 406 0
 1346 005c 2388     		ldrh	r3, [r4, #0]
 1347 005e 2046     		mov	r0, r4
 1348 0060 43F00101 		orr	r1, r3, #1
 1349 0064 20F8601B 		strh	r1, [r0], #96	@ movhi
 1350              	.L152:
 407:state.c       ****       ned_of_ecef_pos_i(&state.ned_pos_i, &state.ned_origin_i, &state.ecef_pos_i);
 1351              		.loc 1 407 0
 1352 0068 221D     		adds	r2, r4, #4
 1353 006a 04F11C01 		add	r1, r4, #28
 1354 006e FFF7FEFF 		bl	ned_of_ecef_pos_i
 1355              	.LVL146:
 408:state.c       ****       SetBit(state.pos_status, POS_NED_I);
 1356              		.loc 1 408 0
 1357 0072 2088     		ldrh	r0, [r4, #0]
 1358 0074 40F00202 		orr	r2, r0, #2
 1359 0078 2280     		strh	r2, [r4, #0]	@ movhi
 1360 007a 06E0     		b	.L151
 1361              	.L128:
 409:state.c       ****       NED_FLOAT_OF_BFP(state.ned_pos_f, state.ned_pos_i);
 410:state.c       ****     }
 411:state.c       ****     else { /* could not get this representation,  set errno */
 412:state.c       ****       errno = 1;
 413:state.c       ****     }
 414:state.c       ****   }
 415:state.c       ****   else if (state.utm_initialized_f) {
 1362              		.loc 1 415 0
 1363 007c 94F8F800 		ldrb	r0, [r4, #248]	@ zero_extendqisi2
 1364 0080 0028     		cmp	r0, #0
 1365 0082 00F0A580 		beq	.L130
 416:state.c       ****     if (bit_is_set(state.pos_status, POS_NED_I)) {
 1366              		.loc 1 416 0
 1367 0086 A907     		lsls	r1, r5, #30
 1368 0088 19D5     		bpl	.L134
 1369              	.L151:
 417:state.c       ****       NED_FLOAT_OF_BFP(state.ned_pos_f, state.ned_pos_i);
 1370              		.loc 1 417 0
 1371 008a 206E     		ldr	r0, [r4, #96]
 1372 008c FFF7FEFF 		bl	__aeabi_i2f
 1373              	.LVL147:
 1374 0090 4FF06E51 		mov	r1, #998244352
 1375 0094 FFF7FEFF 		bl	__aeabi_fmul
 1376              	.LVL148:
 1377 0098 C4F8FC00 		str	r0, [r4, #252]	@ float
 1378 009c 606E     		ldr	r0, [r4, #100]
 1379 009e FFF7FEFF 		bl	__aeabi_i2f
 1380              	.LVL149:
 1381 00a2 4FF06E51 		mov	r1, #998244352
 1382 00a6 FFF7FEFF 		bl	__aeabi_fmul
 1383              	.LVL150:
 1384 00aa C4F80001 		str	r0, [r4, #256]	@ float
 1385 00ae A06E     		ldr	r0, [r4, #104]
 1386 00b0 FFF7FEFF 		bl	__aeabi_i2f
 1387              	.LVL151:
 1388 00b4 4FF06E51 		mov	r1, #998244352
 1389 00b8 FFF7FEFF 		bl	__aeabi_fmul
 1390              	.LVL152:
 1391 00bc 86E0     		b	.L148
 1392              	.L134:
 418:state.c       ****     }
 419:state.c       ****     else if (bit_is_set(state.pos_status, POS_ENU_I)) {
 1393              		.loc 1 419 0
 1394 00be 6A07     		lsls	r2, r5, #29
 1395 00c0 26D5     		bpl	.L135
 420:state.c       ****       ENU_FLOAT_OF_BFP(state.enu_pos_f, state.enu_pos_i);
 1396              		.loc 1 420 0
 1397 00c2 E06E     		ldr	r0, [r4, #108]
 1398 00c4 FFF7FEFF 		bl	__aeabi_i2f
 1399              	.LVL153:
 1400 00c8 4FF06E51 		mov	r1, #998244352
 1401 00cc FFF7FEFF 		bl	__aeabi_fmul
 1402              	.LVL154:
 1403 00d0 0646     		mov	r6, r0
 1404 00d2 C4F80801 		str	r0, [r4, #264]	@ float
 1405 00d6 206F     		ldr	r0, [r4, #112]
 1406 00d8 FFF7FEFF 		bl	__aeabi_i2f
 1407              	.LVL155:
 1408 00dc 4FF06E51 		mov	r1, #998244352
 1409 00e0 FFF7FEFF 		bl	__aeabi_fmul
 1410              	.LVL156:
 1411 00e4 0746     		mov	r7, r0
 1412 00e6 C4F80C01 		str	r0, [r4, #268]	@ float
 1413 00ea 606F     		ldr	r0, [r4, #116]
 1414 00ec FFF7FEFF 		bl	__aeabi_i2f
 1415              	.LVL157:
 1416 00f0 4FF06E51 		mov	r1, #998244352
 1417 00f4 FFF7FEFF 		bl	__aeabi_fmul
 1418              	.LVL158:
 421:state.c       ****       SetBit(state.pos_status, POS_ENU_F);
 1419              		.loc 1 421 0
 1420 00f8 45F08005 		orr	r5, r5, #128
 420:state.c       ****       ENU_FLOAT_OF_BFP(state.enu_pos_f, state.enu_pos_i);
 1421              		.loc 1 420 0
 1422 00fc C4F81001 		str	r0, [r4, #272]	@ float
 1423              		.loc 1 421 0
 1424 0100 2580     		strh	r5, [r4, #0]	@ movhi
 422:state.c       ****       VECT3_NED_OF_ENU(state.ned_pos_f, state.enu_pos_f);
 1425              		.loc 1 422 0
 1426 0102 C4F8FC70 		str	r7, [r4, #252]	@ float
 1427 0106 C4F80061 		str	r6, [r4, #256]	@ float
 1428 010a 00F10040 		add	r0, r0, #-2147483648
 1429 010e 5DE0     		b	.L148
 1430              	.L135:
 423:state.c       ****     }
 424:state.c       ****     else if (bit_is_set(state.pos_status, POS_ENU_F)) {
 1431              		.loc 1 424 0
 1432 0110 2B06     		lsls	r3, r5, #24
 1433 0112 0ED5     		bpl	.L136
 425:state.c       ****       VECT3_NED_OF_ENU(state.ned_pos_f, state.enu_pos_f);
 1434              		.loc 1 425 0
 1435 0114 D4F81011 		ldr	r1, [r4, #272]
 1436 0118 D4F80C31 		ldr	r3, [r4, #268]	@ float
 1437 011c D4F80801 		ldr	r0, [r4, #264]	@ float
 1438 0120 01F10042 		add	r2, r1, #-2147483648
 1439 0124 C4F8FC30 		str	r3, [r4, #252]	@ float
 1440 0128 C4F80001 		str	r0, [r4, #256]	@ float
 1441 012c C4F80421 		str	r2, [r4, #260]	@ float
 1442 0130 4EE0     		b	.L130
 1443              	.L136:
 426:state.c       ****     }
 427:state.c       ****     else if (bit_is_set(state.pos_status, POS_UTM_F)) {
 1444              		.loc 1 427 0
 1445 0132 A805     		lsls	r0, r5, #22
 1446 0134 36D4     		bmi	.L150
 1447              	.L137:
 428:state.c       ****       NED_OF_UTM_DIFF(state.ned_pos_f, state.utm_pos_f, state.utm_origin_f);
 429:state.c       ****     }
 430:state.c       ****     else if (bit_is_set(state.pos_status, POS_LLA_F)) {
 1448              		.loc 1 430 0
 1449 0136 E905     		lsls	r1, r5, #23
 1450 0138 02D5     		bpl	.L138
 431:state.c       ****       /* transform lla_f -> utm_f -> ned, set status bits */
 432:state.c       ****       utm_of_lla_f(&state.utm_pos_f, &state.lla_pos_f);
 1451              		.loc 1 432 0
 1452 013a 04F17800 		add	r0, r4, #120
 1453 013e 29E0     		b	.L149
 1454              	.L138:
 433:state.c       ****       SetBit(state.pos_status, POS_UTM_F);
 434:state.c       ****       NED_OF_UTM_DIFF(state.ned_pos_f, state.utm_pos_f, state.utm_origin_f);
 435:state.c       ****     }
 436:state.c       ****     else if (bit_is_set(state.pos_status, POS_LLA_I)) {
 1455              		.loc 1 436 0
 1456 0140 2A07     		lsls	r2, r5, #28
 1457 0142 45D5     		bpl	.L130
 437:state.c       ****       /* transform lla_i -> lla_f -> utm_f -> ned, set status bits */
 438:state.c       ****       LLA_FLOAT_OF_BFP(state.lla_pos_f, state.lla_pos_i);
 1458              		.loc 1 438 0
 1459 0144 6069     		ldr	r0, [r4, #20]
 1460 0146 FFF7FEFF 		bl	__aeabi_i2d
 1461              	.LVL159:
 1462 014a 25A3     		adr	r3, .L153
 1463 014c D3E90023 		ldrd	r2, [r3]
 1464 0150 FFF7FEFF 		bl	__aeabi_ddiv
 1465              	.LVL160:
 1466 0154 FFF7FEFF 		bl	__aeabi_d2f
 1467              	.LVL161:
 1468 0158 C4F89000 		str	r0, [r4, #144]	@ float
 1469 015c 2069     		ldr	r0, [r4, #16]
 1470 015e FFF7FEFF 		bl	__aeabi_i2d
 1471              	.LVL162:
 1472 0162 1FA3     		adr	r3, .L153
 1473 0164 D3E90023 		ldrd	r2, [r3]
 1474 0168 FFF7FEFF 		bl	__aeabi_ddiv
 1475              	.LVL163:
 1476 016c FFF7FEFF 		bl	__aeabi_d2f
 1477              	.LVL164:
 1478 0170 C4F88C00 		str	r0, [r4, #140]	@ float
 1479 0174 A069     		ldr	r0, [r4, #24]
 1480 0176 FFF7FEFF 		bl	__aeabi_i2d
 1481              	.LVL165:
 1482 017a 0022     		movs	r2, #0
 1483 017c 1B4B     		ldr	r3, .L153+12
 1484 017e FFF7FEFF 		bl	__aeabi_ddiv
 1485              	.LVL166:
 1486 0182 FFF7FEFF 		bl	__aeabi_d2f
 1487              	.LVL167:
 439:state.c       ****       SetBit(state.pos_status, POS_LLA_F);
 1488              		.loc 1 439 0
 1489 0186 45F48075 		orr	r5, r5, #256
 438:state.c       ****       LLA_FLOAT_OF_BFP(state.lla_pos_f, state.lla_pos_i);
 1490              		.loc 1 438 0
 1491 018a C4F89400 		str	r0, [r4, #148]	@ float
 1492              		.loc 1 439 0
 1493 018e 2046     		mov	r0, r4
 1494 0190 20F8785B 		strh	r5, [r0], #120	@ movhi
 1495              	.L149:
 440:state.c       ****       utm_of_lla_f(&state.utm_pos_f, &state.lla_pos_f);
 1496              		.loc 1 440 0
 1497 0194 04F18C01 		add	r1, r4, #140
 1498 0198 FFF7FEFF 		bl	utm_of_lla_f
 1499              	.LVL168:
 441:state.c       ****       SetBit(state.pos_status, POS_UTM_F);
 1500              		.loc 1 441 0
 1501 019c 2188     		ldrh	r1, [r4, #0]
 1502 019e 41F40072 		orr	r2, r1, #512
 1503 01a2 2280     		strh	r2, [r4, #0]	@ movhi
 1504              	.L150:
 442:state.c       ****       NED_OF_UTM_DIFF(state.ned_pos_f, state.utm_pos_f, state.utm_origin_f);
 1505              		.loc 1 442 0
 1506 01a4 D4F8E810 		ldr	r1, [r4, #232]	@ float
 1507 01a8 A06F     		ldr	r0, [r4, #120]	@ float
 1508 01aa FFF7FEFF 		bl	__aeabi_fsub
 1509              	.LVL169:
 1510 01ae D4F8EC10 		ldr	r1, [r4, #236]	@ float
 1511 01b2 C4F8FC00 		str	r0, [r4, #252]	@ float
 1512 01b6 E06F     		ldr	r0, [r4, #124]	@ float
 1513 01b8 FFF7FEFF 		bl	__aeabi_fsub
 1514              	.LVL170:
 1515 01bc D4F88010 		ldr	r1, [r4, #128]	@ float
 1516 01c0 C4F80001 		str	r0, [r4, #256]	@ float
 1517 01c4 D4F8F000 		ldr	r0, [r4, #240]	@ float
 1518 01c8 FFF7FEFF 		bl	__aeabi_fsub
 1519              	.LVL171:
 1520              	.L148:
 1521 01cc C4F80401 		str	r0, [r4, #260]	@ float
 1522              	.L130:
 443:state.c       ****     }
 444:state.c       ****     else { /* could not get this representation,  set errno */
 445:state.c       ****       errno = 2;
 446:state.c       ****     }
 447:state.c       ****   }
 448:state.c       ****   else { /* ned coordinate system not initialized,  set errno */
 449:state.c       ****     errno = 3;
 450:state.c       ****   }
 451:state.c       ****   if (errno) {
 452:state.c       ****     //struct NedCoor_f _ned_zero = {0.0f};
 453:state.c       ****     //return _ned_zero;
 454:state.c       ****   }
 455:state.c       ****   /* set bit to indicate this representation is computed */
 456:state.c       ****   SetBit(state.pos_status, POS_NED_F);
 1523              		.loc 1 456 0
 1524 01d0 054B     		ldr	r3, .L153+8
 1525 01d2 1988     		ldrh	r1, [r3, #0]
 1526 01d4 41F04000 		orr	r0, r1, #64
 1527 01d8 1880     		strh	r0, [r3, #0]	@ movhi
 1528              	.LVL172:
 1529              	.L126:
 1530 01da F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 1531              	.L154:
 1532 01dc AFF30080 		.align	3
 1533              	.L153:
 1534 01e0 00000000 		.word	0
 1535 01e4 D0126341 		.word	1097011920
 1536 01e8 00000000 		.word	.LANCHOR0
 1537 01ec 00408F40 		.word	1083129856
 1538              		.cfi_endproc
 1539              	.LFE107:
 1541              		.section	.text.stateCalcPositionEnu_f,"ax",%progbits
 1542              		.align	1
 1543              		.global	stateCalcPositionEnu_f
 1544              		.thumb
 1545              		.thumb_func
 1547              	stateCalcPositionEnu_f:
 1548              	.LFB108:
 457:state.c       **** }
 458:state.c       **** 
 459:state.c       **** void stateCalcPositionEnu_f(void) {
 1549              		.loc 1 459 0
 1550              		.cfi_startproc
 1551              		@ args = 0, pretend = 0, frame = 0
 1552              		@ frame_needed = 0, uses_anonymous_args = 0
 1553 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 1554              	.LCFI7:
 1555              		.cfi_def_cfa_offset 24
 1556              		.cfi_offset 3, -24
 1557              		.cfi_offset 4, -20
 1558              		.cfi_offset 5, -16
 1559              		.cfi_offset 6, -12
 1560              		.cfi_offset 7, -8
 1561              		.cfi_offset 14, -4
 460:state.c       ****   if (bit_is_set(state.pos_status, POS_ENU_F))
 1562              		.loc 1 460 0
 1563 0002 7B4C     		ldr	r4, .L186+8
 1564 0004 2588     		ldrh	r5, [r4, #0]
 1565 0006 2906     		lsls	r1, r5, #24
 1566 0008 00F1EC80 		bmi	.L155
 1567              	.LVL173:
 461:state.c       ****     return;
 462:state.c       **** 
 463:state.c       ****   int errno = 0;
 464:state.c       ****   if (state.ned_initialized_f) {
 1568              		.loc 1 464 0
 1569 000c 94F8E430 		ldrb	r3, [r4, #228]	@ zero_extendqisi2
 1570 0010 002B     		cmp	r3, #0
 1571 0012 38D0     		beq	.L157
 465:state.c       ****     if (bit_is_set(state.pos_status, POS_NED_F)) {
 1572              		.loc 1 465 0
 1573 0014 6A06     		lsls	r2, r5, #25
 1574 0016 59D4     		bmi	.L181
 1575              	.L158:
 466:state.c       ****       VECT3_ENU_OF_NED(state.enu_pos_f, state.ned_pos_f);
 467:state.c       ****     }
 468:state.c       ****     else if (bit_is_set(state.pos_status, POS_ENU_I)) {
 1576              		.loc 1 468 0
 1577 0018 6B07     		lsls	r3, r5, #29
 1578 001a 3BD4     		bmi	.L183
 1579              	.L160:
 469:state.c       ****       ENU_FLOAT_OF_BFP(state.enu_pos_f, state.enu_pos_i);
 470:state.c       ****     }
 471:state.c       ****     else if (bit_is_set(state.pos_status, POS_NED_I)) {
 1580              		.loc 1 471 0
 1581 001c A807     		lsls	r0, r5, #30
 1582 001e 66D4     		bmi	.L184
 1583              	.L161:
 472:state.c       ****       NED_FLOAT_OF_BFP(state.ned_pos_f, state.ned_pos_i);
 473:state.c       ****       SetBit(state.pos_status, POS_NED_F);
 474:state.c       ****       VECT3_ENU_OF_NED(state.enu_pos_f, state.ned_pos_f);
 475:state.c       ****     }
 476:state.c       ****     else if (bit_is_set(state.pos_status, POS_ECEF_F)) {
 1584              		.loc 1 476 0
 1585 0020 A906     		lsls	r1, r5, #26
 1586 0022 08D5     		bpl	.L162
 477:state.c       ****       enu_of_ecef_point_f(&state.enu_pos_f, &state.ned_origin_f, &state.ecef_pos_f);
 1587              		.loc 1 477 0
 1588 0024 04F58470 		add	r0, r4, #264
 1589 0028 04F1A401 		add	r1, r4, #164
 1590 002c 04F19802 		add	r2, r4, #152
 1591 0030 FFF7FEFF 		bl	enu_of_ecef_point_f
 1592              	.LVL174:
 1593 0034 D1E0     		b	.L159
 1594              	.L162:
 478:state.c       ****     }
 479:state.c       ****     else if (bit_is_set(state.pos_status, POS_ECEF_I)) {
 1595              		.loc 1 479 0
 1596 0036 EA07     		lsls	r2, r5, #31
 1597 0038 02D5     		bpl	.L163
 480:state.c       ****       /* transform ecef_i -> enu_i -> enu_f, set status bits */
 481:state.c       ****       enu_of_ecef_pos_i(&state.enu_pos_i, &state.ned_origin_i, &state.ecef_pos_i);
 1598              		.loc 1 481 0
 1599 003a 04F16C00 		add	r0, r4, #108
 1600 003e 18E0     		b	.L185
 1601              	.L163:
 482:state.c       ****       SetBit(state.pos_status, POS_ENU_I);
 483:state.c       ****       ENU_FLOAT_OF_BFP(state.enu_pos_f, state.enu_pos_i);
 484:state.c       ****     }
 485:state.c       ****     else if (bit_is_set(state.pos_status, POS_LLA_F)) {
 1602              		.loc 1 485 0
 1603 0040 EB05     		lsls	r3, r5, #23
 1604 0042 08D5     		bpl	.L164
 486:state.c       ****       enu_of_lla_point_f(&state.enu_pos_f, &state.ned_origin_f, &state.lla_pos_f);
 1605              		.loc 1 486 0
 1606 0044 04F58470 		add	r0, r4, #264
 1607 0048 04F1A401 		add	r1, r4, #164
 1608 004c 04F18C02 		add	r2, r4, #140
 1609 0050 FFF7FEFF 		bl	enu_of_lla_point_f
 1610              	.LVL175:
 1611 0054 C1E0     		b	.L159
 1612              	.L164:
 487:state.c       ****     }
 488:state.c       ****     else if (bit_is_set(state.pos_status, POS_LLA_I)) {
 1613              		.loc 1 488 0
 1614 0056 2807     		lsls	r0, r5, #28
 1615 0058 40F1BF80 		bpl	.L159
 489:state.c       ****       /* transform lla_i -> ecef_i -> enu_i -> enu_f, set status bits */
 490:state.c       ****       ecef_of_lla_i(&state.ecef_pos_i, &state.lla_pos_i); /* converts to doubles internally */
 1616              		.loc 1 490 0
 1617 005c 201D     		adds	r0, r4, #4
 1618 005e 04F11001 		add	r1, r4, #16
 1619 0062 FFF7FEFF 		bl	ecef_of_lla_i
 1620              	.LVL176:
 491:state.c       ****       SetBit(state.pos_status, POS_ECEF_I);
 1621              		.loc 1 491 0
 1622 0066 2388     		ldrh	r3, [r4, #0]
 1623 0068 2046     		mov	r0, r4
 1624 006a 43F00101 		orr	r1, r3, #1
 1625 006e 20F86C1B 		strh	r1, [r0], #108	@ movhi
 1626              	.L185:
 492:state.c       ****       enu_of_ecef_pos_i(&state.enu_pos_i, &state.ned_origin_i, &state.ecef_pos_i);
 1627              		.loc 1 492 0
 1628 0072 221D     		adds	r2, r4, #4
 1629 0074 04F11C01 		add	r1, r4, #28
 1630 0078 FFF7FEFF 		bl	enu_of_ecef_pos_i
 1631              	.LVL177:
 493:state.c       ****       SetBit(state.pos_status, POS_ENU_I);
 1632              		.loc 1 493 0
 1633 007c 2088     		ldrh	r0, [r4, #0]
 1634 007e 40F00402 		orr	r2, r0, #4
 1635 0082 2280     		strh	r2, [r4, #0]	@ movhi
 1636 0084 06E0     		b	.L183
 1637              	.L157:
 494:state.c       ****       ENU_FLOAT_OF_BFP(state.enu_pos_f, state.enu_pos_i);
 495:state.c       ****     }
 496:state.c       ****     else { /* could not get this representation,  set errno */
 497:state.c       ****       errno = 1;
 498:state.c       ****     }
 499:state.c       ****   }
 500:state.c       ****   else if (state.utm_initialized_f) {
 1638              		.loc 1 500 0
 1639 0086 94F8F800 		ldrb	r0, [r4, #248]	@ zero_extendqisi2
 1640 008a 0028     		cmp	r0, #0
 1641 008c 00F0A580 		beq	.L159
 501:state.c       ****     if (bit_is_set(state.pos_status, POS_ENU_I)) {
 1642              		.loc 1 501 0
 1643 0090 6907     		lsls	r1, r5, #29
 1644 0092 19D5     		bpl	.L165
 1645              	.L183:
 502:state.c       ****       ENU_FLOAT_OF_BFP(state.enu_pos_f, state.enu_pos_i);
 1646              		.loc 1 502 0
 1647 0094 E06E     		ldr	r0, [r4, #108]
 1648 0096 FFF7FEFF 		bl	__aeabi_i2f
 1649              	.LVL178:
 1650 009a 4FF06E51 		mov	r1, #998244352
 1651 009e FFF7FEFF 		bl	__aeabi_fmul
 1652              	.LVL179:
 1653 00a2 C4F80801 		str	r0, [r4, #264]	@ float
 1654 00a6 206F     		ldr	r0, [r4, #112]
 1655 00a8 FFF7FEFF 		bl	__aeabi_i2f
 1656              	.LVL180:
 1657 00ac 4FF06E51 		mov	r1, #998244352
 1658 00b0 FFF7FEFF 		bl	__aeabi_fmul
 1659              	.LVL181:
 1660 00b4 C4F80C01 		str	r0, [r4, #268]	@ float
 1661 00b8 606F     		ldr	r0, [r4, #116]
 1662 00ba FFF7FEFF 		bl	__aeabi_i2f
 1663              	.LVL182:
 1664 00be 4FF06E51 		mov	r1, #998244352
 1665 00c2 FFF7FEFF 		bl	__aeabi_fmul
 1666              	.LVL183:
 1667 00c6 86E0     		b	.L179
 1668              	.L165:
 503:state.c       ****     }
 504:state.c       ****     else if (bit_is_set(state.pos_status, POS_NED_F)) {
 1669              		.loc 1 504 0
 1670 00c8 6A06     		lsls	r2, r5, #25
 1671 00ca 0ED5     		bpl	.L166
 1672              	.L181:
 505:state.c       ****       VECT3_ENU_OF_NED(state.enu_pos_f, state.ned_pos_f);
 1673              		.loc 1 505 0
 1674 00cc D4F80401 		ldr	r0, [r4, #260]
 1675 00d0 D4F80031 		ldr	r3, [r4, #256]	@ float
 1676 00d4 D4F8FC10 		ldr	r1, [r4, #252]	@ float
 1677 00d8 00F10042 		add	r2, r0, #-2147483648
 1678 00dc C4F80831 		str	r3, [r4, #264]	@ float
 1679 00e0 C4F80C11 		str	r1, [r4, #268]	@ float
 1680 00e4 C4F81021 		str	r2, [r4, #272]	@ float
 1681 00e8 77E0     		b	.L159
 1682              	.L166:
 506:state.c       ****     }
 507:state.c       ****     else if (bit_is_set(state.pos_status, POS_NED_I)) {
 1683              		.loc 1 507 0
 1684 00ea AB07     		lsls	r3, r5, #30
 1685 00ec 26D5     		bpl	.L167
 1686              	.L184:
 508:state.c       ****       NED_FLOAT_OF_BFP(state.ned_pos_f, state.ned_pos_i);
 1687              		.loc 1 508 0
 1688 00ee 206E     		ldr	r0, [r4, #96]
 1689 00f0 FFF7FEFF 		bl	__aeabi_i2f
 1690              	.LVL184:
 1691 00f4 4FF06E51 		mov	r1, #998244352
 1692 00f8 FFF7FEFF 		bl	__aeabi_fmul
 1693              	.LVL185:
 1694 00fc 0646     		mov	r6, r0
 1695 00fe C4F8FC00 		str	r0, [r4, #252]	@ float
 1696 0102 606E     		ldr	r0, [r4, #100]
 1697 0104 FFF7FEFF 		bl	__aeabi_i2f
 1698              	.LVL186:
 1699 0108 4FF06E51 		mov	r1, #998244352
 1700 010c FFF7FEFF 		bl	__aeabi_fmul
 1701              	.LVL187:
 1702 0110 0746     		mov	r7, r0
 1703 0112 C4F80001 		str	r0, [r4, #256]	@ float
 1704 0116 A06E     		ldr	r0, [r4, #104]
 1705 0118 FFF7FEFF 		bl	__aeabi_i2f
 1706              	.LVL188:
 1707 011c 4FF06E51 		mov	r1, #998244352
 1708 0120 FFF7FEFF 		bl	__aeabi_fmul
 1709              	.LVL189:
 509:state.c       ****       SetBit(state.pos_status, POS_NED_F);
 1710              		.loc 1 509 0
 1711 0124 45F04005 		orr	r5, r5, #64
 508:state.c       ****       NED_FLOAT_OF_BFP(state.ned_pos_f, state.ned_pos_i);
 1712              		.loc 1 508 0
 1713 0128 C4F80401 		str	r0, [r4, #260]	@ float
 1714              		.loc 1 509 0
 1715 012c 2580     		strh	r5, [r4, #0]	@ movhi
 510:state.c       ****       VECT3_ENU_OF_NED(state.enu_pos_f, state.ned_pos_f);
 1716              		.loc 1 510 0
 1717 012e C4F80871 		str	r7, [r4, #264]	@ float
 1718 0132 C4F80C61 		str	r6, [r4, #268]	@ float
 1719 0136 00F10040 		add	r0, r0, #-2147483648
 1720 013a 4CE0     		b	.L179
 1721              	.L167:
 511:state.c       ****     }
 512:state.c       ****     else if (bit_is_set(state.pos_status, POS_UTM_F)) {
 1722              		.loc 1 512 0
 1723 013c A805     		lsls	r0, r5, #22
 1724 013e 36D4     		bmi	.L182
 1725              	.L168:
 513:state.c       ****       ENU_OF_UTM_DIFF(state.enu_pos_f, state.utm_pos_f, state.utm_origin_f);
 514:state.c       ****     }
 515:state.c       ****     else if (bit_is_set(state.pos_status, POS_LLA_F)) {
 1726              		.loc 1 515 0
 1727 0140 E905     		lsls	r1, r5, #23
 1728 0142 02D5     		bpl	.L169
 516:state.c       ****       /* transform lla_f -> utm_f -> enu, set status bits */
 517:state.c       ****       utm_of_lla_f(&state.utm_pos_f, &state.lla_pos_f);
 1729              		.loc 1 517 0
 1730 0144 04F17800 		add	r0, r4, #120
 1731 0148 29E0     		b	.L180
 1732              	.L169:
 518:state.c       ****       SetBit(state.pos_status, POS_UTM_F);
 519:state.c       ****       ENU_OF_UTM_DIFF(state.enu_pos_f, state.utm_pos_f, state.utm_origin_f);
 520:state.c       ****     }
 521:state.c       ****     else if (bit_is_set(state.pos_status, POS_LLA_I)) {
 1733              		.loc 1 521 0
 1734 014a 2A07     		lsls	r2, r5, #28
 1735 014c 45D5     		bpl	.L159
 522:state.c       ****       /* transform lla_i -> lla_f -> utm_f -> enu, set status bits */
 523:state.c       ****       LLA_FLOAT_OF_BFP(state.lla_pos_f, state.lla_pos_i);
 1736              		.loc 1 523 0
 1737 014e 6069     		ldr	r0, [r4, #20]
 1738 0150 FFF7FEFF 		bl	__aeabi_i2d
 1739              	.LVL190:
 1740 0154 24A3     		adr	r3, .L186
 1741 0156 D3E90023 		ldrd	r2, [r3]
 1742 015a FFF7FEFF 		bl	__aeabi_ddiv
 1743              	.LVL191:
 1744 015e FFF7FEFF 		bl	__aeabi_d2f
 1745              	.LVL192:
 1746 0162 C4F89000 		str	r0, [r4, #144]	@ float
 1747 0166 2069     		ldr	r0, [r4, #16]
 1748 0168 FFF7FEFF 		bl	__aeabi_i2d
 1749              	.LVL193:
 1750 016c 1EA3     		adr	r3, .L186
 1751 016e D3E90023 		ldrd	r2, [r3]
 1752 0172 FFF7FEFF 		bl	__aeabi_ddiv
 1753              	.LVL194:
 1754 0176 FFF7FEFF 		bl	__aeabi_d2f
 1755              	.LVL195:
 1756 017a C4F88C00 		str	r0, [r4, #140]	@ float
 1757 017e A069     		ldr	r0, [r4, #24]
 1758 0180 FFF7FEFF 		bl	__aeabi_i2d
 1759              	.LVL196:
 1760 0184 0022     		movs	r2, #0
 1761 0186 1B4B     		ldr	r3, .L186+12
 1762 0188 FFF7FEFF 		bl	__aeabi_ddiv
 1763              	.LVL197:
 1764 018c FFF7FEFF 		bl	__aeabi_d2f
 1765              	.LVL198:
 524:state.c       ****       SetBit(state.pos_status, POS_LLA_F);
 1766              		.loc 1 524 0
 1767 0190 45F48075 		orr	r5, r5, #256
 523:state.c       ****       LLA_FLOAT_OF_BFP(state.lla_pos_f, state.lla_pos_i);
 1768              		.loc 1 523 0
 1769 0194 C4F89400 		str	r0, [r4, #148]	@ float
 1770              		.loc 1 524 0
 1771 0198 2046     		mov	r0, r4
 1772 019a 20F8785B 		strh	r5, [r0], #120	@ movhi
 1773              	.L180:
 525:state.c       ****       utm_of_lla_f(&state.utm_pos_f, &state.lla_pos_f);
 1774              		.loc 1 525 0
 1775 019e 04F18C01 		add	r1, r4, #140
 1776 01a2 FFF7FEFF 		bl	utm_of_lla_f
 1777              	.LVL199:
 526:state.c       ****       SetBit(state.pos_status, POS_UTM_F);
 1778              		.loc 1 526 0
 1779 01a6 2188     		ldrh	r1, [r4, #0]
 1780 01a8 41F40072 		orr	r2, r1, #512
 1781 01ac 2280     		strh	r2, [r4, #0]	@ movhi
 1782              	.L182:
 527:state.c       ****       ENU_OF_UTM_DIFF(state.enu_pos_f, state.utm_pos_f, state.utm_origin_f);
 1783              		.loc 1 527 0
 1784 01ae D4F8EC10 		ldr	r1, [r4, #236]	@ float
 1785 01b2 E06F     		ldr	r0, [r4, #124]	@ float
 1786 01b4 FFF7FEFF 		bl	__aeabi_fsub
 1787              	.LVL200:
 1788 01b8 D4F8E810 		ldr	r1, [r4, #232]	@ float
 1789 01bc C4F80801 		str	r0, [r4, #264]	@ float
 1790 01c0 A06F     		ldr	r0, [r4, #120]	@ float
 1791 01c2 FFF7FEFF 		bl	__aeabi_fsub
 1792              	.LVL201:
 1793 01c6 D4F8F010 		ldr	r1, [r4, #240]	@ float
 1794 01ca C4F80C01 		str	r0, [r4, #268]	@ float
 1795 01ce D4F88000 		ldr	r0, [r4, #128]	@ float
 1796 01d2 FFF7FEFF 		bl	__aeabi_fsub
 1797              	.LVL202:
 1798              	.L179:
 1799 01d6 C4F81001 		str	r0, [r4, #272]	@ float
 1800              	.L159:
 528:state.c       ****     }
 529:state.c       ****     else { /* could not get this representation,  set errno */
 530:state.c       ****       errno = 2;
 531:state.c       ****     }
 532:state.c       ****   }
 533:state.c       ****   else { /* ned coordinate system not initialized,  set errno */
 534:state.c       ****     errno = 3;
 535:state.c       ****   }
 536:state.c       ****   if (errno) {
 537:state.c       ****     //struct EnuCoor_f _enu_zero = {0.0f};
 538:state.c       ****     //return _enu_zero;
 539:state.c       ****   }
 540:state.c       ****   /* set bit to indicate this representation is computed */
 541:state.c       ****   SetBit(state.pos_status, POS_ENU_F);
 1801              		.loc 1 541 0
 1802 01da 054B     		ldr	r3, .L186+8
 1803 01dc 1988     		ldrh	r1, [r3, #0]
 1804 01de 41F08000 		orr	r0, r1, #128
 1805 01e2 1880     		strh	r0, [r3, #0]	@ movhi
 1806              	.LVL203:
 1807              	.L155:
 1808 01e4 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 1809              	.L187:
 1810 01e6 00BF     		.align	3
 1811              	.L186:
 1812 01e8 00000000 		.word	0
 1813 01ec D0126341 		.word	1097011920
 1814 01f0 00000000 		.word	.LANCHOR0
 1815 01f4 00408F40 		.word	1083129856
 1816              		.cfi_endproc
 1817              	.LFE108:
 1819              		.global	__aeabi_fdiv
 1820              		.section	.text.stateCalcPositionLla_f,"ax",%progbits
 1821              		.align	1
 1822              		.global	stateCalcPositionLla_f
 1823              		.thumb
 1824              		.thumb_func
 1826              	stateCalcPositionLla_f:
 1827              	.LFB109:
 542:state.c       **** }
 543:state.c       **** 
 544:state.c       **** void stateCalcPositionLla_f(void) {
 1828              		.loc 1 544 0
 1829              		.cfi_startproc
 1830              		@ args = 0, pretend = 0, frame = 0
 1831              		@ frame_needed = 0, uses_anonymous_args = 0
 1832 0000 38B5     		push	{r3, r4, r5, lr}
 1833              	.LCFI8:
 1834              		.cfi_def_cfa_offset 16
 1835              		.cfi_offset 3, -16
 1836              		.cfi_offset 4, -12
 1837              		.cfi_offset 5, -8
 1838              		.cfi_offset 14, -4
 545:state.c       ****   if (bit_is_set(state.pos_status, POS_LLA_F))
 1839              		.loc 1 545 0
 1840 0002 484C     		ldr	r4, .L201
 1841 0004 2588     		ldrh	r5, [r4, #0]
 1842 0006 EA05     		lsls	r2, r5, #23
 1843 0008 00F18B80 		bmi	.L188
 546:state.c       ****     return;
 547:state.c       **** 
 548:state.c       ****   if (bit_is_set(state.pos_status, POS_LLA_I)) {
 1844              		.loc 1 548 0
 1845 000c 2B07     		lsls	r3, r5, #28
 1846 000e 15D5     		bpl	.L190
 549:state.c       ****     LLA_FLOAT_OF_BFP(state.lla_pos_f, state.lla_pos_f);
 1847              		.loc 1 549 0
 1848 0010 D4F89000 		ldr	r0, [r4, #144]	@ float
 1849 0014 4449     		ldr	r1, .L201+4
 1850 0016 FFF7FEFF 		bl	__aeabi_fdiv
 1851              	.LVL204:
 1852 001a 4349     		ldr	r1, .L201+4
 1853 001c C4F89000 		str	r0, [r4, #144]	@ float
 1854 0020 D4F88C00 		ldr	r0, [r4, #140]	@ float
 1855 0024 FFF7FEFF 		bl	__aeabi_fdiv
 1856              	.LVL205:
 1857 0028 4049     		ldr	r1, .L201+8
 1858 002a C4F88C00 		str	r0, [r4, #140]	@ float
 1859 002e D4F89400 		ldr	r0, [r4, #148]	@ float
 1860 0032 FFF7FEFF 		bl	__aeabi_fdiv
 1861              	.LVL206:
 1862 0036 C4F89400 		str	r0, [r4, #148]	@ float
 1863 003a 6DE0     		b	.L191
 1864              	.L190:
 550:state.c       ****   }
 551:state.c       ****   else if (bit_is_set(state.pos_status, POS_ECEF_F)) {
 1865              		.loc 1 551 0
 1866 003c A806     		lsls	r0, r5, #26
 1867 003e 02D5     		bpl	.L192
 552:state.c       ****     lla_of_ecef_f(&state.lla_pos_f, &state.ecef_pos_f);
 1868              		.loc 1 552 0
 1869 0040 04F18C00 		add	r0, r4, #140
 1870 0044 27E0     		b	.L199
 1871              	.L192:
 553:state.c       ****   }
 554:state.c       ****   else if (bit_is_set(state.pos_status, POS_ECEF_I)) {
 1872              		.loc 1 554 0
 1873 0046 E907     		lsls	r1, r5, #31
 1874 0048 2AD5     		bpl	.L193
 555:state.c       ****     /* transform ecef_i -> ecef_f -> lla_f, set status bits */
 556:state.c       ****     ECEF_FLOAT_OF_BFP(state.ecef_pos_f, state.ecef_pos_i);
 1875              		.loc 1 556 0
 1876 004a 6068     		ldr	r0, [r4, #4]
 1877 004c FFF7FEFF 		bl	__aeabi_i2d
 1878              	.LVL207:
 1879 0050 0022     		movs	r2, #0
 1880 0052 374B     		ldr	r3, .L201+12
 1881 0054 FFF7FEFF 		bl	__aeabi_ddiv
 1882              	.LVL208:
 1883 0058 FFF7FEFF 		bl	__aeabi_d2f
 1884              	.LVL209:
 1885 005c C4F89800 		str	r0, [r4, #152]	@ float
 1886 0060 A068     		ldr	r0, [r4, #8]
 1887 0062 FFF7FEFF 		bl	__aeabi_i2d
 1888              	.LVL210:
 1889 0066 0022     		movs	r2, #0
 1890 0068 314B     		ldr	r3, .L201+12
 1891 006a FFF7FEFF 		bl	__aeabi_ddiv
 1892              	.LVL211:
 1893 006e FFF7FEFF 		bl	__aeabi_d2f
 1894              	.LVL212:
 1895 0072 C4F89C00 		str	r0, [r4, #156]	@ float
 1896 0076 E068     		ldr	r0, [r4, #12]
 1897 0078 FFF7FEFF 		bl	__aeabi_i2d
 1898              	.LVL213:
 1899 007c 0022     		movs	r2, #0
 1900 007e 2C4B     		ldr	r3, .L201+12
 1901 0080 FFF7FEFF 		bl	__aeabi_ddiv
 1902              	.LVL214:
 1903 0084 FFF7FEFF 		bl	__aeabi_d2f
 1904              	.LVL215:
 557:state.c       ****     SetBit(state.pos_status, POS_ECEF_F);
 1905              		.loc 1 557 0
 1906 0088 45F02005 		orr	r5, r5, #32
 556:state.c       ****     ECEF_FLOAT_OF_BFP(state.ecef_pos_f, state.ecef_pos_i);
 1907              		.loc 1 556 0
 1908 008c C4F8A000 		str	r0, [r4, #160]	@ float
 1909              		.loc 1 557 0
 1910 0090 2046     		mov	r0, r4
 1911 0092 20F88C5B 		strh	r5, [r0], #140	@ movhi
 1912              	.L199:
 558:state.c       ****     lla_of_ecef_f(&state.lla_pos_f, &state.ecef_pos_f);
 1913              		.loc 1 558 0
 1914 0096 04F19801 		add	r1, r4, #152
 1915 009a FFF7FEFF 		bl	lla_of_ecef_f
 1916              	.LVL216:
 1917 009e 3BE0     		b	.L191
 1918              	.L193:
 559:state.c       ****   }
 560:state.c       ****   else if (bit_is_set(state.pos_status, POS_NED_F)) {
 1919              		.loc 1 560 0
 1920 00a0 6A06     		lsls	r2, r5, #25
 1921 00a2 02D5     		bpl	.L194
 561:state.c       ****     /* transform ned_f -> ecef_f -> lla_f, set status bits */
 562:state.c       ****     ecef_of_ned_point_f(&state.ecef_pos_f, &state.ned_origin_f, &state.ned_pos_f);
 1922              		.loc 1 562 0
 1923 00a4 04F19800 		add	r0, r4, #152
 1924 00a8 21E0     		b	.L200
 1925              	.L194:
 563:state.c       ****     SetBit(state.pos_status, POS_ECEF_F);
 564:state.c       ****     lla_of_ecef_f(&state.lla_pos_f, &state.ecef_pos_f);
 565:state.c       ****   }
 566:state.c       ****   else if (bit_is_set(state.pos_status, POS_NED_I)) {
 1926              		.loc 1 566 0
 1927 00aa AB07     		lsls	r3, r5, #30
 1928 00ac 2CD5     		bpl	.L195
 567:state.c       ****     /* transform ned_i -> ned_f -> ecef_f -> lla_f, set status bits */
 568:state.c       ****     NED_FLOAT_OF_BFP(state.ned_pos_f, state.ned_pos_i);
 1929              		.loc 1 568 0
 1930 00ae 206E     		ldr	r0, [r4, #96]
 1931 00b0 FFF7FEFF 		bl	__aeabi_i2f
 1932              	.LVL217:
 1933 00b4 4FF06E51 		mov	r1, #998244352
 1934 00b8 FFF7FEFF 		bl	__aeabi_fmul
 1935              	.LVL218:
 1936 00bc C4F8FC00 		str	r0, [r4, #252]	@ float
 1937 00c0 606E     		ldr	r0, [r4, #100]
 1938 00c2 FFF7FEFF 		bl	__aeabi_i2f
 1939              	.LVL219:
 1940 00c6 4FF06E51 		mov	r1, #998244352
 1941 00ca FFF7FEFF 		bl	__aeabi_fmul
 1942              	.LVL220:
 1943 00ce C4F80001 		str	r0, [r4, #256]	@ float
 1944 00d2 A06E     		ldr	r0, [r4, #104]
 1945 00d4 FFF7FEFF 		bl	__aeabi_i2f
 1946              	.LVL221:
 1947 00d8 4FF06E51 		mov	r1, #998244352
 1948 00dc FFF7FEFF 		bl	__aeabi_fmul
 1949              	.LVL222:
 569:state.c       ****     SetBit(state.pos_status, POS_NED_F);
 1950              		.loc 1 569 0
 1951 00e0 45F04005 		orr	r5, r5, #64
 568:state.c       ****     NED_FLOAT_OF_BFP(state.ned_pos_f, state.ned_pos_i);
 1952              		.loc 1 568 0
 1953 00e4 C4F80401 		str	r0, [r4, #260]	@ float
 1954              		.loc 1 569 0
 1955 00e8 2046     		mov	r0, r4
 1956 00ea 20F8985B 		strh	r5, [r0], #152	@ movhi
 1957              	.L200:
 570:state.c       ****     ecef_of_ned_point_f(&state.ecef_pos_f, &state.ned_origin_f, &state.ned_pos_f);
 1958              		.loc 1 570 0
 1959 00ee 04F1A401 		add	r1, r4, #164
 1960 00f2 04F1FC02 		add	r2, r4, #252
 1961 00f6 FFF7FEFF 		bl	ecef_of_ned_point_f
 1962              	.LVL223:
 571:state.c       ****     SetBit(state.pos_status, POS_ECEF_F);
 1963              		.loc 1 571 0
 1964 00fa 2388     		ldrh	r3, [r4, #0]
 1965 00fc 2046     		mov	r0, r4
 1966 00fe 43F02001 		orr	r1, r3, #32
 1967 0102 20F88C1B 		strh	r1, [r0], #140	@ movhi
 1968 0106 C6E7     		b	.L199
 1969              	.L195:
 572:state.c       ****     lla_of_ecef_f(&state.lla_pos_f, &state.ecef_pos_f);
 573:state.c       ****   }
 574:state.c       ****   else if (bit_is_set(state.pos_status, POS_UTM_F)) {
 1970              		.loc 1 574 0
 1971 0108 A805     		lsls	r0, r5, #22
 1972 010a 05D5     		bpl	.L191
 575:state.c       ****     lla_of_utm_f(&state.lla_pos_f, &state.utm_pos_f);
 1973              		.loc 1 575 0
 1974 010c 04F18C00 		add	r0, r4, #140
 1975 0110 04F17801 		add	r1, r4, #120
 1976 0114 FFF7FEFF 		bl	lla_of_utm_f
 1977              	.LVL224:
 1978              	.L191:
 576:state.c       ****   }
 577:state.c       ****   else {
 578:state.c       ****     /* could not get this representation,  set errno */
 579:state.c       ****     //struct LlaCoor_f _lla_zero = {0.0};
 580:state.c       ****     //return _lla_zero;
 581:state.c       ****   }
 582:state.c       ****   /* set bit to indicate this representation is computed */
 583:state.c       ****   SetBit(state.pos_status, POS_LLA_F);
 1979              		.loc 1 583 0
 1980 0118 0248     		ldr	r0, .L201
 1981 011a 0288     		ldrh	r2, [r0, #0]
 1982 011c 42F48073 		orr	r3, r2, #256
 1983 0120 0380     		strh	r3, [r0, #0]	@ movhi
 1984              	.L188:
 1985 0122 38BD     		pop	{r3, r4, r5, pc}
 1986              	.L202:
 1987              		.align	2
 1988              	.L201:
 1989 0124 00000000 		.word	.LANCHOR0
 1990 0128 8096184B 		.word	1259902592
 1991 012c 00007A44 		.word	1148846080
 1992 0130 00005940 		.word	1079574528
 1993              		.cfi_endproc
 1994              	.LFE109:
 1996              		.section	.text.stateCalcSpeedNed_i,"ax",%progbits
 1997              		.align	1
 1998              		.global	stateCalcSpeedNed_i
 1999              		.thumb
 2000              		.thumb_func
 2002              	stateCalcSpeedNed_i:
 2003              	.LFB110:
 584:state.c       **** }
 585:state.c       **** /** @}*/
 586:state.c       **** 
 587:state.c       **** 
 588:state.c       **** 
 589:state.c       **** 
 590:state.c       **** 
 591:state.c       **** /******************************************************************************
 592:state.c       ****  *                                                                            *
 593:state.c       ****  * Transformation functions for the SPEED representations                     *
 594:state.c       ****  *                                                                            *
 595:state.c       ****  *****************************************************************************/
 596:state.c       **** /** @addtogroup state_velocity
 597:state.c       ****  *  @{ */
 598:state.c       **** /************************ Set functions ****************************/
 599:state.c       **** 
 600:state.c       **** void stateCalcSpeedNed_i(void) {
 2004              		.loc 1 600 0
 2005              		.cfi_startproc
 2006              		@ args = 0, pretend = 0, frame = 0
 2007              		@ frame_needed = 0, uses_anonymous_args = 0
 2008 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 2009              	.LCFI9:
 2010              		.cfi_def_cfa_offset 24
 2011              		.cfi_offset 3, -24
 2012              		.cfi_offset 4, -20
 2013              		.cfi_offset 5, -16
 2014              		.cfi_offset 6, -12
 2015              		.cfi_offset 7, -8
 2016              		.cfi_offset 14, -4
 601:state.c       ****   if (bit_is_set(state.speed_status, SPEED_NED_I))
 2017              		.loc 1 601 0
 2018 0002 534C     		ldr	r4, .L227
 2019 0004 B4F81451 		ldrh	r5, [r4, #276]
 2020 0008 A907     		lsls	r1, r5, #30
 2021 000a 00F1A080 		bmi	.L203
 2022              	.LVL225:
 602:state.c       ****     return;
 603:state.c       **** 
 604:state.c       ****   int errno = 0;
 605:state.c       ****   if (state.ned_initialized_i) {
 2023              		.loc 1 605 0
 2024 000e 94F85C30 		ldrb	r3, [r4, #92]	@ zero_extendqisi2
 2025 0012 ABB3     		cbz	r3, .L205
 606:state.c       ****     if (bit_is_set(state.speed_status, SPEED_NED_F)) {
 2026              		.loc 1 606 0
 2027 0014 6A06     		lsls	r2, r5, #25
 2028 0016 39D4     		bmi	.L226
 2029              	.L206:
 607:state.c       ****       SPEEDS_BFP_OF_REAL(state.ned_speed_i, state.ned_speed_f);
 608:state.c       ****     }
 609:state.c       ****     else if (bit_is_set(state.speed_status, SPEED_ENU_I)) {
 2030              		.loc 1 609 0
 2031 0018 6B07     		lsls	r3, r5, #29
 2032 001a 56D4     		bmi	.L223
 2033              	.L208:
 610:state.c       ****       INT32_VECT3_NED_OF_ENU(state.ned_speed_i, state.enu_speed_i);
 611:state.c       ****     }
 612:state.c       ****     else if (bit_is_set(state.speed_status, SPEED_ENU_F)) {
 2034              		.loc 1 612 0
 2035 001c 2806     		lsls	r0, r5, #24
 2036 001e 64D4     		bmi	.L224
 2037              	.L209:
 613:state.c       ****       SPEEDS_BFP_OF_REAL(state.enu_speed_i, state.enu_speed_f);
 614:state.c       ****       SetBit(state.speed_status, SPEED_ENU_I);
 615:state.c       ****       INT32_VECT3_NED_OF_ENU(state.ned_speed_i, state.enu_speed_i);
 616:state.c       ****     }
 617:state.c       ****     else if (bit_is_set(state.speed_status, SPEED_ECEF_I)) {
 2038              		.loc 1 617 0
 2039 0020 E907     		lsls	r1, r5, #31
 2040 0022 24D4     		bmi	.L225
 2041              	.L210:
 618:state.c       ****       ned_of_ecef_vect_i(&state.ned_speed_i, &state.ned_origin_i, &state.ecef_speed_i);
 619:state.c       ****     }
 620:state.c       ****     else if (bit_is_set(state.speed_status, SPEED_ECEF_F)) {
 2042              		.loc 1 620 0
 2043 0024 AA06     		lsls	r2, r5, #26
 2044 0026 40F18B80 		bpl	.L207
 621:state.c       ****       /* transform ecef_f -> ecef_i -> ned_i , set status bits */
 622:state.c       ****       SPEEDS_BFP_OF_REAL(state.ecef_speed_i, state.ecef_speed_f);
 2045              		.loc 1 622 0
 2046 002a 4FF09241 		mov	r1, #1224736768
 2047 002e D4F84401 		ldr	r0, [r4, #324]	@ float
 2048 0032 FFF7FEFF 		bl	__aeabi_fmul
 2049              	.LVL226:
 2050 0036 FFF7FEFF 		bl	__aeabi_f2iz
 2051              	.LVL227:
 2052 003a 4FF09241 		mov	r1, #1224736768
 2053 003e C4F81801 		str	r0, [r4, #280]
 2054 0042 D4F84801 		ldr	r0, [r4, #328]	@ float
 2055 0046 FFF7FEFF 		bl	__aeabi_fmul
 2056              	.LVL228:
 2057 004a FFF7FEFF 		bl	__aeabi_f2iz
 2058              	.LVL229:
 2059 004e 4FF09241 		mov	r1, #1224736768
 2060 0052 C4F81C01 		str	r0, [r4, #284]
 2061 0056 D4F84C01 		ldr	r0, [r4, #332]	@ float
 2062 005a FFF7FEFF 		bl	__aeabi_fmul
 2063              	.LVL230:
 2064 005e FFF7FEFF 		bl	__aeabi_f2iz
 2065              	.LVL231:
 623:state.c       ****       SetBit(state.speed_status, SPEED_ECEF_I);
 2066              		.loc 1 623 0
 2067 0062 45F00105 		orr	r5, r5, #1
 622:state.c       ****       SPEEDS_BFP_OF_REAL(state.ecef_speed_i, state.ecef_speed_f);
 2068              		.loc 1 622 0
 2069 0066 C4F82001 		str	r0, [r4, #288]
 2070              		.loc 1 623 0
 2071 006a A4F81451 		strh	r5, [r4, #276]	@ movhi
 2072              	.L225:
 624:state.c       ****       ned_of_ecef_vect_i(&state.ned_speed_i, &state.ned_origin_i, &state.ecef_speed_i);
 2073              		.loc 1 624 0
 2074 006e 04F59270 		add	r0, r4, #292
 2075 0072 04F11C01 		add	r1, r4, #28
 2076 0076 04F58C72 		add	r2, r4, #280
 2077 007a FFF7FEFF 		bl	ned_of_ecef_vect_i
 2078              	.LVL232:
 2079 007e 5FE0     		b	.L207
 2080              	.L205:
 625:state.c       ****     }
 626:state.c       ****     else { /* could not get this representation,  set errno */
 627:state.c       ****       errno = 1;
 628:state.c       ****     }
 629:state.c       ****   }
 630:state.c       ****   else if (state.utm_initialized_f) {
 2081              		.loc 1 630 0
 2082 0080 94F8F800 		ldrb	r0, [r4, #248]	@ zero_extendqisi2
 2083 0084 0028     		cmp	r0, #0
 2084 0086 5BD0     		beq	.L207
 631:state.c       ****     if (bit_is_set(state.speed_status, SPEED_NED_F)) {
 2085              		.loc 1 631 0
 2086 0088 6B06     		lsls	r3, r5, #25
 2087 008a 1CD5     		bpl	.L211
 2088              	.L226:
 632:state.c       ****       SPEEDS_BFP_OF_REAL(state.ned_speed_i, state.ned_speed_f);
 2089              		.loc 1 632 0
 2090 008c 4FF09241 		mov	r1, #1224736768
 2091 0090 D4F85001 		ldr	r0, [r4, #336]	@ float
 2092 0094 FFF7FEFF 		bl	__aeabi_fmul
 2093              	.LVL233:
 2094 0098 FFF7FEFF 		bl	__aeabi_f2iz
 2095              	.LVL234:
 2096 009c 4FF09241 		mov	r1, #1224736768
 2097 00a0 C4F82401 		str	r0, [r4, #292]
 2098 00a4 D4F85401 		ldr	r0, [r4, #340]	@ float
 2099 00a8 FFF7FEFF 		bl	__aeabi_fmul
 2100              	.LVL235:
 2101 00ac FFF7FEFF 		bl	__aeabi_f2iz
 2102              	.LVL236:
 2103 00b0 4FF09241 		mov	r1, #1224736768
 2104 00b4 C4F82801 		str	r0, [r4, #296]
 2105 00b8 D4F85801 		ldr	r0, [r4, #344]	@ float
 2106 00bc FFF7FEFF 		bl	__aeabi_fmul
 2107              	.LVL237:
 2108 00c0 FFF7FEFF 		bl	__aeabi_f2iz
 2109              	.LVL238:
 2110 00c4 3AE0     		b	.L222
 2111              	.L211:
 633:state.c       ****     }
 634:state.c       ****     else if (bit_is_set(state.speed_status, SPEED_ENU_I)) {
 2112              		.loc 1 634 0
 2113 00c6 6807     		lsls	r0, r5, #29
 2114 00c8 0DD5     		bpl	.L212
 2115              	.L223:
 635:state.c       ****       INT32_VECT3_NED_OF_ENU(state.ned_speed_i, state.enu_speed_i);
 2116              		.loc 1 635 0
 2117 00ca D4F83831 		ldr	r3, [r4, #312]
 2118 00ce D4F83411 		ldr	r1, [r4, #308]
 2119 00d2 D4F83021 		ldr	r2, [r4, #304]
 2120 00d6 5842     		negs	r0, r3
 2121 00d8 C4F82411 		str	r1, [r4, #292]
 2122 00dc C4F82821 		str	r2, [r4, #296]
 2123 00e0 C4F82C01 		str	r0, [r4, #300]
 2124 00e4 2CE0     		b	.L207
 2125              	.L212:
 636:state.c       ****     }
 637:state.c       ****     else if (bit_is_set(state.speed_status, SPEED_ENU_F)) {
 2126              		.loc 1 637 0
 2127 00e6 2906     		lsls	r1, r5, #24
 2128 00e8 2AD5     		bpl	.L207
 2129              	.L224:
 638:state.c       ****       SPEEDS_BFP_OF_REAL(state.enu_speed_i, state.enu_speed_f);
 2130              		.loc 1 638 0
 2131 00ea 4FF09241 		mov	r1, #1224736768
 2132 00ee D4F85C01 		ldr	r0, [r4, #348]	@ float
 2133 00f2 FFF7FEFF 		bl	__aeabi_fmul
 2134              	.LVL239:
 2135 00f6 FFF7FEFF 		bl	__aeabi_f2iz
 2136              	.LVL240:
 2137 00fa 4FF09241 		mov	r1, #1224736768
 2138 00fe 0646     		mov	r6, r0
 2139 0100 C4F83001 		str	r0, [r4, #304]
 2140 0104 D4F86001 		ldr	r0, [r4, #352]	@ float
 2141 0108 FFF7FEFF 		bl	__aeabi_fmul
 2142              	.LVL241:
 2143 010c FFF7FEFF 		bl	__aeabi_f2iz
 2144              	.LVL242:
 2145 0110 4FF09241 		mov	r1, #1224736768
 2146 0114 0746     		mov	r7, r0
 2147 0116 C4F83401 		str	r0, [r4, #308]
 2148 011a D4F86401 		ldr	r0, [r4, #356]	@ float
 2149 011e FFF7FEFF 		bl	__aeabi_fmul
 2150              	.LVL243:
 2151 0122 FFF7FEFF 		bl	__aeabi_f2iz
 2152              	.LVL244:
 639:state.c       ****       SetBit(state.speed_status, SPEED_ENU_I);
 2153              		.loc 1 639 0
 2154 0126 45F00405 		orr	r5, r5, #4
 638:state.c       ****       SPEEDS_BFP_OF_REAL(state.enu_speed_i, state.enu_speed_f);
 2155              		.loc 1 638 0
 2156 012a C4F83801 		str	r0, [r4, #312]
 2157              		.loc 1 639 0
 2158 012e A4F81451 		strh	r5, [r4, #276]	@ movhi
 640:state.c       ****       INT32_VECT3_NED_OF_ENU(state.ned_speed_i, state.enu_speed_i);
 2159              		.loc 1 640 0
 2160 0132 C4F82471 		str	r7, [r4, #292]
 2161 0136 C4F82861 		str	r6, [r4, #296]
 2162 013a 4042     		negs	r0, r0
 2163              	.L222:
 2164 013c C4F82C01 		str	r0, [r4, #300]
 2165              	.L207:
 641:state.c       ****     }
 642:state.c       ****     else { /* could not get this representation,  set errno */
 643:state.c       ****       errno = 2;
 644:state.c       ****     }
 645:state.c       ****   }
 646:state.c       ****   else { /* ned coordinate system not initialized,  set errno */
 647:state.c       ****     errno = 3;
 648:state.c       ****   }
 649:state.c       ****   if (errno) {
 650:state.c       ****     //struct NedCoor_i _ned_zero = {0};
 651:state.c       ****     //return _ned_zero;
 652:state.c       ****   }
 653:state.c       ****   /* set bit to indicate this representation is computed */
 654:state.c       ****   SetBit(state.speed_status, SPEED_NED_I);
 2166              		.loc 1 654 0
 2167 0140 0349     		ldr	r1, .L227
 2168 0142 B1F81421 		ldrh	r2, [r1, #276]
 2169 0146 42F00203 		orr	r3, r2, #2
 2170 014a A1F81431 		strh	r3, [r1, #276]	@ movhi
 2171              	.LVL245:
 2172              	.L203:
 2173 014e F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 2174              	.L228:
 2175              		.align	2
 2176              	.L227:
 2177 0150 00000000 		.word	.LANCHOR0
 2178              		.cfi_endproc
 2179              	.LFE110:
 2181              		.section	.text.stateCalcSpeedEnu_i,"ax",%progbits
 2182              		.align	1
 2183              		.global	stateCalcSpeedEnu_i
 2184              		.thumb
 2185              		.thumb_func
 2187              	stateCalcSpeedEnu_i:
 2188              	.LFB111:
 655:state.c       **** }
 656:state.c       **** 
 657:state.c       **** void stateCalcSpeedEnu_i(void) {
 2189              		.loc 1 657 0
 2190              		.cfi_startproc
 2191              		@ args = 0, pretend = 0, frame = 0
 2192              		@ frame_needed = 0, uses_anonymous_args = 0
 658:state.c       ****   if (bit_is_set(state.speed_status, SPEED_ENU_I))
 2193              		.loc 1 658 0
 2194 0000 5C4B     		ldr	r3, .L257
 657:state.c       **** void stateCalcSpeedEnu_i(void) {
 2195              		.loc 1 657 0
 2196 0002 70B5     		push	{r4, r5, r6, lr}
 2197              	.LCFI10:
 2198              		.cfi_def_cfa_offset 16
 2199              		.cfi_offset 4, -16
 2200              		.cfi_offset 5, -12
 2201              		.cfi_offset 6, -8
 2202              		.cfi_offset 14, -4
 2203              		.loc 1 658 0
 2204 0004 B3F81451 		ldrh	r5, [r3, #276]
 2205 0008 6A07     		lsls	r2, r5, #29
 2206 000a 00F1B180 		bmi	.L229
 2207              	.LVL246:
 659:state.c       ****     return;
 660:state.c       **** 
 661:state.c       ****   int errno = 0;
 662:state.c       ****   if (state.ned_initialized_i) {
 2208              		.loc 1 662 0
 2209 000e 93F85C20 		ldrb	r2, [r3, #92]	@ zero_extendqisi2
 2210 0012 002A     		cmp	r2, #0
 2211 0014 44D0     		beq	.L231
 663:state.c       ****     if (bit_is_set(state.speed_status, SPEED_NED_I)) {
 2212              		.loc 1 663 0
 2213 0016 A807     		lsls	r0, r5, #30
 2214 0018 0CD5     		bpl	.L232
 664:state.c       ****       INT32_VECT3_ENU_OF_NED(state.enu_speed_i, state.ned_speed_i);
 2215              		.loc 1 664 0
 2216 001a D3F82C21 		ldr	r2, [r3, #300]
 2217 001e D3F82811 		ldr	r1, [r3, #296]
 2218 0022 D3F82441 		ldr	r4, [r3, #292]
 2219 0026 5042     		negs	r0, r2
 2220 0028 C3F83011 		str	r1, [r3, #304]
 2221 002c C3F83441 		str	r4, [r3, #308]
 2222 0030 C3F83801 		str	r0, [r3, #312]
 2223              	.L232:
 665:state.c       ****     }
 666:state.c       ****     if (bit_is_set(state.speed_status, SPEED_ENU_F)) {
 2224              		.loc 1 666 0
 2225 0034 15F0800F 		tst	r5, #128
 2226 0038 4E4C     		ldr	r4, .L257
 2227 003a 48D1     		bne	.L256
 2228              	.L233:
 667:state.c       ****       ENU_BFP_OF_REAL(state.enu_speed_i, state.enu_speed_f);
 668:state.c       ****     }
 669:state.c       ****     else if (bit_is_set(state.speed_status, SPEED_NED_F)) {
 2229              		.loc 1 669 0
 2230 003c 6906     		lsls	r1, r5, #25
 2231 003e 65D4     		bmi	.L254
 2232              	.L235:
 670:state.c       ****       SPEEDS_BFP_OF_REAL(state.ned_speed_i, state.ned_speed_f);
 671:state.c       ****       SetBit(state.pos_status, SPEED_NED_I);
 672:state.c       ****       INT32_VECT3_ENU_OF_NED(state.enu_speed_i, state.ned_speed_i);
 673:state.c       ****     }
 674:state.c       ****     else if (bit_is_set(state.speed_status, SPEED_ECEF_I)) {
 2233              		.loc 1 674 0
 2234 0040 EA07     		lsls	r2, r5, #31
 2235 0042 24D4     		bmi	.L255
 2236              	.L236:
 675:state.c       ****       enu_of_ecef_vect_i(&state.enu_speed_i, &state.ned_origin_i, &state.ecef_speed_i);
 676:state.c       ****     }
 677:state.c       ****     else if (bit_is_set(state.speed_status, SPEED_ECEF_F)) {
 2237              		.loc 1 677 0
 2238 0044 AB06     		lsls	r3, r5, #26
 2239 0046 40F18C80 		bpl	.L234
 678:state.c       ****       /* transform ecef_f -> ecef_i -> enu_i , set status bits */
 679:state.c       ****       SPEEDS_BFP_OF_REAL(state.ecef_speed_i, state.ecef_speed_f);
 2240              		.loc 1 679 0
 2241 004a 4FF09241 		mov	r1, #1224736768
 2242 004e D4F84401 		ldr	r0, [r4, #324]	@ float
 2243 0052 FFF7FEFF 		bl	__aeabi_fmul
 2244              	.LVL247:
 2245 0056 FFF7FEFF 		bl	__aeabi_f2iz
 2246              	.LVL248:
 2247 005a 4FF09241 		mov	r1, #1224736768
 2248 005e C4F81801 		str	r0, [r4, #280]
 2249 0062 D4F84801 		ldr	r0, [r4, #328]	@ float
 2250 0066 FFF7FEFF 		bl	__aeabi_fmul
 2251              	.LVL249:
 2252 006a FFF7FEFF 		bl	__aeabi_f2iz
 2253              	.LVL250:
 2254 006e 4FF09241 		mov	r1, #1224736768
 2255 0072 C4F81C01 		str	r0, [r4, #284]
 2256 0076 D4F84C01 		ldr	r0, [r4, #332]	@ float
 2257 007a FFF7FEFF 		bl	__aeabi_fmul
 2258              	.LVL251:
 2259 007e FFF7FEFF 		bl	__aeabi_f2iz
 2260              	.LVL252:
 680:state.c       ****       SetBit(state.speed_status, SPEED_ECEF_I);
 2261              		.loc 1 680 0
 2262 0082 45F00105 		orr	r5, r5, #1
 679:state.c       ****       SPEEDS_BFP_OF_REAL(state.ecef_speed_i, state.ecef_speed_f);
 2263              		.loc 1 679 0
 2264 0086 C4F82001 		str	r0, [r4, #288]
 2265              		.loc 1 680 0
 2266 008a A4F81451 		strh	r5, [r4, #276]	@ movhi
 2267              	.L255:
 681:state.c       ****       enu_of_ecef_vect_i(&state.enu_speed_i, &state.ned_origin_i, &state.ecef_speed_i);
 2268              		.loc 1 681 0
 2269 008e 04F59870 		add	r0, r4, #304
 2270 0092 04F11C01 		add	r1, r4, #28
 2271 0096 04F58C72 		add	r2, r4, #280
 2272 009a FFF7FEFF 		bl	enu_of_ecef_vect_i
 2273              	.LVL253:
 2274 009e 60E0     		b	.L234
 2275              	.L231:
 682:state.c       ****     }
 683:state.c       ****     else { /* could not get this representation,  set errno */
 684:state.c       ****       errno = 1;
 685:state.c       ****     }
 686:state.c       ****   }
 687:state.c       ****   else if (state.utm_initialized_f) {
 2276              		.loc 1 687 0
 2277 00a0 93F8F800 		ldrb	r0, [r3, #248]	@ zero_extendqisi2
 2278 00a4 0028     		cmp	r0, #0
 2279 00a6 5CD0     		beq	.L234
 688:state.c       ****     if (bit_is_set(state.speed_status, SPEED_NED_I)) {
 2280              		.loc 1 688 0
 2281 00a8 AC07     		lsls	r4, r5, #30
 2282 00aa 0CD5     		bpl	.L239
 689:state.c       ****       INT32_VECT3_ENU_OF_NED(state.enu_speed_i, state.ned_speed_i);
 2283              		.loc 1 689 0
 2284 00ac D3F82C21 		ldr	r2, [r3, #300]
 2285 00b0 D3F82811 		ldr	r1, [r3, #296]
 2286 00b4 D3F82441 		ldr	r4, [r3, #292]
 2287 00b8 5042     		negs	r0, r2
 2288 00ba C3F83011 		str	r1, [r3, #304]
 2289 00be C3F83441 		str	r4, [r3, #308]
 2290 00c2 C3F83801 		str	r0, [r3, #312]
 2291              	.L239:
 690:state.c       ****     }
 691:state.c       ****     if (bit_is_set(state.speed_status, SPEED_ENU_F)) {
 2292              		.loc 1 691 0
 2293 00c6 15F0800F 		tst	r5, #128
 2294 00ca 2A4C     		ldr	r4, .L257
 2295 00cc 1CD0     		beq	.L240
 2296              	.L256:
 692:state.c       ****       ENU_BFP_OF_REAL(state.enu_speed_i, state.enu_speed_f);
 2297              		.loc 1 692 0
 2298 00ce 4FF08741 		mov	r1, #1132462080
 2299 00d2 D4F85C01 		ldr	r0, [r4, #348]	@ float
 2300 00d6 FFF7FEFF 		bl	__aeabi_fmul
 2301              	.LVL254:
 2302 00da FFF7FEFF 		bl	__aeabi_f2iz
 2303              	.LVL255:
 2304 00de 4FF08741 		mov	r1, #1132462080
 2305 00e2 C4F83001 		str	r0, [r4, #304]
 2306 00e6 D4F86001 		ldr	r0, [r4, #352]	@ float
 2307 00ea FFF7FEFF 		bl	__aeabi_fmul
 2308              	.LVL256:
 2309 00ee FFF7FEFF 		bl	__aeabi_f2iz
 2310              	.LVL257:
 2311 00f2 4FF08741 		mov	r1, #1132462080
 2312 00f6 C4F83401 		str	r0, [r4, #308]
 2313 00fa D4F86401 		ldr	r0, [r4, #356]	@ float
 2314 00fe FFF7FEFF 		bl	__aeabi_fmul
 2315              	.LVL258:
 2316 0102 FFF7FEFF 		bl	__aeabi_f2iz
 2317              	.LVL259:
 2318 0106 2AE0     		b	.L253
 2319              	.L240:
 693:state.c       ****     }
 694:state.c       ****     else if (bit_is_set(state.speed_status, SPEED_NED_F)) {
 2320              		.loc 1 694 0
 2321 0108 6806     		lsls	r0, r5, #25
 2322 010a 2AD5     		bpl	.L234
 2323              	.L254:
 695:state.c       ****       SPEEDS_BFP_OF_REAL(state.ned_speed_i, state.ned_speed_f);
 2324              		.loc 1 695 0
 2325 010c 4FF09241 		mov	r1, #1224736768
 2326 0110 D4F85001 		ldr	r0, [r4, #336]	@ float
 2327 0114 FFF7FEFF 		bl	__aeabi_fmul
 2328              	.LVL260:
 2329 0118 FFF7FEFF 		bl	__aeabi_f2iz
 2330              	.LVL261:
 2331 011c 4FF09241 		mov	r1, #1224736768
 2332 0120 0546     		mov	r5, r0
 2333 0122 C4F82401 		str	r0, [r4, #292]
 2334 0126 D4F85401 		ldr	r0, [r4, #340]	@ float
 2335 012a FFF7FEFF 		bl	__aeabi_fmul
 2336              	.LVL262:
 2337 012e FFF7FEFF 		bl	__aeabi_f2iz
 2338              	.LVL263:
 2339 0132 4FF09241 		mov	r1, #1224736768
 2340 0136 0646     		mov	r6, r0
 2341 0138 C4F82801 		str	r0, [r4, #296]
 2342 013c D4F85801 		ldr	r0, [r4, #344]	@ float
 2343 0140 FFF7FEFF 		bl	__aeabi_fmul
 2344              	.LVL264:
 2345 0144 FFF7FEFF 		bl	__aeabi_f2iz
 2346              	.LVL265:
 696:state.c       ****       SetBit(state.pos_status, SPEED_NED_I);
 2347              		.loc 1 696 0
 2348 0148 2388     		ldrh	r3, [r4, #0]
 695:state.c       ****       SPEEDS_BFP_OF_REAL(state.ned_speed_i, state.ned_speed_f);
 2349              		.loc 1 695 0
 2350 014a C4F82C01 		str	r0, [r4, #300]
 2351              		.loc 1 696 0
 2352 014e 43F00201 		orr	r1, r3, #2
 2353 0152 2180     		strh	r1, [r4, #0]	@ movhi
 697:state.c       ****       INT32_VECT3_ENU_OF_NED(state.enu_speed_i, state.ned_speed_i);
 2354              		.loc 1 697 0
 2355 0154 C4F83061 		str	r6, [r4, #304]
 2356 0158 C4F83451 		str	r5, [r4, #308]
 2357 015c 4042     		negs	r0, r0
 2358              	.L253:
 2359 015e C4F83801 		str	r0, [r4, #312]
 2360              	.L234:
 698:state.c       ****     }
 699:state.c       ****     else { /* could not get this representation,  set errno */
 700:state.c       ****       errno = 2;
 701:state.c       ****     }
 702:state.c       ****   }
 703:state.c       ****   else { /* ned coordinate system not initialized,  set errno */
 704:state.c       ****     errno = 3;
 705:state.c       ****   }
 706:state.c       ****   if (errno) {
 707:state.c       ****     //struct EnuCoor_i _enu_zero = {0};
 708:state.c       ****     //return _enu_zero;
 709:state.c       ****   }
 710:state.c       ****   /* set bit to indicate this representation is computed */
 711:state.c       ****   SetBit(state.speed_status, SPEED_ENU_I);
 2361              		.loc 1 711 0
 2362 0162 0448     		ldr	r0, .L257
 2363 0164 B0F81421 		ldrh	r2, [r0, #276]
 2364 0168 42F00403 		orr	r3, r2, #4
 2365 016c A0F81431 		strh	r3, [r0, #276]	@ movhi
 2366              	.LVL266:
 2367              	.L229:
 2368 0170 70BD     		pop	{r4, r5, r6, pc}
 2369              	.L258:
 2370 0172 00BF     		.align	2
 2371              	.L257:
 2372 0174 00000000 		.word	.LANCHOR0
 2373              		.cfi_endproc
 2374              	.LFE111:
 2376              		.section	.text.stateCalcSpeedEcef_i,"ax",%progbits
 2377              		.align	1
 2378              		.global	stateCalcSpeedEcef_i
 2379              		.thumb
 2380              		.thumb_func
 2382              	stateCalcSpeedEcef_i:
 2383              	.LFB112:
 712:state.c       **** }
 713:state.c       **** 
 714:state.c       **** void stateCalcSpeedEcef_i(void) {
 2384              		.loc 1 714 0
 2385              		.cfi_startproc
 2386              		@ args = 0, pretend = 0, frame = 0
 2387              		@ frame_needed = 0, uses_anonymous_args = 0
 2388 0000 38B5     		push	{r3, r4, r5, lr}
 2389              	.LCFI11:
 2390              		.cfi_def_cfa_offset 16
 2391              		.cfi_offset 3, -16
 2392              		.cfi_offset 4, -12
 2393              		.cfi_offset 5, -8
 2394              		.cfi_offset 14, -4
 715:state.c       ****   if (bit_is_set(state.speed_status, SPEED_ECEF_I))
 2395              		.loc 1 715 0
 2396 0002 2E4C     		ldr	r4, .L268
 2397 0004 B4F81451 		ldrh	r5, [r4, #276]
 2398 0008 EA07     		lsls	r2, r5, #31
 2399 000a 55D4     		bmi	.L259
 716:state.c       ****     return;
 717:state.c       **** 
 718:state.c       ****   if (bit_is_set(state.speed_status, SPEED_ECEF_F)) {
 2400              		.loc 1 718 0
 2401 000c AB06     		lsls	r3, r5, #26
 2402 000e 1ED5     		bpl	.L261
 719:state.c       ****     SPEEDS_BFP_OF_REAL(state.ecef_speed_i, state.ecef_speed_f);
 2403              		.loc 1 719 0
 2404 0010 4FF09241 		mov	r1, #1224736768
 2405 0014 D4F84401 		ldr	r0, [r4, #324]	@ float
 2406 0018 FFF7FEFF 		bl	__aeabi_fmul
 2407              	.LVL267:
 2408 001c FFF7FEFF 		bl	__aeabi_f2iz
 2409              	.LVL268:
 2410 0020 4FF09241 		mov	r1, #1224736768
 2411 0024 C4F81801 		str	r0, [r4, #280]
 2412 0028 D4F84801 		ldr	r0, [r4, #328]	@ float
 2413 002c FFF7FEFF 		bl	__aeabi_fmul
 2414              	.LVL269:
 2415 0030 FFF7FEFF 		bl	__aeabi_f2iz
 2416              	.LVL270:
 2417 0034 4FF09241 		mov	r1, #1224736768
 2418 0038 C4F81C01 		str	r0, [r4, #284]
 2419 003c D4F84C01 		ldr	r0, [r4, #332]	@ float
 2420 0040 FFF7FEFF 		bl	__aeabi_fmul
 2421              	.LVL271:
 2422 0044 FFF7FEFF 		bl	__aeabi_f2iz
 2423              	.LVL272:
 2424 0048 C4F82001 		str	r0, [r4, #288]
 2425 004c 2DE0     		b	.L262
 2426              	.L261:
 720:state.c       ****   }
 721:state.c       ****   else if (bit_is_set(state.speed_status, SPEED_NED_I)) {
 2427              		.loc 1 721 0
 2428 004e A807     		lsls	r0, r5, #30
 2429 0050 23D4     		bmi	.L267
 2430              	.L263:
 722:state.c       ****     ecef_of_ned_vect_i(&state.ecef_speed_i, &state.ned_origin_i, &state.ned_speed_i);
 723:state.c       ****   }
 724:state.c       ****   else if (bit_is_set(state.speed_status, SPEED_NED_F)) {
 2431              		.loc 1 724 0
 2432 0052 6906     		lsls	r1, r5, #25
 2433 0054 29D5     		bpl	.L262
 725:state.c       ****     /* transform ned_f -> ned_i -> ecef_i , set status bits */
 726:state.c       ****     SPEEDS_BFP_OF_REAL(state.ned_speed_i, state.ned_speed_f);
 2434              		.loc 1 726 0
 2435 0056 4FF09241 		mov	r1, #1224736768
 2436 005a D4F85001 		ldr	r0, [r4, #336]	@ float
 2437 005e FFF7FEFF 		bl	__aeabi_fmul
 2438              	.LVL273:
 2439 0062 FFF7FEFF 		bl	__aeabi_f2iz
 2440              	.LVL274:
 2441 0066 4FF09241 		mov	r1, #1224736768
 2442 006a C4F82401 		str	r0, [r4, #292]
 2443 006e D4F85401 		ldr	r0, [r4, #340]	@ float
 2444 0072 FFF7FEFF 		bl	__aeabi_fmul
 2445              	.LVL275:
 2446 0076 FFF7FEFF 		bl	__aeabi_f2iz
 2447              	.LVL276:
 2448 007a 4FF09241 		mov	r1, #1224736768
 2449 007e C4F82801 		str	r0, [r4, #296]
 2450 0082 D4F85801 		ldr	r0, [r4, #344]	@ float
 2451 0086 FFF7FEFF 		bl	__aeabi_fmul
 2452              	.LVL277:
 2453 008a FFF7FEFF 		bl	__aeabi_f2iz
 2454              	.LVL278:
 727:state.c       ****     SetBit(state.speed_status, SPEED_NED_I);
 2455              		.loc 1 727 0
 2456 008e 45F00205 		orr	r5, r5, #2
 726:state.c       ****     SPEEDS_BFP_OF_REAL(state.ned_speed_i, state.ned_speed_f);
 2457              		.loc 1 726 0
 2458 0092 C4F82C01 		str	r0, [r4, #300]
 2459              		.loc 1 727 0
 2460 0096 A4F81451 		strh	r5, [r4, #276]	@ movhi
 2461              	.L267:
 728:state.c       ****     ecef_of_ned_vect_i(&state.ecef_speed_i, &state.ned_origin_i, &state.ned_speed_i);
 2462              		.loc 1 728 0
 2463 009a 04F58C70 		add	r0, r4, #280
 2464 009e 04F11C01 		add	r1, r4, #28
 2465 00a2 04F59272 		add	r2, r4, #292
 2466 00a6 FFF7FEFF 		bl	ecef_of_ned_vect_i
 2467              	.LVL279:
 2468              	.L262:
 729:state.c       ****   }
 730:state.c       ****   else {
 731:state.c       ****     /* could not get this representation,  set errno */
 732:state.c       ****     //struct EcefCoor_i _ecef_zero = {0};
 733:state.c       ****     //return _ecef_zero;
 734:state.c       ****   }
 735:state.c       ****   /* set bit to indicate this representation is computed */
 736:state.c       ****   SetBit(state.speed_status, SPEED_ECEF_I);
 2469              		.loc 1 736 0
 2470 00aa 044B     		ldr	r3, .L268
 2471 00ac B3F81421 		ldrh	r2, [r3, #276]
 2472 00b0 42F00100 		orr	r0, r2, #1
 2473 00b4 A3F81401 		strh	r0, [r3, #276]	@ movhi
 2474              	.L259:
 2475 00b8 38BD     		pop	{r3, r4, r5, pc}
 2476              	.L269:
 2477 00ba 00BF     		.align	2
 2478              	.L268:
 2479 00bc 00000000 		.word	.LANCHOR0
 2480              		.cfi_endproc
 2481              	.LFE112:
 2483              		.global	__aeabi_fadd
 2484              		.section	.text.stateCalcHorizontalSpeedNorm_i,"ax",%progbits
 2485              		.align	1
 2486              		.global	stateCalcHorizontalSpeedNorm_i
 2487              		.thumb
 2488              		.thumb_func
 2490              	stateCalcHorizontalSpeedNorm_i:
 2491              	.LFB113:
 737:state.c       **** }
 738:state.c       **** 
 739:state.c       **** void stateCalcHorizontalSpeedNorm_i(void) {
 2492              		.loc 1 739 0
 2493              		.cfi_startproc
 2494              		@ args = 0, pretend = 0, frame = 0
 2495              		@ frame_needed = 0, uses_anonymous_args = 0
 2496 0000 70B5     		push	{r4, r5, r6, lr}
 2497              	.LCFI12:
 2498              		.cfi_def_cfa_offset 16
 2499              		.cfi_offset 4, -16
 2500              		.cfi_offset 5, -12
 2501              		.cfi_offset 6, -8
 2502              		.cfi_offset 14, -4
 740:state.c       ****   if (bit_is_set(state.speed_status, SPEED_HNORM_I))
 2503              		.loc 1 740 0
 2504 0002 584C     		ldr	r4, .L302
 2505 0004 B4F81431 		ldrh	r3, [r4, #276]
 2506 0008 1807     		lsls	r0, r3, #28
 2507 000a 00F1AA80 		bmi	.L270
 741:state.c       ****     return;
 742:state.c       **** 
 743:state.c       ****   if (bit_is_set(state.speed_status, SPEED_HNORM_F)){
 2508              		.loc 1 743 0
 2509 000e D905     		lsls	r1, r3, #23
 2510 0010 02D5     		bpl	.L272
 744:state.c       ****     state.h_speed_norm_i = SPEED_BFP_OF_REAL(state.h_speed_norm_f);
 2511              		.loc 1 744 0
 2512 0012 D4F86801 		ldr	r0, [r4, #360]	@ float
 2513 0016 95E0     		b	.L300
 2514              	.L272:
 745:state.c       ****   }
 746:state.c       ****   else if (bit_is_set(state.speed_status, SPEED_NED_I)) {
 2515              		.loc 1 746 0
 2516 0018 9A07     		lsls	r2, r3, #30
 2517 001a 17D5     		bpl	.L274
 2518              	.LBB2:
 747:state.c       ****     int32_t n2 = (state.ned_speed_i.x*state.ned_speed_i.x +
 748:state.c       ****                   state.ned_speed_i.y*state.ned_speed_i.y) >> INT32_SPEED_FRAC;
 2519              		.loc 1 748 0
 2520 001c D4F82831 		ldr	r3, [r4, #296]
 747:state.c       ****     int32_t n2 = (state.ned_speed_i.x*state.ned_speed_i.x +
 2521              		.loc 1 747 0
 2522 0020 D4F82401 		ldr	r0, [r4, #292]
 2523              		.loc 1 748 0
 2524 0024 5B43     		muls	r3, r3, r3
 747:state.c       ****     int32_t n2 = (state.ned_speed_i.x*state.ned_speed_i.x +
 2525              		.loc 1 747 0
 2526 0026 00FB0031 		mla	r1, r0, r0, r3
 2527              	.LVL280:
 749:state.c       ****     INT32_SQRT(state.h_speed_norm_i, n2);
 2528              		.loc 1 749 0
 2529 002a C914     		asrs	r1, r1, #19
 2530              	.LVL281:
 2531 002c 4AD0     		beq	.L301
 2532              	.L275:
 2533              	.LVL282:
 2534              	.LBB3:
 2535              		.loc 1 749 0 is_stmt 0 discriminator 2
 2536 002e 0B46     		mov	r3, r1
 2537 0030 2820     		movs	r0, #40
 2538              	.LVL283:
 2539              	.L277:
 2540              		.loc 1 749 0 discriminator 3
 2541 0032 B1FBF3F2 		udiv	r2, r1, r3
 2542              	.LVL284:
 2543 0036 D218     		adds	r2, r2, r3
 2544              	.LVL285:
 2545 0038 5208     		lsrs	r2, r2, #1
 2546              	.LVL286:
 2547 003a 9B1A     		subs	r3, r3, r2
 2548              	.LVL287:
 2549 003c 012B     		cmp	r3, #1
 2550 003e 4DD9     		bls	.L290
 2551              	.L276:
 2552 0040 0138     		subs	r0, r0, #1
 2553              		.loc 1 749 0 discriminator 4
 2554 0042 10F0FF00 		ands	r0, r0, #255
 2555 0046 1346     		mov	r3, r2
 2556 0048 F3D1     		bne	.L277
 2557 004a 47E0     		b	.L290
 2558              	.LVL288:
 2559              	.L274:
 2560              	.LBE3:
 2561              	.LBE2:
 750:state.c       ****   }
 751:state.c       ****   else if (bit_is_set(state.speed_status, SPEED_NED_F)) {
 2562              		.loc 1 751 0 is_stmt 1
 2563 004c 5806     		lsls	r0, r3, #25
 2564 004e 5FD4     		bmi	.L299
 2565              	.L279:
 752:state.c       ****     FLOAT_VECT2_NORM(state.h_speed_norm_f, state.ned_speed_f);
 753:state.c       ****     SetBit(state.speed_status, SPEED_HNORM_F);
 754:state.c       ****     state.h_speed_norm_i = SPEED_BFP_OF_REAL(state.h_speed_norm_f);
 755:state.c       ****   }
 756:state.c       ****   else if (bit_is_set(state.speed_status, SPEED_ENU_I)) {
 2566              		.loc 1 756 0
 2567 0050 5907     		lsls	r1, r3, #29
 2568 0052 17D5     		bpl	.L280
 2569              	.LBB4:
 757:state.c       ****     int32_t n2 = (state.enu_speed_i.x*state.enu_speed_i.x +
 758:state.c       ****                   state.enu_speed_i.y*state.enu_speed_i.y) >> INT32_SPEED_FRAC;
 2570              		.loc 1 758 0
 2571 0054 D4F83421 		ldr	r2, [r4, #308]
 757:state.c       ****     int32_t n2 = (state.enu_speed_i.x*state.enu_speed_i.x +
 2572              		.loc 1 757 0
 2573 0058 D4F83011 		ldr	r1, [r4, #304]
 2574              		.loc 1 758 0
 2575 005c 5243     		muls	r2, r2, r2
 757:state.c       ****     int32_t n2 = (state.enu_speed_i.x*state.enu_speed_i.x +
 2576              		.loc 1 757 0
 2577 005e 01FB0123 		mla	r3, r1, r1, r2
 2578              	.LVL289:
 759:state.c       ****     INT32_SQRT(state.h_speed_norm_i, n2);
 2579              		.loc 1 759 0
 2580 0062 D914     		asrs	r1, r3, #19
 2581              	.LVL290:
 2582 0064 2ED0     		beq	.L301
 2583              	.L281:
 2584              	.LVL291:
 2585              	.LBB5:
 2586              		.loc 1 759 0 is_stmt 0 discriminator 2
 2587 0066 0B46     		mov	r3, r1
 2588 0068 2820     		movs	r0, #40
 2589              	.LVL292:
 2590              	.L283:
 2591              		.loc 1 759 0 discriminator 3
 2592 006a B1FBF3F2 		udiv	r2, r1, r3
 2593              	.LVL293:
 2594 006e D218     		adds	r2, r2, r3
 2595              	.LVL294:
 2596 0070 5208     		lsrs	r2, r2, #1
 2597              	.LVL295:
 2598 0072 9B1A     		subs	r3, r3, r2
 2599              	.LVL296:
 2600 0074 012B     		cmp	r3, #1
 2601 0076 31D9     		bls	.L290
 2602              	.L282:
 2603 0078 0138     		subs	r0, r0, #1
 2604              		.loc 1 759 0 discriminator 4
 2605 007a 10F0FF00 		ands	r0, r0, #255
 2606 007e 1346     		mov	r3, r2
 2607 0080 F3D1     		bne	.L283
 2608 0082 2BE0     		b	.L290
 2609              	.LVL297:
 2610              	.L280:
 2611              	.LBE5:
 2612              	.LBE4:
 760:state.c       ****   }
 761:state.c       ****   else if (bit_is_set(state.speed_status, SPEED_ENU_F)) {
 2613              		.loc 1 761 0 is_stmt 1
 2614 0084 1A06     		lsls	r2, r3, #24
 2615 0086 04D5     		bpl	.L285
 762:state.c       ****     FLOAT_VECT2_NORM(state.h_speed_norm_f, state.enu_speed_f);
 2616              		.loc 1 762 0
 2617 0088 D4F85C01 		ldr	r0, [r4, #348]	@ float
 2618 008c D4F86061 		ldr	r6, [r4, #352]	@ float
 2619 0090 42E0     		b	.L297
 2620              	.L285:
 763:state.c       ****     SetBit(state.speed_status, SPEED_HNORM_F);
 764:state.c       ****     state.h_speed_norm_i = SPEED_BFP_OF_REAL(state.h_speed_norm_f);
 765:state.c       ****   }
 766:state.c       ****   else if (bit_is_set(state.speed_status, SPEED_ECEF_I)) {
 2621              		.loc 1 766 0
 2622 0092 D807     		lsls	r0, r3, #31
 2623 0094 2CD5     		bpl	.L286
 2624              	.LBB6:
 767:state.c       ****     /* transform ecef speed to ned, set status bit, then compute norm */
 768:state.c       ****     ned_of_ecef_vect_i(&state.ned_speed_i, &state.ned_origin_i, &state.ecef_speed_i);
 2625              		.loc 1 768 0
 2626 0096 04F59270 		add	r0, r4, #292
 2627 009a 04F11C01 		add	r1, r4, #28
 2628 009e 04F58C72 		add	r2, r4, #280
 2629 00a2 FFF7FEFF 		bl	ned_of_ecef_vect_i
 2630              	.LVL298:
 769:state.c       ****     SetBit(state.speed_status, SPEED_NED_I);
 770:state.c       ****     int32_t n2 = (state.ned_speed_i.x*state.ned_speed_i.x +
 771:state.c       ****                   state.ned_speed_i.y*state.ned_speed_i.y) >> INT32_SPEED_FRAC;
 2631              		.loc 1 771 0
 2632 00a6 D4F82811 		ldr	r1, [r4, #296]
 769:state.c       ****     SetBit(state.speed_status, SPEED_NED_I);
 2633              		.loc 1 769 0
 2634 00aa B4F81421 		ldrh	r2, [r4, #276]
 2635              		.loc 1 771 0
 2636 00ae 4943     		muls	r1, r1, r1
 770:state.c       ****     int32_t n2 = (state.ned_speed_i.x*state.ned_speed_i.x +
 2637              		.loc 1 770 0
 2638 00b0 D4F82401 		ldr	r0, [r4, #292]
 769:state.c       ****     SetBit(state.speed_status, SPEED_NED_I);
 2639              		.loc 1 769 0
 2640 00b4 42F00203 		orr	r3, r2, #2
 770:state.c       ****     int32_t n2 = (state.ned_speed_i.x*state.ned_speed_i.x +
 2641              		.loc 1 770 0
 2642 00b8 00FB0012 		mla	r2, r0, r0, r1
 2643              	.LVL299:
 772:state.c       ****     INT32_SQRT(state.h_speed_norm_i, n2);
 2644              		.loc 1 772 0
 2645 00bc D114     		asrs	r1, r2, #19
 2646              	.LVL300:
 769:state.c       ****     SetBit(state.speed_status, SPEED_NED_I);
 2647              		.loc 1 769 0
 2648 00be A4F81431 		strh	r3, [r4, #276]	@ movhi
 2649              		.loc 1 772 0
 2650 00c2 02D1     		bne	.L287
 2651              	.LVL301:
 2652              	.L301:
 2653              		.loc 1 772 0 is_stmt 0 discriminator 1
 2654 00c4 C4F83C11 		str	r1, [r4, #316]
 2655 00c8 44E0     		b	.L273
 2656              	.LVL302:
 2657              	.L287:
 2658              	.LBB7:
 2659              		.loc 1 772 0 discriminator 2
 2660 00ca 0B46     		mov	r3, r1
 2661 00cc 2820     		movs	r0, #40
 2662              	.LVL303:
 2663              	.L289:
 2664              		.loc 1 772 0 discriminator 3
 2665 00ce B1FBF3F2 		udiv	r2, r1, r3
 2666              	.LVL304:
 2667 00d2 D218     		adds	r2, r2, r3
 2668              	.LVL305:
 2669 00d4 5208     		lsrs	r2, r2, #1
 2670              	.LVL306:
 2671 00d6 9B1A     		subs	r3, r3, r2
 2672              	.LVL307:
 2673 00d8 012B     		cmp	r3, #1
 2674 00da 03D8     		bhi	.L288
 2675              	.LVL308:
 2676              	.L290:
 2677              		.loc 1 772 0
 2678 00dc 2149     		ldr	r1, .L302
 2679 00de C1F83C21 		str	r2, [r1, #316]
 2680 00e2 37E0     		b	.L273
 2681              	.LVL309:
 2682              	.L288:
 2683 00e4 0138     		subs	r0, r0, #1
 2684              		.loc 1 772 0 discriminator 4
 2685 00e6 10F0FF00 		ands	r0, r0, #255
 2686 00ea 1346     		mov	r3, r2
 2687 00ec EFD1     		bne	.L289
 2688 00ee F5E7     		b	.L290
 2689              	.LVL310:
 2690              	.L286:
 2691              	.LBE7:
 2692              	.LBE6:
 773:state.c       ****   }
 774:state.c       ****   else if (bit_is_set(state.speed_status, SPEED_ECEF_F)) {
 2693              		.loc 1 774 0 is_stmt 1
 2694 00f0 9906     		lsls	r1, r3, #26
 2695 00f2 2FD5     		bpl	.L273
 775:state.c       ****     ned_of_ecef_vect_f(&state.ned_speed_f, &state.ned_origin_f, &state.ecef_speed_f);
 2696              		.loc 1 775 0
 2697 00f4 04F5A870 		add	r0, r4, #336
 2698 00f8 04F1A401 		add	r1, r4, #164
 2699 00fc 04F5A272 		add	r2, r4, #324
 2700 0100 FFF7FEFF 		bl	ned_of_ecef_vect_f
 2701              	.LVL311:
 776:state.c       ****     SetBit(state.speed_status, SPEED_NED_F);
 2702              		.loc 1 776 0
 2703 0104 B4F81401 		ldrh	r0, [r4, #276]
 2704 0108 40F04001 		orr	r1, r0, #64
 2705 010c A4F81411 		strh	r1, [r4, #276]	@ movhi
 2706              	.L299:
 777:state.c       ****     FLOAT_VECT2_NORM(state.h_speed_norm_f, state.ned_speed_f);
 2707              		.loc 1 777 0
 2708 0110 D4F85001 		ldr	r0, [r4, #336]	@ float
 2709 0114 D4F85461 		ldr	r6, [r4, #340]	@ float
 2710              	.L297:
 2711 0118 0146     		mov	r1, r0
 2712 011a FFF7FEFF 		bl	__aeabi_fmul
 2713              	.LVL312:
 2714 011e 3146     		mov	r1, r6
 2715 0120 0546     		mov	r5, r0
 2716 0122 3046     		mov	r0, r6
 2717 0124 FFF7FEFF 		bl	__aeabi_fmul
 2718              	.LVL313:
 2719 0128 0146     		mov	r1, r0
 2720 012a 2846     		mov	r0, r5
 2721 012c FFF7FEFF 		bl	__aeabi_fadd
 2722              	.LVL314:
 2723 0130 FFF7FEFF 		bl	sqrtf
 2724              	.LVL315:
 778:state.c       ****     SetBit(state.speed_status, SPEED_HNORM_F);
 2725              		.loc 1 778 0
 2726 0134 B4F81411 		ldrh	r1, [r4, #276]
 777:state.c       ****     FLOAT_VECT2_NORM(state.h_speed_norm_f, state.ned_speed_f);
 2727              		.loc 1 777 0
 2728 0138 C4F86801 		str	r0, [r4, #360]	@ float
 2729              		.loc 1 778 0
 2730 013c 41F48072 		orr	r2, r1, #256
 2731 0140 A4F81421 		strh	r2, [r4, #276]	@ movhi
 2732              	.L300:
 779:state.c       ****     state.h_speed_norm_i = SPEED_BFP_OF_REAL(state.h_speed_norm_f);
 2733              		.loc 1 779 0
 2734 0144 4FF09241 		mov	r1, #1224736768
 2735 0148 FFF7FEFF 		bl	__aeabi_fmul
 2736              	.LVL316:
 2737 014c FFF7FEFF 		bl	__aeabi_f2iz
 2738              	.LVL317:
 2739 0150 C4F83C01 		str	r0, [r4, #316]
 2740              	.L273:
 780:state.c       ****   }
 781:state.c       ****   else {
 782:state.c       ****     //int32_t _norm_zero = 0;
 783:state.c       ****     //return _norm_zero;
 784:state.c       ****   }
 785:state.c       ****   /* set bit to indicate this representation is computed */
 786:state.c       ****   SetBit(state.speed_status, SPEED_HNORM_I);
 2741              		.loc 1 786 0
 2742 0154 034B     		ldr	r3, .L302
 2743 0156 B3F81421 		ldrh	r2, [r3, #276]
 2744 015a 42F00800 		orr	r0, r2, #8
 2745 015e A3F81401 		strh	r0, [r3, #276]	@ movhi
 2746              	.L270:
 2747 0162 70BD     		pop	{r4, r5, r6, pc}
 2748              	.L303:
 2749              		.align	2
 2750              	.L302:
 2751 0164 00000000 		.word	.LANCHOR0
 2752              		.cfi_endproc
 2753              	.LFE113:
 2755              		.section	.text.stateCalcHorizontalSpeedDir_i,"ax",%progbits
 2756              		.align	1
 2757              		.global	stateCalcHorizontalSpeedDir_i
 2758              		.thumb
 2759              		.thumb_func
 2761              	stateCalcHorizontalSpeedDir_i:
 2762              	.LFB114:
 787:state.c       **** }
 788:state.c       **** 
 789:state.c       **** void stateCalcHorizontalSpeedDir_i(void) {
 2763              		.loc 1 789 0
 2764              		.cfi_startproc
 2765              		@ args = 0, pretend = 0, frame = 0
 2766              		@ frame_needed = 0, uses_anonymous_args = 0
 2767 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 2768              	.LCFI13:
 2769              		.cfi_def_cfa_offset 24
 2770              		.cfi_offset 3, -24
 2771              		.cfi_offset 4, -20
 2772              		.cfi_offset 5, -16
 2773              		.cfi_offset 6, -12
 2774              		.cfi_offset 7, -8
 2775              		.cfi_offset 14, -4
 790:state.c       ****   if (bit_is_set(state.speed_status, SPEED_HDIR_I))
 2776              		.loc 1 790 0
 2777 0002 B04C     		ldr	r4, .L348
 2778 0004 B4F81451 		ldrh	r5, [r4, #276]
 2779 0008 EA06     		lsls	r2, r5, #27
 2780 000a 00F15981 		bmi	.L304
 791:state.c       ****     return;
 792:state.c       **** 
 793:state.c       ****   if (bit_is_set(state.speed_status, SPEED_HDIR_F)){
 2781              		.loc 1 793 0
 2782 000e AB05     		lsls	r3, r5, #22
 2783 0010 0AD5     		bpl	.L306
 794:state.c       ****     state.h_speed_dir_i = SPEED_BFP_OF_REAL(state.h_speed_dir_f);
 2784              		.loc 1 794 0
 2785 0012 4FF09241 		mov	r1, #1224736768
 2786 0016 D4F86C01 		ldr	r0, [r4, #364]	@ float
 2787 001a FFF7FEFF 		bl	__aeabi_fmul
 2788              	.LVL318:
 2789 001e FFF7FEFF 		bl	__aeabi_f2iz
 2790              	.LVL319:
 2791 0022 C4F84001 		str	r0, [r4, #320]
 2792 0026 44E1     		b	.L307
 2793              	.L306:
 795:state.c       ****   }
 796:state.c       ****   else if (bit_is_set(state.speed_status, SPEED_NED_I)) {
 2794              		.loc 1 796 0
 2795 0028 A807     		lsls	r0, r5, #30
 2796 002a 3ED5     		bpl	.L308
 2797              	.LVL320:
 2798              	.LBB8:
 797:state.c       ****     INT32_ATAN2(state.h_speed_dir_i, state.ned_speed_i.y, state.ned_speed_i.x);
 2799              		.loc 1 797 0
 2800 002c D4F82811 		ldr	r1, [r4, #296]
 2801 0030 81EAE173 		eor	r3, r1, r1, asr #31
 2802 0034 A3EBE173 		sub	r3, r3, r1, asr #31
 2803 0038 5A1C     		adds	r2, r3, #1
 2804              	.LVL321:
 2805 003a D4F82431 		ldr	r3, [r4, #292]
 2806 003e 002B     		cmp	r3, #0
 2807 0040 03EB0200 		add	r0, r3, r2
 2808 0044 0BDB     		blt	.L309
 2809              	.LVL322:
 2810              		.loc 1 797 0 is_stmt 0 discriminator 1
 2811 0046 9A1A     		subs	r2, r3, r2
 2812              	.LVL323:
 2813 0048 9303     		lsls	r3, r2, #14
 2814              	.LVL324:
 2815 004a 93FBF0F0 		sdiv	r0, r3, r0
 2816              	.LVL325:
 2817 004e 4FF44962 		mov	r2, #3216
 2818 0052 5043     		muls	r0, r2, r0
 2819              	.LVL326:
 2820 0054 8313     		asrs	r3, r0, #14
 2821 0056 D01A     		subs	r0, r2, r3
 2822 0058 C4F84001 		str	r0, [r4, #320]
 2823 005c 0CE0     		b	.L310
 2824              	.LVL327:
 2825              	.L309:
 2826              		.loc 1 797 0 discriminator 2
 2827 005e 8003     		lsls	r0, r0, #14
 2828 0060 D21A     		subs	r2, r2, r3
 2829              	.LVL328:
 2830 0062 90FBF2F3 		sdiv	r3, r0, r2
 2831              	.LVL329:
 2832 0066 4FF44960 		mov	r0, #3216
 2833 006a 4343     		muls	r3, r0, r3
 2834 006c 9A13     		asrs	r2, r3, #14
 2835 006e C2F51653 		rsb	r3, r2, #9600
 2836 0072 3033     		adds	r3, r3, #48
 2837 0074 C4F84031 		str	r3, [r4, #320]
 2838              	.LVL330:
 2839              	.L310:
 2840              		.loc 1 797 0 discriminator 3
 2841 0078 0029     		cmp	r1, #0
 2842 007a 9249     		ldr	r1, .L348
 2843              	.LVL331:
 2844 007c 04DA     		bge	.L311
 2845              		.loc 1 797 0 discriminator 4
 2846 007e D1F84021 		ldr	r2, [r1, #320]
 2847 0082 5342     		negs	r3, r2
 2848 0084 C1F84031 		str	r3, [r1, #320]
 2849              	.L311:
 2850 0088 D1F84031 		ldr	r3, [r1, #320]
 2851              	.L312:
 2852              	.LBE8:
 798:state.c       ****     INT32_COURSE_NORMALIZE(state.h_speed_dir_i);
 2853              		.loc 1 798 0 is_stmt 1 discriminator 1
 2854 008c 002B     		cmp	r3, #0
 2855 008e 03DA     		bge	.L343
 2856              	.L313:
 2857              		.loc 1 798 0 is_stmt 0 discriminator 2
 2858 0090 03F5C943 		add	r3, r3, #25728
 2859 0094 0733     		adds	r3, r3, #7
 2860 0096 F9E7     		b	.L312
 2861              	.L343:
 2862              		.loc 1 798 0 discriminator 4
 2863 0098 46F28640 		movw	r0, #25734
 2864 009c 8342     		cmp	r3, r0
 2865 009e 40F30581 		ble	.L347
 2866              	.L315:
 2867              		.loc 1 798 0 discriminator 5
 2868 00a2 A3F5C942 		sub	r2, r3, #25728
 2869 00a6 D31F     		subs	r3, r2, #7
 2870 00a8 F6E7     		b	.L343
 2871              	.LVL332:
 2872              	.L308:
 799:state.c       ****   }
 800:state.c       ****   else if (bit_is_set(state.speed_status, SPEED_ENU_I)) {
 2873              		.loc 1 800 0 is_stmt 1
 2874 00aa 6907     		lsls	r1, r5, #29
 2875 00ac 3ED5     		bpl	.L316
 2876              	.LVL333:
 2877              	.LBB9:
 801:state.c       ****     INT32_ATAN2(state.h_speed_dir_i, state.enu_speed_i.x, state.enu_speed_i.y);
 2878              		.loc 1 801 0
 2879 00ae D4F83011 		ldr	r1, [r4, #304]
 2880 00b2 D4F83431 		ldr	r3, [r4, #308]
 2881 00b6 81EAE170 		eor	r0, r1, r1, asr #31
 2882 00ba A0EBE170 		sub	r0, r0, r1, asr #31
 2883 00be 421C     		adds	r2, r0, #1
 2884              	.LVL334:
 2885 00c0 002B     		cmp	r3, #0
 2886 00c2 03EB0200 		add	r0, r3, r2
 2887 00c6 0BDB     		blt	.L317
 2888              	.LVL335:
 2889              		.loc 1 801 0 is_stmt 0 discriminator 1
 2890 00c8 9A1A     		subs	r2, r3, r2
 2891              	.LVL336:
 2892 00ca 9303     		lsls	r3, r2, #14
 2893              	.LVL337:
 2894 00cc 93FBF0F0 		sdiv	r0, r3, r0
 2895              	.LVL338:
 2896 00d0 4FF44962 		mov	r2, #3216
 2897 00d4 5043     		muls	r0, r2, r0
 2898              	.LVL339:
 2899 00d6 8313     		asrs	r3, r0, #14
 2900 00d8 D01A     		subs	r0, r2, r3
 2901 00da C4F84001 		str	r0, [r4, #320]
 2902 00de 0CE0     		b	.L318
 2903              	.LVL340:
 2904              	.L317:
 2905              		.loc 1 801 0 discriminator 2
 2906 00e0 8003     		lsls	r0, r0, #14
 2907 00e2 D21A     		subs	r2, r2, r3
 2908              	.LVL341:
 2909 00e4 90FBF2F3 		sdiv	r3, r0, r2
 2910              	.LVL342:
 2911 00e8 4FF44960 		mov	r0, #3216
 2912 00ec 4343     		muls	r3, r0, r3
 2913 00ee 9A13     		asrs	r2, r3, #14
 2914 00f0 C2F51653 		rsb	r3, r2, #9600
 2915 00f4 3033     		adds	r3, r3, #48
 2916 00f6 C4F84031 		str	r3, [r4, #320]
 2917              	.LVL343:
 2918              	.L318:
 2919              		.loc 1 801 0 discriminator 3
 2920 00fa 0029     		cmp	r1, #0
 2921 00fc 7149     		ldr	r1, .L348
 2922              	.LVL344:
 2923 00fe 04DA     		bge	.L319
 2924              		.loc 1 801 0 discriminator 4
 2925 0100 D1F84021 		ldr	r2, [r1, #320]
 2926 0104 5342     		negs	r3, r2
 2927 0106 C1F84031 		str	r3, [r1, #320]
 2928              	.L319:
 2929 010a D1F84031 		ldr	r3, [r1, #320]
 2930              	.L320:
 2931              	.LBE9:
 802:state.c       ****     INT32_COURSE_NORMALIZE(state.h_speed_dir_i);
 2932              		.loc 1 802 0 is_stmt 1 discriminator 1
 2933 010e 002B     		cmp	r3, #0
 2934 0110 03DA     		bge	.L344
 2935              	.L321:
 2936              		.loc 1 802 0 is_stmt 0 discriminator 2
 2937 0112 03F5C942 		add	r2, r3, #25728
 2938 0116 D31D     		adds	r3, r2, #7
 2939 0118 F9E7     		b	.L320
 2940              	.L344:
 2941              		.loc 1 802 0 discriminator 4
 2942 011a 46F28640 		movw	r0, #25734
 2943 011e 8342     		cmp	r3, r0
 2944 0120 40F3C480 		ble	.L347
 2945              	.L323:
 2946              		.loc 1 802 0 discriminator 5
 2947 0124 A3F5C941 		sub	r1, r3, #25728
 2948 0128 CB1F     		subs	r3, r1, #7
 2949 012a F6E7     		b	.L344
 2950              	.LVL345:
 2951              	.L316:
 803:state.c       ****   }
 804:state.c       ****   else if (bit_is_set(state.speed_status, SPEED_NED_F)) {
 2952              		.loc 1 804 0 is_stmt 1
 2953 012c 6A06     		lsls	r2, r5, #25
 2954 012e 5DD5     		bpl	.L325
 805:state.c       ****     SPEEDS_BFP_OF_REAL(state.ned_speed_i, state.ned_speed_f);
 2955              		.loc 1 805 0
 2956 0130 4FF09241 		mov	r1, #1224736768
 2957 0134 D4F85001 		ldr	r0, [r4, #336]	@ float
 2958 0138 FFF7FEFF 		bl	__aeabi_fmul
 2959              	.LVL346:
 2960 013c FFF7FEFF 		bl	__aeabi_f2iz
 2961              	.LVL347:
 2962 0140 4FF09241 		mov	r1, #1224736768
 2963 0144 0646     		mov	r6, r0
 2964 0146 C4F82401 		str	r0, [r4, #292]
 2965 014a D4F85401 		ldr	r0, [r4, #340]	@ float
 2966 014e FFF7FEFF 		bl	__aeabi_fmul
 2967              	.LVL348:
 2968 0152 FFF7FEFF 		bl	__aeabi_f2iz
 2969              	.LVL349:
 2970 0156 4FF09241 		mov	r1, #1224736768
 2971 015a 0746     		mov	r7, r0
 2972 015c C4F82801 		str	r0, [r4, #296]
 2973 0160 D4F85801 		ldr	r0, [r4, #344]	@ float
 2974 0164 FFF7FEFF 		bl	__aeabi_fmul
 2975              	.LVL350:
 2976 0168 FFF7FEFF 		bl	__aeabi_f2iz
 2977              	.LVL351:
 2978 016c C4F82C01 		str	r0, [r4, #300]
 2979              	.LBB10:
 806:state.c       ****     SetBit(state.speed_status, SPEED_NED_I);
 807:state.c       ****     INT32_ATAN2(state.h_speed_dir_i, state.ned_speed_i.y, state.ned_speed_i.x);
 2980              		.loc 1 807 0
 2981 0170 87EAE770 		eor	r0, r7, r7, asr #31
 2982 0174 A0EBE770 		sub	r0, r0, r7, asr #31
 2983 0178 411C     		adds	r1, r0, #1
 2984              	.LBE10:
 806:state.c       ****     SetBit(state.speed_status, SPEED_NED_I);
 2985              		.loc 1 806 0
 2986 017a 45F00205 		orr	r5, r5, #2
 2987              	.LBB11:
 2988              		.loc 1 807 0
 2989 017e 002E     		cmp	r6, #0
 2990              	.LBE11:
 806:state.c       ****     SetBit(state.speed_status, SPEED_NED_I);
 2991              		.loc 1 806 0
 2992 0180 A4F81451 		strh	r5, [r4, #276]	@ movhi
 2993              	.LVL352:
 2994 0184 06EB0102 		add	r2, r6, r1
 2995              	.LBB12:
 2996              		.loc 1 807 0
 2997 0188 0BDB     		blt	.L326
 2998              	.LVL353:
 2999              		.loc 1 807 0 is_stmt 0 discriminator 1
 3000 018a 701A     		subs	r0, r6, r1
 3001 018c 8103     		lsls	r1, r0, #14
 3002              	.LVL354:
 3003 018e 91FBF2F2 		sdiv	r2, r1, r2
 3004              	.LVL355:
 3005 0192 4FF44963 		mov	r3, #3216
 3006 0196 5A43     		muls	r2, r3, r2
 3007              	.LVL356:
 3008 0198 9013     		asrs	r0, r2, #14
 3009 019a 191A     		subs	r1, r3, r0
 3010 019c C4F84011 		str	r1, [r4, #320]
 3011 01a0 0CE0     		b	.L327
 3012              	.LVL357:
 3013              	.L326:
 3014              		.loc 1 807 0 discriminator 2
 3015 01a2 9303     		lsls	r3, r2, #14
 3016 01a4 8E1B     		subs	r6, r1, r6
 3017              	.LVL358:
 3018 01a6 93FBF6F0 		sdiv	r0, r3, r6
 3019 01aa 4FF44961 		mov	r1, #3216
 3020              	.LVL359:
 3021 01ae 4843     		muls	r0, r1, r0
 3022 01b0 8213     		asrs	r2, r0, #14
 3023 01b2 C2F51653 		rsb	r3, r2, #9600
 3024 01b6 3033     		adds	r3, r3, #48
 3025 01b8 C4F84031 		str	r3, [r4, #320]
 3026              	.L327:
 3027              		.loc 1 807 0 discriminator 3
 3028 01bc 002F     		cmp	r7, #0
 3029 01be 414B     		ldr	r3, .L348
 3030 01c0 04DA     		bge	.L328
 3031              		.loc 1 807 0 discriminator 4
 3032 01c2 D3F84021 		ldr	r2, [r3, #320]
 3033 01c6 5042     		negs	r0, r2
 3034 01c8 C3F84001 		str	r0, [r3, #320]
 3035              	.L328:
 3036 01cc D3F84031 		ldr	r3, [r3, #320]
 3037              	.L329:
 3038              	.LBE12:
 808:state.c       ****     INT32_COURSE_NORMALIZE(state.h_speed_dir_i);
 3039              		.loc 1 808 0 is_stmt 1 discriminator 1
 3040 01d0 002B     		cmp	r3, #0
 3041 01d2 03DA     		bge	.L345
 3042              	.L330:
 3043              		.loc 1 808 0 is_stmt 0 discriminator 2
 3044 01d4 03F5C942 		add	r2, r3, #25728
 3045 01d8 D31D     		adds	r3, r2, #7
 3046 01da F9E7     		b	.L329
 3047              	.L345:
 3048              		.loc 1 808 0 discriminator 4
 3049 01dc 46F28641 		movw	r1, #25734
 3050 01e0 8B42     		cmp	r3, r1
 3051 01e2 63DD     		ble	.L347
 3052              	.L332:
 3053              		.loc 1 808 0 discriminator 5
 3054 01e4 A3F5C943 		sub	r3, r3, #25728
 3055 01e8 073B     		subs	r3, r3, #7
 3056 01ea F7E7     		b	.L345
 3057              	.LVL360:
 3058              	.L325:
 809:state.c       ****   }
 810:state.c       ****   else if (bit_is_set(state.speed_status, SPEED_ENU_F)) {
 3059              		.loc 1 810 0 is_stmt 1
 3060 01ec 2B06     		lsls	r3, r5, #24
 3061 01ee 60D5     		bpl	.L307
 811:state.c       ****     SPEEDS_BFP_OF_REAL(state.enu_speed_i, state.enu_speed_f);
 3062              		.loc 1 811 0
 3063 01f0 4FF09241 		mov	r1, #1224736768
 3064 01f4 D4F85C01 		ldr	r0, [r4, #348]	@ float
 3065 01f8 FFF7FEFF 		bl	__aeabi_fmul
 3066              	.LVL361:
 3067 01fc FFF7FEFF 		bl	__aeabi_f2iz
 3068              	.LVL362:
 3069 0200 4FF09241 		mov	r1, #1224736768
 3070 0204 0746     		mov	r7, r0
 3071 0206 C4F83001 		str	r0, [r4, #304]
 3072 020a D4F86001 		ldr	r0, [r4, #352]	@ float
 3073 020e FFF7FEFF 		bl	__aeabi_fmul
 3074              	.LVL363:
 3075 0212 FFF7FEFF 		bl	__aeabi_f2iz
 3076              	.LVL364:
 3077 0216 4FF09241 		mov	r1, #1224736768
 3078 021a 0646     		mov	r6, r0
 3079 021c C4F83401 		str	r0, [r4, #308]
 3080 0220 D4F86401 		ldr	r0, [r4, #356]	@ float
 3081 0224 FFF7FEFF 		bl	__aeabi_fmul
 3082              	.LVL365:
 3083 0228 FFF7FEFF 		bl	__aeabi_f2iz
 3084              	.LVL366:
 3085              	.LBB13:
 812:state.c       ****     SetBit(state.speed_status, SPEED_ENU_I);
 813:state.c       ****     INT32_ATAN2(state.h_speed_dir_i, state.enu_speed_i.x, state.enu_speed_i.y);
 3086              		.loc 1 813 0
 3087 022c 87EAE773 		eor	r3, r7, r7, asr #31
 3088 0230 A3EBE773 		sub	r3, r3, r7, asr #31
 3089              	.LBE13:
 811:state.c       ****     SPEEDS_BFP_OF_REAL(state.enu_speed_i, state.enu_speed_f);
 3090              		.loc 1 811 0
 3091 0234 C4F83801 		str	r0, [r4, #312]
 812:state.c       ****     SetBit(state.speed_status, SPEED_ENU_I);
 3092              		.loc 1 812 0
 3093 0238 45F00405 		orr	r5, r5, #4
 3094              	.LBB14:
 3095              		.loc 1 813 0
 3096 023c 581C     		adds	r0, r3, #1
 3097 023e 002E     		cmp	r6, #0
 3098              	.LBE14:
 812:state.c       ****     SetBit(state.speed_status, SPEED_ENU_I);
 3099              		.loc 1 812 0
 3100 0240 A4F81451 		strh	r5, [r4, #276]	@ movhi
 3101              	.LVL367:
 3102 0244 06EB0002 		add	r2, r6, r0
 3103              	.LBB15:
 3104              		.loc 1 813 0
 3105 0248 0BDB     		blt	.L333
 3106              	.LVL368:
 3107              		.loc 1 813 0 is_stmt 0 discriminator 1
 3108 024a 331A     		subs	r3, r6, r0
 3109 024c 9803     		lsls	r0, r3, #14
 3110              	.LVL369:
 3111 024e 90FBF2F2 		sdiv	r2, r0, r2
 3112              	.LVL370:
 3113 0252 4FF44961 		mov	r1, #3216
 3114 0256 4A43     		muls	r2, r1, r2
 3115              	.LVL371:
 3116 0258 9313     		asrs	r3, r2, #14
 3117 025a C81A     		subs	r0, r1, r3
 3118 025c C4F84001 		str	r0, [r4, #320]
 3119 0260 0CE0     		b	.L334
 3120              	.LVL372:
 3121              	.L333:
 3122              		.loc 1 813 0 discriminator 2
 3123 0262 9103     		lsls	r1, r2, #14
 3124 0264 861B     		subs	r6, r0, r6
 3125              	.LVL373:
 3126 0266 91FBF6F3 		sdiv	r3, r1, r6
 3127 026a 4FF44960 		mov	r0, #3216
 3128              	.LVL374:
 3129 026e 4343     		muls	r3, r0, r3
 3130 0270 9A13     		asrs	r2, r3, #14
 3131 0272 C2F51651 		rsb	r1, r2, #9600
 3132 0276 3031     		adds	r1, r1, #48
 3133 0278 C4F84011 		str	r1, [r4, #320]
 3134              	.L334:
 3135              		.loc 1 813 0 discriminator 3
 3136 027c 002F     		cmp	r7, #0
 3137 027e 1149     		ldr	r1, .L348
 3138 0280 04DA     		bge	.L335
 3139              		.loc 1 813 0 discriminator 4
 3140 0282 D1F84021 		ldr	r2, [r1, #320]
 3141 0286 5342     		negs	r3, r2
 3142 0288 C1F84031 		str	r3, [r1, #320]
 3143              	.L335:
 3144 028c D1F84031 		ldr	r3, [r1, #320]
 3145              	.L336:
 3146              	.LBE15:
 814:state.c       ****     INT32_COURSE_NORMALIZE(state.h_speed_dir_i);
 3147              		.loc 1 814 0 is_stmt 1 discriminator 1
 3148 0290 002B     		cmp	r3, #0
 3149 0292 03DA     		bge	.L346
 3150              	.L337:
 3151              		.loc 1 814 0 is_stmt 0 discriminator 2
 3152 0294 03F5C942 		add	r2, r3, #25728
 3153 0298 D31D     		adds	r3, r2, #7
 3154 029a F9E7     		b	.L336
 3155              	.L346:
 3156              		.loc 1 814 0 discriminator 4
 3157 029c 46F28640 		movw	r0, #25734
 3158 02a0 8342     		cmp	r3, r0
 3159 02a2 03DD     		ble	.L347
 3160              	.L339:
 3161              		.loc 1 814 0 discriminator 5
 3162 02a4 A3F5C941 		sub	r1, r3, #25728
 3163 02a8 CB1F     		subs	r3, r1, #7
 3164 02aa F7E7     		b	.L346
 3165              	.LVL375:
 3166              	.L347:
 3167 02ac 0549     		ldr	r1, .L348
 3168 02ae C1F84031 		str	r3, [r1, #320]
 3169              	.L307:
 815:state.c       ****   }
 816:state.c       ****   /* set bit to indicate this representation is computed */
 817:state.c       ****   SetBit(state.speed_status, SPEED_HDIR_I);
 3170              		.loc 1 817 0 is_stmt 1
 3171 02b2 0448     		ldr	r0, .L348
 3172 02b4 B0F81411 		ldrh	r1, [r0, #276]
 3173 02b8 41F01002 		orr	r2, r1, #16
 3174 02bc A0F81421 		strh	r2, [r0, #276]	@ movhi
 3175              	.L304:
 3176 02c0 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 3177              	.L349:
 3178 02c2 00BF     		.align	2
 3179              	.L348:
 3180 02c4 00000000 		.word	.LANCHOR0
 3181              		.cfi_endproc
 3182              	.LFE114:
 3184              		.section	.text.stateCalcSpeedNed_f,"ax",%progbits
 3185              		.align	1
 3186              		.global	stateCalcSpeedNed_f
 3187              		.thumb
 3188              		.thumb_func
 3190              	stateCalcSpeedNed_f:
 3191              	.LFB115:
 818:state.c       **** }
 819:state.c       **** 
 820:state.c       **** void stateCalcSpeedNed_f(void) {
 3192              		.loc 1 820 0
 3193              		.cfi_startproc
 3194              		@ args = 0, pretend = 0, frame = 0
 3195              		@ frame_needed = 0, uses_anonymous_args = 0
 3196 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 3197              	.LCFI14:
 3198              		.cfi_def_cfa_offset 24
 3199              		.cfi_offset 3, -24
 3200              		.cfi_offset 4, -20
 3201              		.cfi_offset 5, -16
 3202              		.cfi_offset 6, -12
 3203              		.cfi_offset 7, -8
 3204              		.cfi_offset 14, -4
 821:state.c       ****   if (bit_is_set(state.speed_status, SPEED_NED_F))
 3205              		.loc 1 821 0
 3206 0002 544C     		ldr	r4, .L374
 3207 0004 B4F81451 		ldrh	r5, [r4, #276]
 3208 0008 6906     		lsls	r1, r5, #25
 3209 000a 00F1A280 		bmi	.L350
 3210              	.LVL376:
 822:state.c       ****     return;
 823:state.c       **** 
 824:state.c       ****   int errno = 0;
 825:state.c       ****   if (state.ned_initialized_f) {
 3211              		.loc 1 825 0
 3212 000e 94F8E430 		ldrb	r3, [r4, #228]	@ zero_extendqisi2
 3213 0012 ABB3     		cbz	r3, .L352
 826:state.c       ****     if (bit_is_set(state.speed_status, SPEED_NED_I)) {
 3214              		.loc 1 826 0
 3215 0014 AA07     		lsls	r2, r5, #30
 3216 0016 39D4     		bmi	.L373
 3217              	.L353:
 827:state.c       ****       SPEEDS_FLOAT_OF_BFP(state.ned_speed_f, state.ned_speed_i);
 828:state.c       ****     }
 829:state.c       ****     else if (bit_is_set(state.speed_status, SPEED_ENU_F)) {
 3218              		.loc 1 829 0
 3219 0018 2B06     		lsls	r3, r5, #24
 3220 001a 56D4     		bmi	.L370
 3221              	.L355:
 830:state.c       ****       VECT3_NED_OF_ENU(state.ned_speed_f, state.enu_speed_f);
 831:state.c       ****     }
 832:state.c       ****     else if (bit_is_set(state.speed_status, SPEED_ENU_I)) {
 3222              		.loc 1 832 0
 3223 001c 6807     		lsls	r0, r5, #29
 3224 001e 65D4     		bmi	.L371
 3225              	.L356:
 833:state.c       ****       SPEEDS_FLOAT_OF_BFP(state.enu_speed_f, state.enu_speed_i);
 834:state.c       ****       SetBit(state.speed_status, SPEED_ENU_F);
 835:state.c       ****       VECT3_NED_OF_ENU(state.ned_speed_f, state.enu_speed_f);
 836:state.c       ****     }
 837:state.c       ****     else if (bit_is_set(state.speed_status, SPEED_ECEF_F)) {
 3226              		.loc 1 837 0
 3227 0020 A906     		lsls	r1, r5, #26
 3228 0022 24D4     		bmi	.L372
 3229              	.L357:
 838:state.c       ****       ned_of_ecef_vect_f(&state.ned_speed_f, &state.ned_origin_f, &state.ecef_speed_f);
 839:state.c       ****     }
 840:state.c       ****     else if (bit_is_set(state.speed_status, SPEED_ECEF_I)) {
 3230              		.loc 1 840 0
 3231 0024 EA07     		lsls	r2, r5, #31
 3232 0026 40F18D80 		bpl	.L354
 841:state.c       ****       /* transform ecef_i -> ecef_f -> ned_f , set status bits */
 842:state.c       ****       SPEEDS_FLOAT_OF_BFP(state.ecef_speed_f, state.ecef_speed_i);
 3233              		.loc 1 842 0
 3234 002a D4F81801 		ldr	r0, [r4, #280]
 3235 002e FFF7FEFF 		bl	__aeabi_i2f
 3236              	.LVL377:
 3237 0032 4FF05851 		mov	r1, #905969664
 3238 0036 FFF7FEFF 		bl	__aeabi_fmul
 3239              	.LVL378:
 3240 003a C4F84401 		str	r0, [r4, #324]	@ float
 3241 003e D4F81C01 		ldr	r0, [r4, #284]
 3242 0042 FFF7FEFF 		bl	__aeabi_i2f
 3243              	.LVL379:
 3244 0046 4FF05851 		mov	r1, #905969664
 3245 004a FFF7FEFF 		bl	__aeabi_fmul
 3246              	.LVL380:
 3247 004e C4F84801 		str	r0, [r4, #328]	@ float
 3248 0052 D4F82001 		ldr	r0, [r4, #288]
 3249 0056 FFF7FEFF 		bl	__aeabi_i2f
 3250              	.LVL381:
 3251 005a 4FF05851 		mov	r1, #905969664
 3252 005e FFF7FEFF 		bl	__aeabi_fmul
 3253              	.LVL382:
 843:state.c       ****       SetBit(state.speed_status, SPEED_ECEF_F);
 3254              		.loc 1 843 0
 3255 0062 45F02005 		orr	r5, r5, #32
 842:state.c       ****       SPEEDS_FLOAT_OF_BFP(state.ecef_speed_f, state.ecef_speed_i);
 3256              		.loc 1 842 0
 3257 0066 C4F84C01 		str	r0, [r4, #332]	@ float
 3258              		.loc 1 843 0
 3259 006a A4F81451 		strh	r5, [r4, #276]	@ movhi
 3260              	.L372:
 844:state.c       ****       ned_of_ecef_vect_f(&state.ned_speed_f, &state.ned_origin_f, &state.ecef_speed_f);
 3261              		.loc 1 844 0
 3262 006e 04F5A870 		add	r0, r4, #336
 3263 0072 04F1A401 		add	r1, r4, #164
 3264 0076 04F5A272 		add	r2, r4, #324
 3265 007a FFF7FEFF 		bl	ned_of_ecef_vect_f
 3266              	.LVL383:
 3267 007e 61E0     		b	.L354
 3268              	.L352:
 845:state.c       ****     }
 846:state.c       ****     else { /* could not get this representation,  set errno */
 847:state.c       ****       errno = 1;
 848:state.c       ****     }
 849:state.c       ****   }
 850:state.c       ****   else if (state.utm_initialized_f) {
 3269              		.loc 1 850 0
 3270 0080 94F8F800 		ldrb	r0, [r4, #248]	@ zero_extendqisi2
 3271 0084 0028     		cmp	r0, #0
 3272 0086 5DD0     		beq	.L354
 851:state.c       ****     if (bit_is_set(state.speed_status, SPEED_NED_I)) {
 3273              		.loc 1 851 0
 3274 0088 AB07     		lsls	r3, r5, #30
 3275 008a 1CD5     		bpl	.L358
 3276              	.L373:
 852:state.c       ****       SPEEDS_FLOAT_OF_BFP(state.ned_speed_f, state.ned_speed_i);
 3277              		.loc 1 852 0
 3278 008c D4F82401 		ldr	r0, [r4, #292]
 3279 0090 FFF7FEFF 		bl	__aeabi_i2f
 3280              	.LVL384:
 3281 0094 4FF05851 		mov	r1, #905969664
 3282 0098 FFF7FEFF 		bl	__aeabi_fmul
 3283              	.LVL385:
 3284 009c C4F85001 		str	r0, [r4, #336]	@ float
 3285 00a0 D4F82801 		ldr	r0, [r4, #296]
 3286 00a4 FFF7FEFF 		bl	__aeabi_i2f
 3287              	.LVL386:
 3288 00a8 4FF05851 		mov	r1, #905969664
 3289 00ac FFF7FEFF 		bl	__aeabi_fmul
 3290              	.LVL387:
 3291 00b0 C4F85401 		str	r0, [r4, #340]	@ float
 3292 00b4 D4F82C01 		ldr	r0, [r4, #300]
 3293 00b8 FFF7FEFF 		bl	__aeabi_i2f
 3294              	.LVL388:
 3295 00bc 4FF05851 		mov	r1, #905969664
 3296 00c0 FFF7FEFF 		bl	__aeabi_fmul
 3297              	.LVL389:
 3298 00c4 3CE0     		b	.L369
 3299              	.L358:
 853:state.c       ****     }
 854:state.c       ****     else if (bit_is_set(state.speed_status, SPEED_ENU_F)) {
 3300              		.loc 1 854 0
 3301 00c6 2806     		lsls	r0, r5, #24
 3302 00c8 0ED5     		bpl	.L359
 3303              	.L370:
 855:state.c       ****       VECT3_NED_OF_ENU(state.ned_speed_f, state.enu_speed_f);
 3304              		.loc 1 855 0
 3305 00ca D4F86431 		ldr	r3, [r4, #356]
 3306 00ce D4F86011 		ldr	r1, [r4, #352]	@ float
 3307 00d2 D4F85C21 		ldr	r2, [r4, #348]	@ float
 3308 00d6 03F10040 		add	r0, r3, #-2147483648
 3309 00da C4F85011 		str	r1, [r4, #336]	@ float
 3310 00de C4F85421 		str	r2, [r4, #340]	@ float
 3311 00e2 C4F85801 		str	r0, [r4, #344]	@ float
 3312 00e6 2DE0     		b	.L354
 3313              	.L359:
 856:state.c       ****     }
 857:state.c       ****     else if (bit_is_set(state.speed_status, SPEED_ENU_I)) {
 3314              		.loc 1 857 0
 3315 00e8 6907     		lsls	r1, r5, #29
 3316 00ea 2BD5     		bpl	.L354
 3317              	.L371:
 858:state.c       ****       SPEEDS_FLOAT_OF_BFP(state.enu_speed_f, state.enu_speed_i);
 3318              		.loc 1 858 0
 3319 00ec D4F83001 		ldr	r0, [r4, #304]
 3320 00f0 FFF7FEFF 		bl	__aeabi_i2f
 3321              	.LVL390:
 3322 00f4 4FF05851 		mov	r1, #905969664
 3323 00f8 FFF7FEFF 		bl	__aeabi_fmul
 3324              	.LVL391:
 3325 00fc 0646     		mov	r6, r0
 3326 00fe C4F85C01 		str	r0, [r4, #348]	@ float
 3327 0102 D4F83401 		ldr	r0, [r4, #308]
 3328 0106 FFF7FEFF 		bl	__aeabi_i2f
 3329              	.LVL392:
 3330 010a 4FF05851 		mov	r1, #905969664
 3331 010e FFF7FEFF 		bl	__aeabi_fmul
 3332              	.LVL393:
 3333 0112 0746     		mov	r7, r0
 3334 0114 C4F86001 		str	r0, [r4, #352]	@ float
 3335 0118 D4F83801 		ldr	r0, [r4, #312]
 3336 011c FFF7FEFF 		bl	__aeabi_i2f
 3337              	.LVL394:
 3338 0120 4FF05851 		mov	r1, #905969664
 3339 0124 FFF7FEFF 		bl	__aeabi_fmul
 3340              	.LVL395:
 859:state.c       ****       SetBit(state.speed_status, SPEED_ENU_F);
 3341              		.loc 1 859 0
 3342 0128 45F08005 		orr	r5, r5, #128
 858:state.c       ****       SPEEDS_FLOAT_OF_BFP(state.enu_speed_f, state.enu_speed_i);
 3343              		.loc 1 858 0
 3344 012c C4F86401 		str	r0, [r4, #356]	@ float
 3345              		.loc 1 859 0
 3346 0130 A4F81451 		strh	r5, [r4, #276]	@ movhi
 860:state.c       ****       VECT3_NED_OF_ENU(state.ned_speed_f, state.enu_speed_f);
 3347              		.loc 1 860 0
 3348 0134 C4F85071 		str	r7, [r4, #336]	@ float
 3349 0138 C4F85461 		str	r6, [r4, #340]	@ float
 3350 013c 00F10040 		add	r0, r0, #-2147483648
 3351              	.L369:
 3352 0140 C4F85801 		str	r0, [r4, #344]	@ float
 3353              	.L354:
 861:state.c       ****     }
 862:state.c       ****     else { /* could not get this representation,  set errno */
 863:state.c       ****       errno = 2;
 864:state.c       ****     }
 865:state.c       ****   }
 866:state.c       ****   else { /* ned coordinate system not initialized,  set errno */
 867:state.c       ****     errno = 3;
 868:state.c       ****   }
 869:state.c       ****   if (errno) {
 870:state.c       ****     //struct NedCoor_f _ned_zero = {0.0f};
 871:state.c       ****     //return _ned_zero;
 872:state.c       ****   }
 873:state.c       ****   /* set bit to indicate this representation is computed */
 874:state.c       ****   SetBit(state.speed_status, SPEED_NED_F);
 3354              		.loc 1 874 0
 3355 0144 0349     		ldr	r1, .L374
 3356 0146 B1F81421 		ldrh	r2, [r1, #276]
 3357 014a 42F04003 		orr	r3, r2, #64
 3358 014e A1F81431 		strh	r3, [r1, #276]	@ movhi
 3359              	.LVL396:
 3360              	.L350:
 3361 0152 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 3362              	.L375:
 3363              		.align	2
 3364              	.L374:
 3365 0154 00000000 		.word	.LANCHOR0
 3366              		.cfi_endproc
 3367              	.LFE115:
 3369              		.section	.text.stateCalcSpeedEnu_f,"ax",%progbits
 3370              		.align	1
 3371              		.global	stateCalcSpeedEnu_f
 3372              		.thumb
 3373              		.thumb_func
 3375              	stateCalcSpeedEnu_f:
 3376              	.LFB116:
 875:state.c       **** }
 876:state.c       **** 
 877:state.c       **** void stateCalcSpeedEnu_f(void) {
 3377              		.loc 1 877 0
 3378              		.cfi_startproc
 3379              		@ args = 0, pretend = 0, frame = 0
 3380              		@ frame_needed = 0, uses_anonymous_args = 0
 3381 0000 70B5     		push	{r4, r5, r6, lr}
 3382              	.LCFI15:
 3383              		.cfi_def_cfa_offset 16
 3384              		.cfi_offset 4, -16
 3385              		.cfi_offset 5, -12
 3386              		.cfi_offset 6, -8
 3387              		.cfi_offset 14, -4
 878:state.c       ****   if (bit_is_set(state.speed_status, SPEED_ENU_F))
 3388              		.loc 1 878 0
 3389 0002 544C     		ldr	r4, .L400
 3390 0004 B4F81451 		ldrh	r5, [r4, #276]
 3391 0008 2806     		lsls	r0, r5, #24
 3392 000a 00F1A280 		bmi	.L376
 3393              	.LVL397:
 879:state.c       ****     return;
 880:state.c       **** 
 881:state.c       ****   int errno = 0;
 882:state.c       ****   if (state.ned_initialized_f) {
 3394              		.loc 1 882 0
 3395 000e 94F8E430 		ldrb	r3, [r4, #228]	@ zero_extendqisi2
 3396 0012 ABB3     		cbz	r3, .L378
 883:state.c       ****     if (bit_is_set(state.speed_status, SPEED_NED_F)) {
 3397              		.loc 1 883 0
 3398 0014 6906     		lsls	r1, r5, #25
 3399 0016 39D4     		bmi	.L395
 3400              	.L379:
 884:state.c       ****       VECT3_ENU_OF_NED(state.enu_speed_f, state.ned_speed_f);
 885:state.c       ****     }
 886:state.c       ****     else if (bit_is_set(state.speed_status, SPEED_ENU_I)) {
 3401              		.loc 1 886 0
 3402 0018 6A07     		lsls	r2, r5, #29
 3403 001a 48D4     		bmi	.L399
 3404              	.L381:
 887:state.c       ****       ENU_FLOAT_OF_BFP(state.enu_speed_f, state.enu_speed_i);
 888:state.c       ****     }
 889:state.c       ****     else if (bit_is_set(state.speed_status, SPEED_NED_I)) {
 3405              		.loc 1 889 0
 3406 001c AB07     		lsls	r3, r5, #30
 3407 001e 65D4     		bmi	.L397
 3408              	.L382:
 890:state.c       ****       SPEEDS_FLOAT_OF_BFP(state.ned_speed_f, state.ned_speed_i);
 891:state.c       ****       SetBit(state.pos_status, SPEED_NED_F);
 892:state.c       ****       VECT3_ENU_OF_NED(state.enu_speed_f, state.ned_speed_f);
 893:state.c       ****     }
 894:state.c       ****     else if (bit_is_set(state.speed_status, SPEED_ECEF_F)) {
 3409              		.loc 1 894 0
 3410 0020 A806     		lsls	r0, r5, #26
 3411 0022 24D4     		bmi	.L398
 3412              	.L383:
 895:state.c       ****       enu_of_ecef_vect_f(&state.enu_speed_f, &state.ned_origin_f, &state.ecef_speed_f);
 896:state.c       ****     }
 897:state.c       ****     else if (bit_is_set(state.speed_status, SPEED_ECEF_I)) {
 3413              		.loc 1 897 0
 3414 0024 E907     		lsls	r1, r5, #31
 3415 0026 40F18D80 		bpl	.L380
 898:state.c       ****       /* transform ecef_I -> ecef_f -> enu_f , set status bits */
 899:state.c       ****       SPEEDS_FLOAT_OF_BFP(state.ecef_speed_f, state.ecef_speed_i);
 3416              		.loc 1 899 0
 3417 002a D4F81801 		ldr	r0, [r4, #280]
 3418 002e FFF7FEFF 		bl	__aeabi_i2f
 3419              	.LVL398:
 3420 0032 4FF05851 		mov	r1, #905969664
 3421 0036 FFF7FEFF 		bl	__aeabi_fmul
 3422              	.LVL399:
 3423 003a C4F84401 		str	r0, [r4, #324]	@ float
 3424 003e D4F81C01 		ldr	r0, [r4, #284]
 3425 0042 FFF7FEFF 		bl	__aeabi_i2f
 3426              	.LVL400:
 3427 0046 4FF05851 		mov	r1, #905969664
 3428 004a FFF7FEFF 		bl	__aeabi_fmul
 3429              	.LVL401:
 3430 004e C4F84801 		str	r0, [r4, #328]	@ float
 3431 0052 D4F82001 		ldr	r0, [r4, #288]
 3432 0056 FFF7FEFF 		bl	__aeabi_i2f
 3433              	.LVL402:
 3434 005a 4FF05851 		mov	r1, #905969664
 3435 005e FFF7FEFF 		bl	__aeabi_fmul
 3436              	.LVL403:
 900:state.c       ****       SetBit(state.speed_status, SPEED_ECEF_F);
 3437              		.loc 1 900 0
 3438 0062 45F02005 		orr	r5, r5, #32
 899:state.c       ****       SPEEDS_FLOAT_OF_BFP(state.ecef_speed_f, state.ecef_speed_i);
 3439              		.loc 1 899 0
 3440 0066 C4F84C01 		str	r0, [r4, #332]	@ float
 3441              		.loc 1 900 0
 3442 006a A4F81451 		strh	r5, [r4, #276]	@ movhi
 3443              	.L398:
 901:state.c       ****       enu_of_ecef_vect_f(&state.enu_speed_f, &state.ned_origin_f, &state.ecef_speed_f);
 3444              		.loc 1 901 0
 3445 006e 04F5AE70 		add	r0, r4, #348
 3446 0072 04F1A401 		add	r1, r4, #164
 3447 0076 04F5A272 		add	r2, r4, #324
 3448 007a FFF7FEFF 		bl	enu_of_ecef_vect_f
 3449              	.LVL404:
 3450 007e 61E0     		b	.L380
 3451              	.L378:
 902:state.c       ****     }
 903:state.c       ****     else { /* could not get this representation,  set errno */
 904:state.c       ****       errno = 1;
 905:state.c       ****     }
 906:state.c       ****   }
 907:state.c       ****   else if (state.utm_initialized_f) {
 3452              		.loc 1 907 0
 3453 0080 94F8F800 		ldrb	r0, [r4, #248]	@ zero_extendqisi2
 3454 0084 0028     		cmp	r0, #0
 3455 0086 5DD0     		beq	.L380
 908:state.c       ****     if (bit_is_set(state.speed_status, SPEED_NED_F)) {
 3456              		.loc 1 908 0
 3457 0088 6A06     		lsls	r2, r5, #25
 3458 008a 0ED5     		bpl	.L384
 3459              	.L395:
 909:state.c       ****       VECT3_ENU_OF_NED(state.enu_speed_f, state.ned_speed_f);
 3460              		.loc 1 909 0
 3461 008c D4F85811 		ldr	r1, [r4, #344]
 3462 0090 D4F85431 		ldr	r3, [r4, #340]	@ float
 3463 0094 D4F85001 		ldr	r0, [r4, #336]	@ float
 3464 0098 01F10042 		add	r2, r1, #-2147483648
 3465 009c C4F85C31 		str	r3, [r4, #348]	@ float
 3466 00a0 C4F86001 		str	r0, [r4, #352]	@ float
 3467 00a4 C4F86421 		str	r2, [r4, #356]	@ float
 3468 00a8 4CE0     		b	.L380
 3469              	.L384:
 910:state.c       ****     }
 911:state.c       ****     else if (bit_is_set(state.speed_status, SPEED_ENU_I)) {
 3470              		.loc 1 911 0
 3471 00aa 6B07     		lsls	r3, r5, #29
 3472 00ac 1CD5     		bpl	.L385
 3473              	.L399:
 912:state.c       ****       ENU_FLOAT_OF_BFP(state.enu_speed_f, state.enu_speed_i);
 3474              		.loc 1 912 0
 3475 00ae D4F83001 		ldr	r0, [r4, #304]
 3476 00b2 FFF7FEFF 		bl	__aeabi_i2f
 3477              	.LVL405:
 3478 00b6 4FF06E51 		mov	r1, #998244352
 3479 00ba FFF7FEFF 		bl	__aeabi_fmul
 3480              	.LVL406:
 3481 00be C4F85C01 		str	r0, [r4, #348]	@ float
 3482 00c2 D4F83401 		ldr	r0, [r4, #308]
 3483 00c6 FFF7FEFF 		bl	__aeabi_i2f
 3484              	.LVL407:
 3485 00ca 4FF06E51 		mov	r1, #998244352
 3486 00ce FFF7FEFF 		bl	__aeabi_fmul
 3487              	.LVL408:
 3488 00d2 C4F86001 		str	r0, [r4, #352]	@ float
 3489 00d6 D4F83801 		ldr	r0, [r4, #312]
 3490 00da FFF7FEFF 		bl	__aeabi_i2f
 3491              	.LVL409:
 3492 00de 4FF06E51 		mov	r1, #998244352
 3493 00e2 FFF7FEFF 		bl	__aeabi_fmul
 3494              	.LVL410:
 3495 00e6 2BE0     		b	.L396
 3496              	.L385:
 913:state.c       ****     }
 914:state.c       ****     else if (bit_is_set(state.speed_status, SPEED_NED_I)) {
 3497              		.loc 1 914 0
 3498 00e8 A807     		lsls	r0, r5, #30
 3499 00ea 2BD5     		bpl	.L380
 3500              	.L397:
 915:state.c       ****       SPEEDS_FLOAT_OF_BFP(state.ned_speed_f, state.ned_speed_i);
 3501              		.loc 1 915 0
 3502 00ec D4F82401 		ldr	r0, [r4, #292]
 3503 00f0 FFF7FEFF 		bl	__aeabi_i2f
 3504              	.LVL411:
 3505 00f4 4FF05851 		mov	r1, #905969664
 3506 00f8 FFF7FEFF 		bl	__aeabi_fmul
 3507              	.LVL412:
 3508 00fc 0546     		mov	r5, r0
 3509 00fe C4F85001 		str	r0, [r4, #336]	@ float
 3510 0102 D4F82801 		ldr	r0, [r4, #296]
 3511 0106 FFF7FEFF 		bl	__aeabi_i2f
 3512              	.LVL413:
 3513 010a 4FF05851 		mov	r1, #905969664
 3514 010e FFF7FEFF 		bl	__aeabi_fmul
 3515              	.LVL414:
 3516 0112 0646     		mov	r6, r0
 3517 0114 C4F85401 		str	r0, [r4, #340]	@ float
 3518 0118 D4F82C01 		ldr	r0, [r4, #300]
 3519 011c FFF7FEFF 		bl	__aeabi_i2f
 3520              	.LVL415:
 3521 0120 4FF05851 		mov	r1, #905969664
 3522 0124 FFF7FEFF 		bl	__aeabi_fmul
 3523              	.LVL416:
 916:state.c       ****       SetBit(state.pos_status, SPEED_NED_F);
 3524              		.loc 1 916 0
 3525 0128 2188     		ldrh	r1, [r4, #0]
 915:state.c       ****       SPEEDS_FLOAT_OF_BFP(state.ned_speed_f, state.ned_speed_i);
 3526              		.loc 1 915 0
 3527 012a C4F85801 		str	r0, [r4, #344]	@ float
 3528              		.loc 1 916 0
 3529 012e 41F04002 		orr	r2, r1, #64
 3530 0132 2280     		strh	r2, [r4, #0]	@ movhi
 917:state.c       ****       VECT3_ENU_OF_NED(state.enu_speed_f, state.ned_speed_f);
 3531              		.loc 1 917 0
 3532 0134 C4F85C61 		str	r6, [r4, #348]	@ float
 3533 0138 C4F86051 		str	r5, [r4, #352]	@ float
 3534 013c 00F10040 		add	r0, r0, #-2147483648
 3535              	.L396:
 3536 0140 C4F86401 		str	r0, [r4, #356]	@ float
 3537              	.L380:
 918:state.c       ****     }
 919:state.c       ****     else { /* could not get this representation,  set errno */
 920:state.c       ****       errno = 2;
 921:state.c       ****     }
 922:state.c       ****   }
 923:state.c       ****   else { /* ned coordinate system not initialized,  set errno */
 924:state.c       ****     errno = 3;
 925:state.c       ****   }
 926:state.c       ****   if (errno) {
 927:state.c       ****     //struct EnuCoor_f _enu_zero = {0};
 928:state.c       ****     //return _enu_zero;
 929:state.c       ****   }
 930:state.c       ****   /* set bit to indicate this representation is computed */
 931:state.c       ****   SetBit(state.speed_status, SPEED_ENU_F);
 3538              		.loc 1 931 0
 3539 0144 034B     		ldr	r3, .L400
 3540 0146 B3F81401 		ldrh	r0, [r3, #276]
 3541 014a 40F08001 		orr	r1, r0, #128
 3542 014e A3F81411 		strh	r1, [r3, #276]	@ movhi
 3543              	.LVL417:
 3544              	.L376:
 3545 0152 70BD     		pop	{r4, r5, r6, pc}
 3546              	.L401:
 3547              		.align	2
 3548              	.L400:
 3549 0154 00000000 		.word	.LANCHOR0
 3550              		.cfi_endproc
 3551              	.LFE116:
 3553              		.section	.text.stateCalcSpeedEcef_f,"ax",%progbits
 3554              		.align	1
 3555              		.global	stateCalcSpeedEcef_f
 3556              		.thumb
 3557              		.thumb_func
 3559              	stateCalcSpeedEcef_f:
 3560              	.LFB117:
 932:state.c       **** }
 933:state.c       **** 
 934:state.c       **** void stateCalcSpeedEcef_f(void) {
 3561              		.loc 1 934 0
 3562              		.cfi_startproc
 3563              		@ args = 0, pretend = 0, frame = 0
 3564              		@ frame_needed = 0, uses_anonymous_args = 0
 3565 0000 38B5     		push	{r3, r4, r5, lr}
 3566              	.LCFI16:
 3567              		.cfi_def_cfa_offset 16
 3568              		.cfi_offset 3, -16
 3569              		.cfi_offset 4, -12
 3570              		.cfi_offset 5, -8
 3571              		.cfi_offset 14, -4
 935:state.c       ****   if (bit_is_set(state.speed_status, SPEED_ECEF_F))
 3572              		.loc 1 935 0
 3573 0002 2E4C     		ldr	r4, .L411
 3574 0004 B4F81451 		ldrh	r5, [r4, #276]
 3575 0008 A806     		lsls	r0, r5, #26
 3576 000a 55D4     		bmi	.L402
 936:state.c       ****     return;
 937:state.c       **** 
 938:state.c       ****   if (bit_is_set(state.speed_status, SPEED_ECEF_I)) {
 3577              		.loc 1 938 0
 3578 000c E907     		lsls	r1, r5, #31
 3579 000e 1ED5     		bpl	.L404
 939:state.c       ****     SPEEDS_FLOAT_OF_BFP(state.ecef_speed_f, state.ned_speed_i);
 3580              		.loc 1 939 0
 3581 0010 D4F82401 		ldr	r0, [r4, #292]
 3582 0014 FFF7FEFF 		bl	__aeabi_i2f
 3583              	.LVL418:
 3584 0018 4FF05851 		mov	r1, #905969664
 3585 001c FFF7FEFF 		bl	__aeabi_fmul
 3586              	.LVL419:
 3587 0020 C4F84401 		str	r0, [r4, #324]	@ float
 3588 0024 D4F82801 		ldr	r0, [r4, #296]
 3589 0028 FFF7FEFF 		bl	__aeabi_i2f
 3590              	.LVL420:
 3591 002c 4FF05851 		mov	r1, #905969664
 3592 0030 FFF7FEFF 		bl	__aeabi_fmul
 3593              	.LVL421:
 3594 0034 C4F84801 		str	r0, [r4, #328]	@ float
 3595 0038 D4F82C01 		ldr	r0, [r4, #300]
 3596 003c FFF7FEFF 		bl	__aeabi_i2f
 3597              	.LVL422:
 3598 0040 4FF05851 		mov	r1, #905969664
 3599 0044 FFF7FEFF 		bl	__aeabi_fmul
 3600              	.LVL423:
 3601 0048 C4F84C01 		str	r0, [r4, #332]	@ float
 3602 004c 2DE0     		b	.L405
 3603              	.L404:
 940:state.c       ****   }
 941:state.c       ****   else if (bit_is_set(state.speed_status, SPEED_NED_F)) {
 3604              		.loc 1 941 0
 3605 004e 6A06     		lsls	r2, r5, #25
 3606 0050 23D4     		bmi	.L410
 3607              	.L406:
 942:state.c       ****     ecef_of_ned_vect_f(&state.ecef_speed_f, &state.ned_origin_f, &state.ned_speed_f);
 943:state.c       ****   }
 944:state.c       ****   else if (bit_is_set(state.speed_status, SPEED_NED_I)) {
 3608              		.loc 1 944 0
 3609 0052 AB07     		lsls	r3, r5, #30
 3610 0054 29D5     		bpl	.L405
 945:state.c       ****     /* transform ned_f -> ned_i -> ecef_i , set status bits */
 946:state.c       ****     SPEEDS_FLOAT_OF_BFP(state.ned_speed_f, state.ned_speed_i);
 3611              		.loc 1 946 0
 3612 0056 D4F82401 		ldr	r0, [r4, #292]
 3613 005a FFF7FEFF 		bl	__aeabi_i2f
 3614              	.LVL424:
 3615 005e 4FF05851 		mov	r1, #905969664
 3616 0062 FFF7FEFF 		bl	__aeabi_fmul
 3617              	.LVL425:
 3618 0066 C4F85001 		str	r0, [r4, #336]	@ float
 3619 006a D4F82801 		ldr	r0, [r4, #296]
 3620 006e FFF7FEFF 		bl	__aeabi_i2f
 3621              	.LVL426:
 3622 0072 4FF05851 		mov	r1, #905969664
 3623 0076 FFF7FEFF 		bl	__aeabi_fmul
 3624              	.LVL427:
 3625 007a C4F85401 		str	r0, [r4, #340]	@ float
 3626 007e D4F82C01 		ldr	r0, [r4, #300]
 3627 0082 FFF7FEFF 		bl	__aeabi_i2f
 3628              	.LVL428:
 3629 0086 4FF05851 		mov	r1, #905969664
 3630 008a FFF7FEFF 		bl	__aeabi_fmul
 3631              	.LVL429:
 947:state.c       ****     SetBit(state.speed_status, SPEED_NED_F);
 3632              		.loc 1 947 0
 3633 008e 45F04005 		orr	r5, r5, #64
 946:state.c       ****     SPEEDS_FLOAT_OF_BFP(state.ned_speed_f, state.ned_speed_i);
 3634              		.loc 1 946 0
 3635 0092 C4F85801 		str	r0, [r4, #344]	@ float
 3636              		.loc 1 947 0
 3637 0096 A4F81451 		strh	r5, [r4, #276]	@ movhi
 3638              	.L410:
 948:state.c       ****     ecef_of_ned_vect_f(&state.ecef_speed_f, &state.ned_origin_f, &state.ned_speed_f);
 3639              		.loc 1 948 0
 3640 009a 04F5A270 		add	r0, r4, #324
 3641 009e 04F1A401 		add	r1, r4, #164
 3642 00a2 04F5A872 		add	r2, r4, #336
 3643 00a6 FFF7FEFF 		bl	ecef_of_ned_vect_f
 3644              	.LVL430:
 3645              	.L405:
 949:state.c       ****   }
 950:state.c       ****   else {
 951:state.c       ****     /* could not get this representation,  set errno */
 952:state.c       ****     //struct EcefCoor_f _ecef_zero = {0.0f};
 953:state.c       ****     //return _ecef_zero;
 954:state.c       ****   }
 955:state.c       ****   /* set bit to indicate this representation is computed */
 956:state.c       ****   SetBit(state.speed_status, SPEED_ECEF_F);
 3646              		.loc 1 956 0
 3647 00aa 044B     		ldr	r3, .L411
 3648 00ac B3F81421 		ldrh	r2, [r3, #276]
 3649 00b0 42F02000 		orr	r0, r2, #32
 3650 00b4 A3F81401 		strh	r0, [r3, #276]	@ movhi
 3651              	.L402:
 3652 00b8 38BD     		pop	{r3, r4, r5, pc}
 3653              	.L412:
 3654 00ba 00BF     		.align	2
 3655              	.L411:
 3656 00bc 00000000 		.word	.LANCHOR0
 3657              		.cfi_endproc
 3658              	.LFE117:
 3660              		.section	.text.stateCalcHorizontalSpeedNorm_f,"ax",%progbits
 3661              		.align	1
 3662              		.global	stateCalcHorizontalSpeedNorm_f
 3663              		.thumb
 3664              		.thumb_func
 3666              	stateCalcHorizontalSpeedNorm_f:
 3667              	.LFB118:
 957:state.c       **** }
 958:state.c       **** 
 959:state.c       **** void stateCalcHorizontalSpeedNorm_f(void) {
 3668              		.loc 1 959 0
 3669              		.cfi_startproc
 3670              		@ args = 0, pretend = 0, frame = 0
 3671              		@ frame_needed = 0, uses_anonymous_args = 0
 3672 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 3673              	.LCFI17:
 3674              		.cfi_def_cfa_offset 24
 3675              		.cfi_offset 3, -24
 3676              		.cfi_offset 4, -20
 3677              		.cfi_offset 5, -16
 3678              		.cfi_offset 6, -12
 3679              		.cfi_offset 7, -8
 3680              		.cfi_offset 14, -4
 960:state.c       ****   if (bit_is_set(state.speed_status, SPEED_HNORM_F))
 3681              		.loc 1 960 0
 3682 0002 414C     		ldr	r4, .L426
 3683 0004 B4F81451 		ldrh	r5, [r4, #276]
 3684 0008 EA05     		lsls	r2, r5, #23
 3685 000a 7BD4     		bmi	.L413
 961:state.c       ****     return;
 962:state.c       **** 
 963:state.c       ****   if (bit_is_set(state.speed_status, SPEED_HNORM_I)){
 3686              		.loc 1 963 0
 3687 000c 2B07     		lsls	r3, r5, #28
 3688 000e 08D5     		bpl	.L415
 964:state.c       ****     state.h_speed_norm_f = SPEED_FLOAT_OF_BFP(state.h_speed_norm_i);
 3689              		.loc 1 964 0
 3690 0010 D4F83C01 		ldr	r0, [r4, #316]
 3691 0014 FFF7FEFF 		bl	__aeabi_i2f
 3692              	.LVL431:
 3693 0018 4FF05851 		mov	r1, #905969664
 3694 001c FFF7FEFF 		bl	__aeabi_fmul
 3695              	.LVL432:
 3696 0020 67E0     		b	.L423
 3697              	.L415:
 965:state.c       ****   }
 966:state.c       ****   else if (bit_is_set(state.speed_status, SPEED_NED_F)) {
 3698              		.loc 1 966 0
 3699 0022 6806     		lsls	r0, r5, #25
 3700 0024 04D5     		bpl	.L417
 967:state.c       ****     FLOAT_VECT2_NORM(state.h_speed_norm_f, state.ned_speed_f);
 3701              		.loc 1 967 0
 3702 0026 D4F85001 		ldr	r0, [r4, #336]	@ float
 3703 002a D4F85461 		ldr	r6, [r4, #340]	@ float
 3704 002e 52E0     		b	.L425
 3705              	.L417:
 968:state.c       ****   }
 969:state.c       ****   else if (bit_is_set(state.speed_status, SPEED_ENU_F)) {
 3706              		.loc 1 969 0
 3707 0030 2906     		lsls	r1, r5, #24
 3708 0032 04D5     		bpl	.L418
 970:state.c       ****     FLOAT_VECT2_NORM(state.h_speed_norm_f, state.enu_speed_f);
 3709              		.loc 1 970 0
 3710 0034 D4F85C01 		ldr	r0, [r4, #348]	@ float
 3711 0038 D4F86061 		ldr	r6, [r4, #352]	@ float
 3712 003c 4BE0     		b	.L425
 3713              	.L418:
 971:state.c       ****   }
 972:state.c       ****   else if (bit_is_set(state.speed_status, SPEED_NED_I)) {
 3714              		.loc 1 972 0
 3715 003e AA07     		lsls	r2, r5, #30
 3716 0040 22D5     		bpl	.L419
 973:state.c       ****     SPEEDS_FLOAT_OF_BFP(state.ned_speed_f, state.ned_speed_i);
 3717              		.loc 1 973 0
 3718 0042 D4F82401 		ldr	r0, [r4, #292]
 3719 0046 FFF7FEFF 		bl	__aeabi_i2f
 3720              	.LVL433:
 3721 004a 4FF05851 		mov	r1, #905969664
 3722 004e FFF7FEFF 		bl	__aeabi_fmul
 3723              	.LVL434:
 3724 0052 C4F85001 		str	r0, [r4, #336]	@ float
 3725 0056 0746     		mov	r7, r0
 3726 0058 D4F82801 		ldr	r0, [r4, #296]
 3727 005c FFF7FEFF 		bl	__aeabi_i2f
 3728              	.LVL435:
 3729 0060 4FF05851 		mov	r1, #905969664
 3730 0064 FFF7FEFF 		bl	__aeabi_fmul
 3731              	.LVL436:
 3732 0068 C4F85401 		str	r0, [r4, #340]	@ float
 3733 006c 0646     		mov	r6, r0
 3734 006e D4F82C01 		ldr	r0, [r4, #300]
 3735 0072 FFF7FEFF 		bl	__aeabi_i2f
 3736              	.LVL437:
 3737 0076 4FF05851 		mov	r1, #905969664
 3738 007a FFF7FEFF 		bl	__aeabi_fmul
 3739              	.LVL438:
 974:state.c       ****     SetBit(state.speed_status, SPEED_NED_F);
 3740              		.loc 1 974 0
 3741 007e 45F04005 		orr	r5, r5, #64
 973:state.c       ****     SPEEDS_FLOAT_OF_BFP(state.ned_speed_f, state.ned_speed_i);
 3742              		.loc 1 973 0
 3743 0082 C4F85801 		str	r0, [r4, #344]	@ float
 3744 0086 23E0     		b	.L424
 3745              	.L419:
 975:state.c       ****     FLOAT_VECT2_NORM(state.h_speed_norm_f, state.ned_speed_f);
 976:state.c       ****   }
 977:state.c       ****   else if (bit_is_set(state.speed_status, SPEED_ENU_I)) {
 3746              		.loc 1 977 0
 3747 0088 6B07     		lsls	r3, r5, #29
 3748 008a 34D5     		bpl	.L416
 978:state.c       ****     SPEEDS_FLOAT_OF_BFP(state.enu_speed_f, state.enu_speed_i);
 3749              		.loc 1 978 0
 3750 008c D4F83001 		ldr	r0, [r4, #304]
 3751 0090 FFF7FEFF 		bl	__aeabi_i2f
 3752              	.LVL439:
 3753 0094 4FF05851 		mov	r1, #905969664
 3754 0098 FFF7FEFF 		bl	__aeabi_fmul
 3755              	.LVL440:
 3756 009c C4F85C01 		str	r0, [r4, #348]	@ float
 3757 00a0 0746     		mov	r7, r0
 3758 00a2 D4F83401 		ldr	r0, [r4, #308]
 3759 00a6 FFF7FEFF 		bl	__aeabi_i2f
 3760              	.LVL441:
 3761 00aa 4FF05851 		mov	r1, #905969664
 3762 00ae FFF7FEFF 		bl	__aeabi_fmul
 3763              	.LVL442:
 3764 00b2 C4F86001 		str	r0, [r4, #352]	@ float
 3765 00b6 0646     		mov	r6, r0
 3766 00b8 D4F83801 		ldr	r0, [r4, #312]
 3767 00bc FFF7FEFF 		bl	__aeabi_i2f
 3768              	.LVL443:
 3769 00c0 4FF05851 		mov	r1, #905969664
 3770 00c4 FFF7FEFF 		bl	__aeabi_fmul
 3771              	.LVL444:
 979:state.c       ****     SetBit(state.speed_status, SPEED_ENU_F);
 3772              		.loc 1 979 0
 3773 00c8 45F08005 		orr	r5, r5, #128
 978:state.c       ****     SPEEDS_FLOAT_OF_BFP(state.enu_speed_f, state.enu_speed_i);
 3774              		.loc 1 978 0
 3775 00cc C4F86401 		str	r0, [r4, #356]	@ float
 3776              	.L424:
 3777              		.loc 1 979 0
 3778 00d0 A4F81451 		strh	r5, [r4, #276]	@ movhi
 980:state.c       ****     FLOAT_VECT2_NORM(state.h_speed_norm_f, state.enu_speed_f);
 3779              		.loc 1 980 0
 3780 00d4 3846     		mov	r0, r7
 3781              	.L425:
 3782 00d6 0146     		mov	r1, r0
 3783 00d8 FFF7FEFF 		bl	__aeabi_fmul
 3784              	.LVL445:
 3785 00dc 3146     		mov	r1, r6
 3786 00de 0546     		mov	r5, r0
 3787 00e0 3046     		mov	r0, r6
 3788 00e2 FFF7FEFF 		bl	__aeabi_fmul
 3789              	.LVL446:
 3790 00e6 0146     		mov	r1, r0
 3791 00e8 2846     		mov	r0, r5
 3792 00ea FFF7FEFF 		bl	__aeabi_fadd
 3793              	.LVL447:
 3794 00ee FFF7FEFF 		bl	sqrtf
 3795              	.LVL448:
 3796              	.L423:
 3797 00f2 C4F86801 		str	r0, [r4, #360]	@ float
 3798              	.L416:
 981:state.c       ****   }
 982:state.c       ****   /* set bit to indicate this representation is computed */
 983:state.c       ****   SetBit(state.speed_status, SPEED_HNORM_F);
 3799              		.loc 1 983 0
 3800 00f6 044B     		ldr	r3, .L426
 3801 00f8 B3F81421 		ldrh	r2, [r3, #276]
 3802 00fc 42F48070 		orr	r0, r2, #256
 3803 0100 A3F81401 		strh	r0, [r3, #276]	@ movhi
 3804              	.L413:
 3805 0104 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 3806              	.L427:
 3807 0106 00BF     		.align	2
 3808              	.L426:
 3809 0108 00000000 		.word	.LANCHOR0
 3810              		.cfi_endproc
 3811              	.LFE118:
 3813              		.section	.text.stateCalcHorizontalSpeedDir_f,"ax",%progbits
 3814              		.align	1
 3815              		.global	stateCalcHorizontalSpeedDir_f
 3816              		.thumb
 3817              		.thumb_func
 3819              	stateCalcHorizontalSpeedDir_f:
 3820              	.LFB119:
 984:state.c       **** }
 985:state.c       **** 
 986:state.c       **** void stateCalcHorizontalSpeedDir_f(void) {
 3821              		.loc 1 986 0
 3822              		.cfi_startproc
 3823              		@ args = 0, pretend = 0, frame = 0
 3824              		@ frame_needed = 0, uses_anonymous_args = 0
 3825 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 3826              	.LCFI18:
 3827              		.cfi_def_cfa_offset 24
 3828              		.cfi_offset 3, -24
 3829              		.cfi_offset 4, -20
 3830              		.cfi_offset 5, -16
 3831              		.cfi_offset 6, -12
 3832              		.cfi_offset 7, -8
 3833              		.cfi_offset 14, -4
 987:state.c       ****   if (bit_is_set(state.speed_status, SPEED_HDIR_F))
 3834              		.loc 1 987 0
 3835 0002 3B4C     		ldr	r4, .L441
 3836 0004 B4F81451 		ldrh	r5, [r4, #276]
 3837 0008 A805     		lsls	r0, r5, #22
 3838 000a 70D4     		bmi	.L428
 988:state.c       ****     return;
 989:state.c       **** 
 990:state.c       ****   if (bit_is_set(state.speed_status, SPEED_HDIR_I)){
 3839              		.loc 1 990 0
 3840 000c E906     		lsls	r1, r5, #27
 3841 000e 08D5     		bpl	.L430
 991:state.c       ****     state.h_speed_dir_f = SPEED_FLOAT_OF_BFP(state.h_speed_dir_i);
 3842              		.loc 1 991 0
 3843 0010 D4F84001 		ldr	r0, [r4, #320]
 3844 0014 FFF7FEFF 		bl	__aeabi_i2f
 3845              	.LVL449:
 3846 0018 4FF05851 		mov	r1, #905969664
 3847 001c FFF7FEFF 		bl	__aeabi_fmul
 3848              	.LVL450:
 3849 0020 5CE0     		b	.L438
 3850              	.L430:
 992:state.c       ****   }
 993:state.c       ****   else if (bit_is_set(state.speed_status, SPEED_NED_F)) {
 3851              		.loc 1 993 0
 3852 0022 6A06     		lsls	r2, r5, #25
 3853 0024 04D5     		bpl	.L432
 994:state.c       ****     state.h_speed_dir_f = atan2f(state.ned_speed_f.y, state.ned_speed_f.x);
 3854              		.loc 1 994 0
 3855 0026 D4F85401 		ldr	r0, [r4, #340]	@ float
 3856 002a D4F85011 		ldr	r1, [r4, #336]	@ float
 3857 002e 53E0     		b	.L440
 3858              	.L432:
 995:state.c       ****   }
 996:state.c       ****   else if (bit_is_set(state.speed_status, SPEED_ENU_F)) {
 3859              		.loc 1 996 0
 3860 0030 2B06     		lsls	r3, r5, #24
 3861 0032 04D5     		bpl	.L433
 997:state.c       ****     state.h_speed_dir_f = atan2f(state.enu_speed_f.x, state.enu_speed_f.y);
 3862              		.loc 1 997 0
 3863 0034 D4F85C01 		ldr	r0, [r4, #348]	@ float
 3864 0038 D4F86011 		ldr	r1, [r4, #352]	@ float
 3865 003c 4CE0     		b	.L440
 3866              	.L433:
 998:state.c       ****   }
 999:state.c       ****   else if (bit_is_set(state.speed_status, SPEED_NED_I)) {
 3867              		.loc 1 999 0
 3868 003e A807     		lsls	r0, r5, #30
 3869 0040 22D5     		bpl	.L434
1000:state.c       ****     SPEEDS_FLOAT_OF_BFP(state.ned_speed_f, state.ned_speed_i);
 3870              		.loc 1 1000 0
 3871 0042 D4F82401 		ldr	r0, [r4, #292]
 3872 0046 FFF7FEFF 		bl	__aeabi_i2f
 3873              	.LVL451:
 3874 004a 4FF05851 		mov	r1, #905969664
 3875 004e FFF7FEFF 		bl	__aeabi_fmul
 3876              	.LVL452:
 3877 0052 C4F85001 		str	r0, [r4, #336]	@ float
 3878 0056 0646     		mov	r6, r0
 3879 0058 D4F82801 		ldr	r0, [r4, #296]
 3880 005c FFF7FEFF 		bl	__aeabi_i2f
 3881              	.LVL453:
 3882 0060 4FF05851 		mov	r1, #905969664
 3883 0064 FFF7FEFF 		bl	__aeabi_fmul
 3884              	.LVL454:
 3885 0068 C4F85401 		str	r0, [r4, #340]	@ float
 3886 006c 0746     		mov	r7, r0
 3887 006e D4F82C01 		ldr	r0, [r4, #300]
 3888 0072 FFF7FEFF 		bl	__aeabi_i2f
 3889              	.LVL455:
 3890 0076 4FF05851 		mov	r1, #905969664
 3891 007a FFF7FEFF 		bl	__aeabi_fmul
 3892              	.LVL456:
1001:state.c       ****     SetBit(state.speed_status, SPEED_NED_F);
 3893              		.loc 1 1001 0
 3894 007e 45F04005 		orr	r5, r5, #64
1000:state.c       ****     SPEEDS_FLOAT_OF_BFP(state.ned_speed_f, state.ned_speed_i);
 3895              		.loc 1 1000 0
 3896 0082 C4F85801 		str	r0, [r4, #344]	@ float
 3897 0086 23E0     		b	.L439
 3898              	.L434:
1002:state.c       ****     state.h_speed_dir_f = atan2f(state.ned_speed_f.y, state.ned_speed_f.x);
1003:state.c       ****   }
1004:state.c       ****   else if (bit_is_set(state.speed_status, SPEED_ENU_I)) {
 3899              		.loc 1 1004 0
 3900 0088 6907     		lsls	r1, r5, #29
 3901 008a 29D5     		bpl	.L431
1005:state.c       ****     SPEEDS_FLOAT_OF_BFP(state.enu_speed_f, state.enu_speed_i);
 3902              		.loc 1 1005 0
 3903 008c D4F83001 		ldr	r0, [r4, #304]
 3904 0090 FFF7FEFF 		bl	__aeabi_i2f
 3905              	.LVL457:
 3906 0094 4FF05851 		mov	r1, #905969664
 3907 0098 FFF7FEFF 		bl	__aeabi_fmul
 3908              	.LVL458:
 3909 009c C4F85C01 		str	r0, [r4, #348]	@ float
 3910 00a0 0746     		mov	r7, r0
 3911 00a2 D4F83401 		ldr	r0, [r4, #308]
 3912 00a6 FFF7FEFF 		bl	__aeabi_i2f
 3913              	.LVL459:
 3914 00aa 4FF05851 		mov	r1, #905969664
 3915 00ae FFF7FEFF 		bl	__aeabi_fmul
 3916              	.LVL460:
 3917 00b2 C4F86001 		str	r0, [r4, #352]	@ float
 3918 00b6 0646     		mov	r6, r0
 3919 00b8 D4F83801 		ldr	r0, [r4, #312]
 3920 00bc FFF7FEFF 		bl	__aeabi_i2f
 3921              	.LVL461:
 3922 00c0 4FF05851 		mov	r1, #905969664
 3923 00c4 FFF7FEFF 		bl	__aeabi_fmul
 3924              	.LVL462:
1006:state.c       ****     SetBit(state.speed_status, SPEED_ENU_F);
 3925              		.loc 1 1006 0
 3926 00c8 45F08005 		orr	r5, r5, #128
1005:state.c       ****     SPEEDS_FLOAT_OF_BFP(state.enu_speed_f, state.enu_speed_i);
 3927              		.loc 1 1005 0
 3928 00cc C4F86401 		str	r0, [r4, #356]	@ float
 3929              	.L439:
 3930              		.loc 1 1006 0
 3931 00d0 A4F81451 		strh	r5, [r4, #276]	@ movhi
1007:state.c       ****     state.h_speed_dir_f = atan2f(state.enu_speed_f.x, state.enu_speed_f.y);
 3932              		.loc 1 1007 0
 3933 00d4 3846     		mov	r0, r7
 3934 00d6 3146     		mov	r1, r6
 3935              	.L440:
 3936 00d8 FFF7FEFF 		bl	atan2f
 3937              	.LVL463:
 3938              	.L438:
 3939 00dc C4F86C01 		str	r0, [r4, #364]	@ float
 3940              	.L431:
1008:state.c       ****   }
1009:state.c       ****   /* set bit to indicate this representation is computed */
1010:state.c       ****   SetBit(state.speed_status, SPEED_HDIR_F);
 3941              		.loc 1 1010 0
 3942 00e0 034B     		ldr	r3, .L441
 3943 00e2 B3F81421 		ldrh	r2, [r3, #276]
 3944 00e6 42F40070 		orr	r0, r2, #512
 3945 00ea A3F81401 		strh	r0, [r3, #276]	@ movhi
 3946              	.L428:
 3947 00ee F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 3948              	.L442:
 3949              		.align	2
 3950              	.L441:
 3951 00f0 00000000 		.word	.LANCHOR0
 3952              		.cfi_endproc
 3953              	.LFE119:
 3955              		.section	.text.stateCalcAccelNed_i,"ax",%progbits
 3956              		.align	1
 3957              		.global	stateCalcAccelNed_i
 3958              		.thumb
 3959              		.thumb_func
 3961              	stateCalcAccelNed_i:
 3962              	.LFB120:
1011:state.c       **** }
1012:state.c       **** /** @}*/
1013:state.c       **** 
1014:state.c       **** 
1015:state.c       **** 
1016:state.c       **** /******************************************************************************
1017:state.c       ****  *                                                                            *
1018:state.c       ****  * Transformation functions for the ACCELERATION representations              *
1019:state.c       ****  *                                                                            *
1020:state.c       ****  *****************************************************************************/
1021:state.c       **** /** @addtogroup state_acceleration
1022:state.c       ****  *  @{ */
1023:state.c       **** 
1024:state.c       **** void stateCalcAccelNed_i(void) {
 3963              		.loc 1 1024 0
 3964              		.cfi_startproc
 3965              		@ args = 0, pretend = 0, frame = 0
 3966              		@ frame_needed = 0, uses_anonymous_args = 0
 3967 0000 38B5     		push	{r3, r4, r5, lr}
 3968              	.LCFI19:
 3969              		.cfi_def_cfa_offset 16
 3970              		.cfi_offset 3, -16
 3971              		.cfi_offset 4, -12
 3972              		.cfi_offset 5, -8
 3973              		.cfi_offset 14, -4
1025:state.c       ****   if (bit_is_set(state.accel_status, ACCEL_NED_I))
 3974              		.loc 1 1025 0
 3975 0002 304C     		ldr	r4, .L455
 3976 0004 94F87051 		ldrb	r5, [r4, #368]	@ zero_extendqisi2
 3977 0008 A807     		lsls	r0, r5, #30
 3978 000a 59D4     		bmi	.L443
 3979              	.LVL464:
1026:state.c       ****     return;
1027:state.c       **** 
1028:state.c       ****   int errno = 0;
1029:state.c       ****   if (state.ned_initialized_i) {
 3980              		.loc 1 1029 0
 3981 000c 94F85C30 		ldrb	r3, [r4, #92]	@ zero_extendqisi2
 3982 0010 002B     		cmp	r3, #0
 3983 0012 4ED0     		beq	.L445
1030:state.c       ****     if (bit_is_set(state.accel_status, ACCEL_NED_F)) {
 3984              		.loc 1 1030 0
 3985 0014 2907     		lsls	r1, r5, #28
 3986 0016 1ED5     		bpl	.L446
1031:state.c       ****       ACCELS_BFP_OF_REAL(state.ned_accel_i, state.ned_accel_f);
 3987              		.loc 1 1031 0
 3988 0018 4FF08941 		mov	r1, #1149239296
 3989 001c D4F88C01 		ldr	r0, [r4, #396]	@ float
 3990 0020 FFF7FEFF 		bl	__aeabi_fmul
 3991              	.LVL465:
 3992 0024 FFF7FEFF 		bl	__aeabi_f2iz
 3993              	.LVL466:
 3994 0028 4FF08941 		mov	r1, #1149239296
 3995 002c C4F87401 		str	r0, [r4, #372]
 3996 0030 D4F89001 		ldr	r0, [r4, #400]	@ float
 3997 0034 FFF7FEFF 		bl	__aeabi_fmul
 3998              	.LVL467:
 3999 0038 FFF7FEFF 		bl	__aeabi_f2iz
 4000              	.LVL468:
 4001 003c 4FF08941 		mov	r1, #1149239296
 4002 0040 C4F87801 		str	r0, [r4, #376]
 4003 0044 D4F89401 		ldr	r0, [r4, #404]	@ float
 4004 0048 FFF7FEFF 		bl	__aeabi_fmul
 4005              	.LVL469:
 4006 004c FFF7FEFF 		bl	__aeabi_f2iz
 4007              	.LVL470:
 4008 0050 C4F87C01 		str	r0, [r4, #380]
 4009 0054 2DE0     		b	.L445
 4010              	.L446:
1032:state.c       ****     }
1033:state.c       ****     else if (bit_is_set(state.accel_status, ACCEL_ECEF_I)) {
 4011              		.loc 1 1033 0
 4012 0056 EA07     		lsls	r2, r5, #31
 4013 0058 23D4     		bmi	.L454
 4014              	.L447:
1034:state.c       ****       ned_of_ecef_vect_i(&state.ned_accel_i, &state.ned_origin_i, &state.ecef_accel_i);
1035:state.c       ****     }
1036:state.c       ****     else if (bit_is_set(state.accel_status, ACCEL_ECEF_F)) {
 4015              		.loc 1 1036 0
 4016 005a 6B07     		lsls	r3, r5, #29
 4017 005c 29D5     		bpl	.L445
1037:state.c       ****       /* transform ecef_f -> ecef_i -> ned_i , set status bits */
1038:state.c       ****       ACCELS_BFP_OF_REAL(state.ecef_accel_i, state.ecef_accel_f);
 4018              		.loc 1 1038 0
 4019 005e 4FF08941 		mov	r1, #1149239296
 4020 0062 D4F89801 		ldr	r0, [r4, #408]	@ float
 4021 0066 FFF7FEFF 		bl	__aeabi_fmul
 4022              	.LVL471:
 4023 006a FFF7FEFF 		bl	__aeabi_f2iz
 4024              	.LVL472:
 4025 006e 4FF08941 		mov	r1, #1149239296
 4026 0072 C4F88001 		str	r0, [r4, #384]
 4027 0076 D4F89C01 		ldr	r0, [r4, #412]	@ float
 4028 007a FFF7FEFF 		bl	__aeabi_fmul
 4029              	.LVL473:
 4030 007e FFF7FEFF 		bl	__aeabi_f2iz
 4031              	.LVL474:
 4032 0082 4FF08941 		mov	r1, #1149239296
 4033 0086 C4F88401 		str	r0, [r4, #388]
 4034 008a D4F8A001 		ldr	r0, [r4, #416]	@ float
 4035 008e FFF7FEFF 		bl	__aeabi_fmul
 4036              	.LVL475:
 4037 0092 FFF7FEFF 		bl	__aeabi_f2iz
 4038              	.LVL476:
1039:state.c       ****       SetBit(state.accel_status, ACCEL_ECEF_I);
 4039              		.loc 1 1039 0
 4040 0096 45F00105 		orr	r5, r5, #1
1038:state.c       ****       ACCELS_BFP_OF_REAL(state.ecef_accel_i, state.ecef_accel_f);
 4041              		.loc 1 1038 0
 4042 009a C4F88801 		str	r0, [r4, #392]
 4043              		.loc 1 1039 0
 4044 009e 84F87051 		strb	r5, [r4, #368]
 4045              	.L454:
1040:state.c       ****       ned_of_ecef_vect_i(&state.ned_accel_i, &state.ned_origin_i, &state.ecef_accel_i);
 4046              		.loc 1 1040 0
 4047 00a2 04F5BA70 		add	r0, r4, #372
 4048 00a6 04F11C01 		add	r1, r4, #28
 4049 00aa 04F5C072 		add	r2, r4, #384
 4050 00ae FFF7FEFF 		bl	ned_of_ecef_vect_i
 4051              	.LVL477:
 4052              	.L445:
1041:state.c       ****     }
1042:state.c       ****     else { /* could not get this representation,  set errno */
1043:state.c       ****       errno = 1;
1044:state.c       ****     }
1045:state.c       ****   } else { /* ned coordinate system not initialized,  set errno */
1046:state.c       ****     errno = 2;
1047:state.c       ****   }
1048:state.c       ****   if (errno) {
1049:state.c       ****     //struct NedCoor_i _ned_zero = {0};
1050:state.c       ****     //return _ned_zero;
1051:state.c       ****   }
1052:state.c       ****   /* set bit to indicate this representation is computed */
1053:state.c       ****   SetBit(state.accel_status, ACCEL_NED_I);
 4053              		.loc 1 1053 0
 4054 00b2 0448     		ldr	r0, .L455
 4055 00b4 90F87021 		ldrb	r2, [r0, #368]	@ zero_extendqisi2
 4056 00b8 42F00201 		orr	r1, r2, #2
 4057 00bc 80F87011 		strb	r1, [r0, #368]
 4058              	.LVL478:
 4059              	.L443:
 4060 00c0 38BD     		pop	{r3, r4, r5, pc}
 4061              	.L456:
 4062 00c2 00BF     		.align	2
 4063              	.L455:
 4064 00c4 00000000 		.word	.LANCHOR0
 4065              		.cfi_endproc
 4066              	.LFE120:
 4068              		.section	.text.stateCalcAccelEcef_i,"ax",%progbits
 4069              		.align	1
 4070              		.global	stateCalcAccelEcef_i
 4071              		.thumb
 4072              		.thumb_func
 4074              	stateCalcAccelEcef_i:
 4075              	.LFB121:
1054:state.c       **** }
1055:state.c       **** 
1056:state.c       **** void stateCalcAccelEcef_i(void) {
 4076              		.loc 1 1056 0
 4077              		.cfi_startproc
 4078              		@ args = 0, pretend = 0, frame = 0
 4079              		@ frame_needed = 0, uses_anonymous_args = 0
 4080 0000 38B5     		push	{r3, r4, r5, lr}
 4081              	.LCFI20:
 4082              		.cfi_def_cfa_offset 16
 4083              		.cfi_offset 3, -16
 4084              		.cfi_offset 4, -12
 4085              		.cfi_offset 5, -8
 4086              		.cfi_offset 14, -4
1057:state.c       ****   if (bit_is_set(state.accel_status, ACCEL_ECEF_I))
 4087              		.loc 1 1057 0
 4088 0002 2E4C     		ldr	r4, .L466
 4089 0004 94F87051 		ldrb	r5, [r4, #368]	@ zero_extendqisi2
 4090 0008 E807     		lsls	r0, r5, #31
 4091 000a 55D4     		bmi	.L457
1058:state.c       ****     return;
1059:state.c       **** 
1060:state.c       ****   if (bit_is_set(state.accel_status, ACCEL_ECEF_F)) {
 4092              		.loc 1 1060 0
 4093 000c 6907     		lsls	r1, r5, #29
 4094 000e 1ED5     		bpl	.L459
1061:state.c       ****     ACCELS_BFP_OF_REAL(state.ecef_accel_i, state.ecef_accel_f);
 4095              		.loc 1 1061 0
 4096 0010 4FF08941 		mov	r1, #1149239296
 4097 0014 D4F89801 		ldr	r0, [r4, #408]	@ float
 4098 0018 FFF7FEFF 		bl	__aeabi_fmul
 4099              	.LVL479:
 4100 001c FFF7FEFF 		bl	__aeabi_f2iz
 4101              	.LVL480:
 4102 0020 4FF08941 		mov	r1, #1149239296
 4103 0024 C4F88001 		str	r0, [r4, #384]
 4104 0028 D4F89C01 		ldr	r0, [r4, #412]	@ float
 4105 002c FFF7FEFF 		bl	__aeabi_fmul
 4106              	.LVL481:
 4107 0030 FFF7FEFF 		bl	__aeabi_f2iz
 4108              	.LVL482:
 4109 0034 4FF08941 		mov	r1, #1149239296
 4110 0038 C4F88401 		str	r0, [r4, #388]
 4111 003c D4F8A001 		ldr	r0, [r4, #416]	@ float
 4112 0040 FFF7FEFF 		bl	__aeabi_fmul
 4113              	.LVL483:
 4114 0044 FFF7FEFF 		bl	__aeabi_f2iz
 4115              	.LVL484:
 4116 0048 C4F88801 		str	r0, [r4, #392]
 4117 004c 2DE0     		b	.L460
 4118              	.L459:
1062:state.c       ****   }
1063:state.c       ****   else if (bit_is_set(state.accel_status, ACCEL_NED_I)) {
 4119              		.loc 1 1063 0
 4120 004e AA07     		lsls	r2, r5, #30
 4121 0050 23D4     		bmi	.L465
 4122              	.L461:
1064:state.c       ****     ecef_of_ned_vect_i(&state.ecef_accel_i, &state.ned_origin_i, &state.ned_accel_i);
1065:state.c       ****   }
1066:state.c       ****   else if (bit_is_set(state.accel_status, ACCEL_NED_F)) {
 4123              		.loc 1 1066 0
 4124 0052 2B07     		lsls	r3, r5, #28
 4125 0054 29D5     		bpl	.L460
1067:state.c       ****     /* transform ned_f -> ned_i -> ecef_i , set status bits */
1068:state.c       ****     ACCELS_BFP_OF_REAL(state.ned_accel_i, state.ned_accel_f);
 4126              		.loc 1 1068 0
 4127 0056 4FF08941 		mov	r1, #1149239296
 4128 005a D4F88C01 		ldr	r0, [r4, #396]	@ float
 4129 005e FFF7FEFF 		bl	__aeabi_fmul
 4130              	.LVL485:
 4131 0062 FFF7FEFF 		bl	__aeabi_f2iz
 4132              	.LVL486:
 4133 0066 4FF08941 		mov	r1, #1149239296
 4134 006a C4F87401 		str	r0, [r4, #372]
 4135 006e D4F89001 		ldr	r0, [r4, #400]	@ float
 4136 0072 FFF7FEFF 		bl	__aeabi_fmul
 4137              	.LVL487:
 4138 0076 FFF7FEFF 		bl	__aeabi_f2iz
 4139              	.LVL488:
 4140 007a 4FF08941 		mov	r1, #1149239296
 4141 007e C4F87801 		str	r0, [r4, #376]
 4142 0082 D4F89401 		ldr	r0, [r4, #404]	@ float
 4143 0086 FFF7FEFF 		bl	__aeabi_fmul
 4144              	.LVL489:
 4145 008a FFF7FEFF 		bl	__aeabi_f2iz
 4146              	.LVL490:
1069:state.c       ****     SetBit(state.accel_status, ACCEL_NED_I);
 4147              		.loc 1 1069 0
 4148 008e 45F00205 		orr	r5, r5, #2
1068:state.c       ****     ACCELS_BFP_OF_REAL(state.ned_accel_i, state.ned_accel_f);
 4149              		.loc 1 1068 0
 4150 0092 C4F87C01 		str	r0, [r4, #380]
 4151              		.loc 1 1069 0
 4152 0096 84F87051 		strb	r5, [r4, #368]
 4153              	.L465:
1070:state.c       ****     ecef_of_ned_vect_i(&state.ecef_accel_i, &state.ned_origin_i, &state.ned_accel_i);
 4154              		.loc 1 1070 0
 4155 009a 04F5C070 		add	r0, r4, #384
 4156 009e 04F11C01 		add	r1, r4, #28
 4157 00a2 04F5BA72 		add	r2, r4, #372
 4158 00a6 FFF7FEFF 		bl	ecef_of_ned_vect_i
 4159              	.LVL491:
 4160              	.L460:
1071:state.c       ****   }
1072:state.c       ****   else {
1073:state.c       ****     /* could not get this representation,  set errno */
1074:state.c       ****     //struct EcefCoor_i _ecef_zero = {0};
1075:state.c       ****     //return _ecef_zero;
1076:state.c       ****   }
1077:state.c       ****   /* set bit to indicate this representation is computed */
1078:state.c       ****   SetBit(state.accel_status, ACCEL_ECEF_I);
 4161              		.loc 1 1078 0
 4162 00aa 044B     		ldr	r3, .L466
 4163 00ac 93F87021 		ldrb	r2, [r3, #368]	@ zero_extendqisi2
 4164 00b0 42F00100 		orr	r0, r2, #1
 4165 00b4 83F87001 		strb	r0, [r3, #368]
 4166              	.L457:
 4167 00b8 38BD     		pop	{r3, r4, r5, pc}
 4168              	.L467:
 4169 00ba 00BF     		.align	2
 4170              	.L466:
 4171 00bc 00000000 		.word	.LANCHOR0
 4172              		.cfi_endproc
 4173              	.LFE121:
 4175              		.section	.text.stateCalcAccelNed_f,"ax",%progbits
 4176              		.align	1
 4177              		.global	stateCalcAccelNed_f
 4178              		.thumb
 4179              		.thumb_func
 4181              	stateCalcAccelNed_f:
 4182              	.LFB122:
1079:state.c       **** }
1080:state.c       **** 
1081:state.c       **** void stateCalcAccelNed_f(void) {
 4183              		.loc 1 1081 0
 4184              		.cfi_startproc
 4185              		@ args = 0, pretend = 0, frame = 0
 4186              		@ frame_needed = 0, uses_anonymous_args = 0
 4187 0000 38B5     		push	{r3, r4, r5, lr}
 4188              	.LCFI21:
 4189              		.cfi_def_cfa_offset 16
 4190              		.cfi_offset 3, -16
 4191              		.cfi_offset 4, -12
 4192              		.cfi_offset 5, -8
 4193              		.cfi_offset 14, -4
1082:state.c       ****   if (bit_is_set(state.accel_status, ACCEL_NED_F))
 4194              		.loc 1 1082 0
 4195 0002 304C     		ldr	r4, .L480
 4196 0004 94F87051 		ldrb	r5, [r4, #368]	@ zero_extendqisi2
 4197 0008 2807     		lsls	r0, r5, #28
 4198 000a 59D4     		bmi	.L468
 4199              	.LVL492:
1083:state.c       ****     return;
1084:state.c       **** 
1085:state.c       ****   int errno = 0;
1086:state.c       ****   if (state.ned_initialized_f) {
 4200              		.loc 1 1086 0
 4201 000c 94F8E430 		ldrb	r3, [r4, #228]	@ zero_extendqisi2
 4202 0010 002B     		cmp	r3, #0
 4203 0012 4ED0     		beq	.L470
1087:state.c       ****     if (bit_is_set(state.accel_status, ACCEL_NED_I)) {
 4204              		.loc 1 1087 0
 4205 0014 A907     		lsls	r1, r5, #30
 4206 0016 1ED5     		bpl	.L471
1088:state.c       ****       ACCELS_FLOAT_OF_BFP(state.ned_accel_f, state.ned_accel_i);
 4207              		.loc 1 1088 0
 4208 0018 D4F87401 		ldr	r0, [r4, #372]
 4209 001c FFF7FEFF 		bl	__aeabi_i2f
 4210              	.LVL493:
 4211 0020 4FF06A51 		mov	r1, #981467136
 4212 0024 FFF7FEFF 		bl	__aeabi_fmul
 4213              	.LVL494:
 4214 0028 C4F88C01 		str	r0, [r4, #396]	@ float
 4215 002c D4F87801 		ldr	r0, [r4, #376]
 4216 0030 FFF7FEFF 		bl	__aeabi_i2f
 4217              	.LVL495:
 4218 0034 4FF06A51 		mov	r1, #981467136
 4219 0038 FFF7FEFF 		bl	__aeabi_fmul
 4220              	.LVL496:
 4221 003c C4F89001 		str	r0, [r4, #400]	@ float
 4222 0040 D4F87C01 		ldr	r0, [r4, #380]
 4223 0044 FFF7FEFF 		bl	__aeabi_i2f
 4224              	.LVL497:
 4225 0048 4FF06A51 		mov	r1, #981467136
 4226 004c FFF7FEFF 		bl	__aeabi_fmul
 4227              	.LVL498:
 4228 0050 C4F89401 		str	r0, [r4, #404]	@ float
 4229 0054 2DE0     		b	.L470
 4230              	.L471:
1089:state.c       ****     }
1090:state.c       ****     else if (bit_is_set(state.accel_status, ACCEL_ECEF_F)) {
 4231              		.loc 1 1090 0
 4232 0056 6A07     		lsls	r2, r5, #29
 4233 0058 23D4     		bmi	.L479
 4234              	.L472:
1091:state.c       ****       ned_of_ecef_vect_f(&state.ned_accel_f, &state.ned_origin_f, &state.ecef_accel_f);
1092:state.c       ****     }
1093:state.c       ****     else if (bit_is_set(state.accel_status, ACCEL_ECEF_I)) {
 4235              		.loc 1 1093 0
 4236 005a EB07     		lsls	r3, r5, #31
 4237 005c 29D5     		bpl	.L470
1094:state.c       ****       /* transform ecef_i -> ecef_f -> ned_f , set status bits */
1095:state.c       ****       ACCELS_FLOAT_OF_BFP(state.ecef_accel_f, state.ecef_accel_i);
 4238              		.loc 1 1095 0
 4239 005e D4F88001 		ldr	r0, [r4, #384]
 4240 0062 FFF7FEFF 		bl	__aeabi_i2f
 4241              	.LVL499:
 4242 0066 4FF06A51 		mov	r1, #981467136
 4243 006a FFF7FEFF 		bl	__aeabi_fmul
 4244              	.LVL500:
 4245 006e C4F89801 		str	r0, [r4, #408]	@ float
 4246 0072 D4F88401 		ldr	r0, [r4, #388]
 4247 0076 FFF7FEFF 		bl	__aeabi_i2f
 4248              	.LVL501:
 4249 007a 4FF06A51 		mov	r1, #981467136
 4250 007e FFF7FEFF 		bl	__aeabi_fmul
 4251              	.LVL502:
 4252 0082 C4F89C01 		str	r0, [r4, #412]	@ float
 4253 0086 D4F88801 		ldr	r0, [r4, #392]
 4254 008a FFF7FEFF 		bl	__aeabi_i2f
 4255              	.LVL503:
 4256 008e 4FF06A51 		mov	r1, #981467136
 4257 0092 FFF7FEFF 		bl	__aeabi_fmul
 4258              	.LVL504:
1096:state.c       ****       SetBit(state.accel_status, ACCEL_ECEF_F);
 4259              		.loc 1 1096 0
 4260 0096 45F00405 		orr	r5, r5, #4
1095:state.c       ****       ACCELS_FLOAT_OF_BFP(state.ecef_accel_f, state.ecef_accel_i);
 4261              		.loc 1 1095 0
 4262 009a C4F8A001 		str	r0, [r4, #416]	@ float
 4263              		.loc 1 1096 0
 4264 009e 84F87051 		strb	r5, [r4, #368]
 4265              	.L479:
1097:state.c       ****       ned_of_ecef_vect_f(&state.ned_accel_f, &state.ned_origin_f, &state.ecef_accel_f);
 4266              		.loc 1 1097 0
 4267 00a2 04F5C670 		add	r0, r4, #396
 4268 00a6 04F1A401 		add	r1, r4, #164
 4269 00aa 04F5CC72 		add	r2, r4, #408
 4270 00ae FFF7FEFF 		bl	ned_of_ecef_vect_f
 4271              	.LVL505:
 4272              	.L470:
1098:state.c       ****     }
1099:state.c       ****     else { /* could not get this representation,  set errno */
1100:state.c       ****       errno = 1;
1101:state.c       ****     }
1102:state.c       ****   } else { /* ned coordinate system not initialized,  set errno */
1103:state.c       ****     errno = 2;
1104:state.c       ****   }
1105:state.c       ****   if (errno) {
1106:state.c       ****     //struct NedCoor_f _ned_zero = {0.0f};
1107:state.c       ****     //return _ned_zero;
1108:state.c       ****   }
1109:state.c       ****   /* set bit to indicate this representation is computed */
1110:state.c       ****   SetBit(state.accel_status, ACCEL_NED_F);
 4273              		.loc 1 1110 0
 4274 00b2 0448     		ldr	r0, .L480
 4275 00b4 90F87021 		ldrb	r2, [r0, #368]	@ zero_extendqisi2
 4276 00b8 42F00801 		orr	r1, r2, #8
 4277 00bc 80F87011 		strb	r1, [r0, #368]
 4278              	.LVL506:
 4279              	.L468:
 4280 00c0 38BD     		pop	{r3, r4, r5, pc}
 4281              	.L481:
 4282 00c2 00BF     		.align	2
 4283              	.L480:
 4284 00c4 00000000 		.word	.LANCHOR0
 4285              		.cfi_endproc
 4286              	.LFE122:
 4288              		.section	.text.stateCalcAccelEcef_f,"ax",%progbits
 4289              		.align	1
 4290              		.global	stateCalcAccelEcef_f
 4291              		.thumb
 4292              		.thumb_func
 4294              	stateCalcAccelEcef_f:
 4295              	.LFB123:
1111:state.c       **** }
1112:state.c       **** 
1113:state.c       **** void stateCalcAccelEcef_f(void) {
 4296              		.loc 1 1113 0
 4297              		.cfi_startproc
 4298              		@ args = 0, pretend = 0, frame = 0
 4299              		@ frame_needed = 0, uses_anonymous_args = 0
 4300 0000 38B5     		push	{r3, r4, r5, lr}
 4301              	.LCFI22:
 4302              		.cfi_def_cfa_offset 16
 4303              		.cfi_offset 3, -16
 4304              		.cfi_offset 4, -12
 4305              		.cfi_offset 5, -8
 4306              		.cfi_offset 14, -4
1114:state.c       ****   if (bit_is_set(state.accel_status, ACCEL_ECEF_F))
 4307              		.loc 1 1114 0
 4308 0002 2E4C     		ldr	r4, .L491
 4309 0004 94F87051 		ldrb	r5, [r4, #368]	@ zero_extendqisi2
 4310 0008 6807     		lsls	r0, r5, #29
 4311 000a 55D4     		bmi	.L482
1115:state.c       ****     return;
1116:state.c       **** 
1117:state.c       ****   if (bit_is_set(state.accel_status, ACCEL_ECEF_I)) {
 4312              		.loc 1 1117 0
 4313 000c E907     		lsls	r1, r5, #31
 4314 000e 1ED5     		bpl	.L484
1118:state.c       ****     ACCELS_FLOAT_OF_BFP(state.ecef_accel_f, state.ned_accel_i);
 4315              		.loc 1 1118 0
 4316 0010 D4F87401 		ldr	r0, [r4, #372]
 4317 0014 FFF7FEFF 		bl	__aeabi_i2f
 4318              	.LVL507:
 4319 0018 4FF06A51 		mov	r1, #981467136
 4320 001c FFF7FEFF 		bl	__aeabi_fmul
 4321              	.LVL508:
 4322 0020 C4F89801 		str	r0, [r4, #408]	@ float
 4323 0024 D4F87801 		ldr	r0, [r4, #376]
 4324 0028 FFF7FEFF 		bl	__aeabi_i2f
 4325              	.LVL509:
 4326 002c 4FF06A51 		mov	r1, #981467136
 4327 0030 FFF7FEFF 		bl	__aeabi_fmul
 4328              	.LVL510:
 4329 0034 C4F89C01 		str	r0, [r4, #412]	@ float
 4330 0038 D4F87C01 		ldr	r0, [r4, #380]
 4331 003c FFF7FEFF 		bl	__aeabi_i2f
 4332              	.LVL511:
 4333 0040 4FF06A51 		mov	r1, #981467136
 4334 0044 FFF7FEFF 		bl	__aeabi_fmul
 4335              	.LVL512:
 4336 0048 C4F8A001 		str	r0, [r4, #416]	@ float
 4337 004c 2DE0     		b	.L485
 4338              	.L484:
1119:state.c       ****   }
1120:state.c       ****   else if (bit_is_set(state.accel_status, ACCEL_NED_F)) {
 4339              		.loc 1 1120 0
 4340 004e 2A07     		lsls	r2, r5, #28
 4341 0050 23D4     		bmi	.L490
 4342              	.L486:
1121:state.c       ****     ecef_of_ned_vect_f(&state.ecef_accel_f, &state.ned_origin_f, &state.ned_accel_f);
1122:state.c       ****   }
1123:state.c       ****   else if (bit_is_set(state.accel_status, ACCEL_NED_I)) {
 4343              		.loc 1 1123 0
 4344 0052 AB07     		lsls	r3, r5, #30
 4345 0054 29D5     		bpl	.L485
1124:state.c       ****     /* transform ned_f -> ned_i -> ecef_i , set status bits */
1125:state.c       ****     ACCELS_FLOAT_OF_BFP(state.ned_accel_f, state.ned_accel_i);
 4346              		.loc 1 1125 0
 4347 0056 D4F87401 		ldr	r0, [r4, #372]
 4348 005a FFF7FEFF 		bl	__aeabi_i2f
 4349              	.LVL513:
 4350 005e 4FF06A51 		mov	r1, #981467136
 4351 0062 FFF7FEFF 		bl	__aeabi_fmul
 4352              	.LVL514:
 4353 0066 C4F88C01 		str	r0, [r4, #396]	@ float
 4354 006a D4F87801 		ldr	r0, [r4, #376]
 4355 006e FFF7FEFF 		bl	__aeabi_i2f
 4356              	.LVL515:
 4357 0072 4FF06A51 		mov	r1, #981467136
 4358 0076 FFF7FEFF 		bl	__aeabi_fmul
 4359              	.LVL516:
 4360 007a C4F89001 		str	r0, [r4, #400]	@ float
 4361 007e D4F87C01 		ldr	r0, [r4, #380]
 4362 0082 FFF7FEFF 		bl	__aeabi_i2f
 4363              	.LVL517:
 4364 0086 4FF06A51 		mov	r1, #981467136
 4365 008a FFF7FEFF 		bl	__aeabi_fmul
 4366              	.LVL518:
1126:state.c       ****     SetBit(state.accel_status, ACCEL_NED_F);
 4367              		.loc 1 1126 0
 4368 008e 45F00805 		orr	r5, r5, #8
1125:state.c       ****     ACCELS_FLOAT_OF_BFP(state.ned_accel_f, state.ned_accel_i);
 4369              		.loc 1 1125 0
 4370 0092 C4F89401 		str	r0, [r4, #404]	@ float
 4371              		.loc 1 1126 0
 4372 0096 84F87051 		strb	r5, [r4, #368]
 4373              	.L490:
1127:state.c       ****     ecef_of_ned_vect_f(&state.ecef_accel_f, &state.ned_origin_f, &state.ned_accel_f);
 4374              		.loc 1 1127 0
 4375 009a 04F5CC70 		add	r0, r4, #408
 4376 009e 04F1A401 		add	r1, r4, #164
 4377 00a2 04F5C672 		add	r2, r4, #396
 4378 00a6 FFF7FEFF 		bl	ecef_of_ned_vect_f
 4379              	.LVL519:
 4380              	.L485:
1128:state.c       ****   }
1129:state.c       ****   else {
1130:state.c       ****     /* could not get this representation,  set errno */
1131:state.c       ****     //struct EcefCoor_f _ecef_zero = {0.0f};
1132:state.c       ****     //return _ecef_zero;
1133:state.c       ****   }
1134:state.c       ****   /* set bit to indicate this representation is computed */
1135:state.c       ****   SetBit(state.accel_status, ACCEL_ECEF_F);
 4381              		.loc 1 1135 0
 4382 00aa 044B     		ldr	r3, .L491
 4383 00ac 93F87021 		ldrb	r2, [r3, #368]	@ zero_extendqisi2
 4384 00b0 42F00400 		orr	r0, r2, #4
 4385 00b4 83F87001 		strb	r0, [r3, #368]
 4386              	.L482:
 4387 00b8 38BD     		pop	{r3, r4, r5, pc}
 4388              	.L492:
 4389 00ba 00BF     		.align	2
 4390              	.L491:
 4391 00bc 00000000 		.word	.LANCHOR0
 4392              		.cfi_endproc
 4393              	.LFE123:
 4395              		.section	.text.stateCalcBodyRates_i,"ax",%progbits
 4396              		.align	1
 4397              		.global	stateCalcBodyRates_i
 4398              		.thumb
 4399              		.thumb_func
 4401              	stateCalcBodyRates_i:
 4402              	.LFB124:
1136:state.c       **** }
1137:state.c       **** /** @}*/
1138:state.c       **** 
1139:state.c       **** /******************************************************************************
1140:state.c       ****  *                                                                            *
1141:state.c       ****  * Transformation functions for the ANGULAR RATE representations              *
1142:state.c       ****  *                                                                            *
1143:state.c       ****  *****************************************************************************/
1144:state.c       **** /** @addtogroup state_rate
1145:state.c       ****  *  @{ */
1146:state.c       **** 
1147:state.c       **** void stateCalcBodyRates_i(void) {
 4403              		.loc 1 1147 0
 4404              		.cfi_startproc
 4405              		@ args = 0, pretend = 0, frame = 0
 4406              		@ frame_needed = 0, uses_anonymous_args = 0
 4407 0000 38B5     		push	{r3, r4, r5, lr}
 4408              	.LCFI23:
 4409              		.cfi_def_cfa_offset 16
 4410              		.cfi_offset 3, -16
 4411              		.cfi_offset 4, -12
 4412              		.cfi_offset 5, -8
 4413              		.cfi_offset 14, -4
1148:state.c       ****   if (bit_is_set(state.rate_status, RATE_I))
 4414              		.loc 1 1148 0
 4415 0002 154C     		ldr	r4, .L499
 4416 0004 94F82852 		ldrb	r5, [r4, #552]	@ zero_extendqisi2
 4417 0008 EA07     		lsls	r2, r5, #31
 4418 000a 24D4     		bmi	.L493
1149:state.c       ****     return;
1150:state.c       **** 
1151:state.c       ****   if (bit_is_set(state.rate_status, RATE_F)) {
 4419              		.loc 1 1151 0
 4420 000c AB07     		lsls	r3, r5, #30
 4421 000e 1DD5     		bpl	.L495
1152:state.c       ****     RATES_BFP_OF_REAL(state.body_rates_i, state.body_rates_f);
 4422              		.loc 1 1152 0
 4423 0010 4FF08B41 		mov	r1, #1166016512
 4424 0014 D4F83802 		ldr	r0, [r4, #568]	@ float
 4425 0018 FFF7FEFF 		bl	__aeabi_fmul
 4426              	.LVL520:
 4427 001c FFF7FEFF 		bl	__aeabi_f2iz
 4428              	.LVL521:
 4429 0020 4FF08B41 		mov	r1, #1166016512
 4430 0024 C4F82C02 		str	r0, [r4, #556]
 4431 0028 D4F83C02 		ldr	r0, [r4, #572]	@ float
 4432 002c FFF7FEFF 		bl	__aeabi_fmul
 4433              	.LVL522:
 4434 0030 FFF7FEFF 		bl	__aeabi_f2iz
 4435              	.LVL523:
 4436 0034 4FF08B41 		mov	r1, #1166016512
 4437 0038 C4F83002 		str	r0, [r4, #560]
 4438 003c D4F84002 		ldr	r0, [r4, #576]	@ float
 4439 0040 FFF7FEFF 		bl	__aeabi_fmul
 4440              	.LVL524:
 4441 0044 FFF7FEFF 		bl	__aeabi_f2iz
 4442              	.LVL525:
 4443 0048 C4F83402 		str	r0, [r4, #564]
 4444              	.L495:
1153:state.c       ****   }
1154:state.c       ****   /* set bit to indicate this representation is computed */
1155:state.c       ****   SetBit(state.rate_status, RATE_I);
 4445              		.loc 1 1155 0
 4446 004c 024B     		ldr	r3, .L499
 4447 004e 45F00105 		orr	r5, r5, #1
 4448 0052 83F82852 		strb	r5, [r3, #552]
 4449              	.L493:
 4450 0056 38BD     		pop	{r3, r4, r5, pc}
 4451              	.L500:
 4452              		.align	2
 4453              	.L499:
 4454 0058 00000000 		.word	.LANCHOR0
 4455              		.cfi_endproc
 4456              	.LFE124:
 4458              		.section	.text.stateCalcBodyRates_f,"ax",%progbits
 4459              		.align	1
 4460              		.global	stateCalcBodyRates_f
 4461              		.thumb
 4462              		.thumb_func
 4464              	stateCalcBodyRates_f:
 4465              	.LFB125:
1156:state.c       **** }
1157:state.c       **** 
1158:state.c       **** void stateCalcBodyRates_f(void) {
 4466              		.loc 1 1158 0
 4467              		.cfi_startproc
 4468              		@ args = 0, pretend = 0, frame = 0
 4469              		@ frame_needed = 0, uses_anonymous_args = 0
 4470 0000 38B5     		push	{r3, r4, r5, lr}
 4471              	.LCFI24:
 4472              		.cfi_def_cfa_offset 16
 4473              		.cfi_offset 3, -16
 4474              		.cfi_offset 4, -12
 4475              		.cfi_offset 5, -8
 4476              		.cfi_offset 14, -4
1159:state.c       ****   if (bit_is_set(state.rate_status, RATE_F))
 4477              		.loc 1 1159 0
 4478 0002 154C     		ldr	r4, .L507
 4479 0004 94F82852 		ldrb	r5, [r4, #552]	@ zero_extendqisi2
 4480 0008 A807     		lsls	r0, r5, #30
 4481 000a 24D4     		bmi	.L501
1160:state.c       ****     return;
1161:state.c       **** 
1162:state.c       ****   if (bit_is_set(state.rate_status, RATE_I)) {
 4482              		.loc 1 1162 0
 4483 000c E907     		lsls	r1, r5, #31
 4484 000e 1DD5     		bpl	.L503
1163:state.c       ****     RATES_FLOAT_OF_BFP(state.body_rates_f, state.body_rates_i);
 4485              		.loc 1 1163 0
 4486 0010 D4F82C02 		ldr	r0, [r4, #556]
 4487 0014 FFF7FEFF 		bl	__aeabi_i2f
 4488              	.LVL526:
 4489 0018 4FF06651 		mov	r1, #964689920
 4490 001c FFF7FEFF 		bl	__aeabi_fmul
 4491              	.LVL527:
 4492 0020 C4F83802 		str	r0, [r4, #568]	@ float
 4493 0024 D4F83002 		ldr	r0, [r4, #560]
 4494 0028 FFF7FEFF 		bl	__aeabi_i2f
 4495              	.LVL528:
 4496 002c 4FF06651 		mov	r1, #964689920
 4497 0030 FFF7FEFF 		bl	__aeabi_fmul
 4498              	.LVL529:
 4499 0034 C4F83C02 		str	r0, [r4, #572]	@ float
 4500 0038 D4F83402 		ldr	r0, [r4, #564]
 4501 003c FFF7FEFF 		bl	__aeabi_i2f
 4502              	.LVL530:
 4503 0040 4FF06651 		mov	r1, #964689920
 4504 0044 FFF7FEFF 		bl	__aeabi_fmul
 4505              	.LVL531:
 4506 0048 C4F84002 		str	r0, [r4, #576]	@ float
 4507              	.L503:
1164:state.c       ****   }
1165:state.c       ****   /* set bit to indicate this representation is computed */
1166:state.c       ****   SetBit(state.rate_status, RATE_F);
 4508              		.loc 1 1166 0
 4509 004c 024B     		ldr	r3, .L507
 4510 004e 45F00205 		orr	r5, r5, #2
 4511 0052 83F82852 		strb	r5, [r3, #552]
 4512              	.L501:
 4513 0056 38BD     		pop	{r3, r4, r5, pc}
 4514              	.L508:
 4515              		.align	2
 4516              	.L507:
 4517 0058 00000000 		.word	.LANCHOR0
 4518              		.cfi_endproc
 4519              	.LFE125:
 4521              		.section	.text.stateCalcHorizontalWindspeed_i,"ax",%progbits
 4522              		.align	1
 4523              		.global	stateCalcHorizontalWindspeed_i
 4524              		.thumb
 4525              		.thumb_func
 4527              	stateCalcHorizontalWindspeed_i:
 4528              	.LFB126:
1167:state.c       **** }
1168:state.c       **** 
1169:state.c       **** /** @}*/
1170:state.c       **** 
1171:state.c       **** 
1172:state.c       **** /******************************************************************************
1173:state.c       ****  *                                                                            *
1174:state.c       ****  * Transformation functions for the WIND- AND AIRSPEED representations        *
1175:state.c       ****  *                                                                            *
1176:state.c       ****  *****************************************************************************/
1177:state.c       **** /** @addtogroup state_wind_airspeed
1178:state.c       ****  *  @{ */
1179:state.c       **** 
1180:state.c       **** void stateCalcHorizontalWindspeed_i(void) {
 4529              		.loc 1 1180 0
 4530              		.cfi_startproc
 4531              		@ args = 0, pretend = 0, frame = 0
 4532              		@ frame_needed = 0, uses_anonymous_args = 0
 4533 0000 10B5     		push	{r4, lr}
 4534              	.LCFI25:
 4535              		.cfi_def_cfa_offset 8
 4536              		.cfi_offset 4, -8
 4537              		.cfi_offset 14, -4
1181:state.c       ****   if (bit_is_set(state.wind_air_status, WINDSPEED_I))
 4538              		.loc 1 1181 0
 4539 0002 114C     		ldr	r4, .L515
 4540 0004 94F84432 		ldrb	r3, [r4, #580]	@ zero_extendqisi2
 4541 0008 DA07     		lsls	r2, r3, #31
 4542 000a 1CD4     		bmi	.L509
1182:state.c       ****     return;
1183:state.c       **** 
1184:state.c       ****   if (bit_is_set(state.wind_air_status, WINDSPEED_F)) {
 4543              		.loc 1 1184 0
 4544 000c 5B07     		lsls	r3, r3, #29
 4545 000e 13D5     		bpl	.L511
1185:state.c       ****     state.h_windspeed_i.x = SPEED_BFP_OF_REAL(state.h_windspeed_f.x);
 4546              		.loc 1 1185 0
 4547 0010 4FF09241 		mov	r1, #1224736768
 4548 0014 D4F85402 		ldr	r0, [r4, #596]	@ float
 4549 0018 FFF7FEFF 		bl	__aeabi_fmul
 4550              	.LVL532:
 4551 001c FFF7FEFF 		bl	__aeabi_f2iz
 4552              	.LVL533:
1186:state.c       ****     state.h_windspeed_i.y = SPEED_BFP_OF_REAL(state.h_windspeed_f.y);
 4553              		.loc 1 1186 0
 4554 0020 4FF09241 		mov	r1, #1224736768
1185:state.c       ****     state.h_windspeed_i.x = SPEED_BFP_OF_REAL(state.h_windspeed_f.x);
 4555              		.loc 1 1185 0
 4556 0024 C4F84802 		str	r0, [r4, #584]
 4557              		.loc 1 1186 0
 4558 0028 D4F85802 		ldr	r0, [r4, #600]	@ float
 4559 002c FFF7FEFF 		bl	__aeabi_fmul
 4560              	.LVL534:
 4561 0030 FFF7FEFF 		bl	__aeabi_f2iz
 4562              	.LVL535:
 4563 0034 C4F84C02 		str	r0, [r4, #588]
 4564              	.L511:
1187:state.c       ****   }
1188:state.c       ****   /* set bit to indicate this representation is computed */
1189:state.c       ****   SetBit(state.rate_status, WINDSPEED_I);
 4565              		.loc 1 1189 0
 4566 0038 0348     		ldr	r0, .L515
 4567 003a 90F82822 		ldrb	r2, [r0, #552]	@ zero_extendqisi2
 4568 003e 42F00101 		orr	r1, r2, #1
 4569 0042 80F82812 		strb	r1, [r0, #552]
 4570              	.L509:
 4571 0046 10BD     		pop	{r4, pc}
 4572              	.L516:
 4573              		.align	2
 4574              	.L515:
 4575 0048 00000000 		.word	.LANCHOR0
 4576              		.cfi_endproc
 4577              	.LFE126:
 4579              		.section	.text.stateCalcAirspeed_i,"ax",%progbits
 4580              		.align	1
 4581              		.global	stateCalcAirspeed_i
 4582              		.thumb
 4583              		.thumb_func
 4585              	stateCalcAirspeed_i:
 4586              	.LFB127:
1190:state.c       **** }
1191:state.c       **** 
1192:state.c       **** void stateCalcAirspeed_i(void) {
 4587              		.loc 1 1192 0
 4588              		.cfi_startproc
 4589              		@ args = 0, pretend = 0, frame = 0
 4590              		@ frame_needed = 0, uses_anonymous_args = 0
 4591 0000 38B5     		push	{r3, r4, r5, lr}
 4592              	.LCFI26:
 4593              		.cfi_def_cfa_offset 16
 4594              		.cfi_offset 3, -16
 4595              		.cfi_offset 4, -12
 4596              		.cfi_offset 5, -8
 4597              		.cfi_offset 14, -4
1193:state.c       ****   if (bit_is_set(state.wind_air_status, AIRSPEED_I))
 4598              		.loc 1 1193 0
 4599 0002 0B4C     		ldr	r4, .L523
 4600 0004 94F84452 		ldrb	r5, [r4, #580]	@ zero_extendqisi2
 4601 0008 A807     		lsls	r0, r5, #30
 4602 000a 0FD4     		bmi	.L517
1194:state.c       ****     return;
1195:state.c       **** 
1196:state.c       ****   if (bit_is_set(state.wind_air_status, AIRSPEED_F)) {
 4603              		.loc 1 1196 0
 4604 000c 2907     		lsls	r1, r5, #28
 4605 000e 09D5     		bpl	.L519
1197:state.c       ****     state.airspeed_i = SPEED_BFP_OF_REAL(state.airspeed_f);
 4606              		.loc 1 1197 0
 4607 0010 4FF09241 		mov	r1, #1224736768
 4608 0014 D4F85C02 		ldr	r0, [r4, #604]	@ float
 4609 0018 FFF7FEFF 		bl	__aeabi_fmul
 4610              	.LVL536:
 4611 001c FFF7FEFF 		bl	__aeabi_f2iz
 4612              	.LVL537:
 4613 0020 C4F85002 		str	r0, [r4, #592]
 4614              	.L519:
1198:state.c       ****   }
1199:state.c       ****   /* set bit to indicate this representation is computed */
1200:state.c       ****   SetBit(state.wind_air_status, AIRSPEED_I);
 4615              		.loc 1 1200 0
 4616 0024 45F00205 		orr	r5, r5, #2
 4617 0028 84F84452 		strb	r5, [r4, #580]
 4618              	.L517:
 4619 002c 38BD     		pop	{r3, r4, r5, pc}
 4620              	.L524:
 4621 002e 00BF     		.align	2
 4622              	.L523:
 4623 0030 00000000 		.word	.LANCHOR0
 4624              		.cfi_endproc
 4625              	.LFE127:
 4627              		.section	.text.stateCalcHorizontalWindspeed_f,"ax",%progbits
 4628              		.align	1
 4629              		.global	stateCalcHorizontalWindspeed_f
 4630              		.thumb
 4631              		.thumb_func
 4633              	stateCalcHorizontalWindspeed_f:
 4634              	.LFB128:
1201:state.c       **** }
1202:state.c       **** 
1203:state.c       **** void stateCalcHorizontalWindspeed_f(void) {
 4635              		.loc 1 1203 0
 4636              		.cfi_startproc
 4637              		@ args = 0, pretend = 0, frame = 0
 4638              		@ frame_needed = 0, uses_anonymous_args = 0
 4639 0000 10B5     		push	{r4, lr}
 4640              	.LCFI27:
 4641              		.cfi_def_cfa_offset 8
 4642              		.cfi_offset 4, -8
 4643              		.cfi_offset 14, -4
1204:state.c       ****   if (bit_is_set(state.wind_air_status, WINDSPEED_F))
 4644              		.loc 1 1204 0
 4645 0002 0C4C     		ldr	r4, .L531
 4646 0004 94F84432 		ldrb	r3, [r4, #580]	@ zero_extendqisi2
 4647 0008 5A07     		lsls	r2, r3, #29
 4648 000a 11D4     		bmi	.L525
1205:state.c       ****     return;
1206:state.c       **** 
1207:state.c       ****   if (bit_is_set(state.wind_air_status, WINDSPEED_I)) {
 4649              		.loc 1 1207 0
 4650 000c DB07     		lsls	r3, r3, #31
 4651 000e 09D5     		bpl	.L527
1208:state.c       ****     state.h_windspeed_f.x = SPEED_FLOAT_OF_BFP(state.h_windspeed_i.x);
1209:state.c       ****     state.h_windspeed_f.x = SPEED_FLOAT_OF_BFP(state.h_windspeed_i.y);
 4652              		.loc 1 1209 0
 4653 0010 D4F84C02 		ldr	r0, [r4, #588]
 4654 0014 FFF7FEFF 		bl	__aeabi_i2f
 4655              	.LVL538:
 4656 0018 4FF05851 		mov	r1, #905969664
 4657 001c FFF7FEFF 		bl	__aeabi_fmul
 4658              	.LVL539:
 4659 0020 C4F85402 		str	r0, [r4, #596]	@ float
 4660              	.L527:
1210:state.c       ****   }
1211:state.c       ****   /* set bit to indicate this representation is computed */
1212:state.c       ****   SetBit(state.rate_status, WINDSPEED_F);
 4661              		.loc 1 1212 0
 4662 0024 94F82802 		ldrb	r0, [r4, #552]	@ zero_extendqisi2
 4663 0028 40F00401 		orr	r1, r0, #4
 4664 002c 84F82812 		strb	r1, [r4, #552]
 4665              	.L525:
 4666 0030 10BD     		pop	{r4, pc}
 4667              	.L532:
 4668 0032 00BF     		.align	2
 4669              	.L531:
 4670 0034 00000000 		.word	.LANCHOR0
 4671              		.cfi_endproc
 4672              	.LFE128:
 4674              		.section	.text.stateCalcAirspeed_f,"ax",%progbits
 4675              		.align	1
 4676              		.global	stateCalcAirspeed_f
 4677              		.thumb
 4678              		.thumb_func
 4680              	stateCalcAirspeed_f:
 4681              	.LFB129:
1213:state.c       **** }
1214:state.c       **** 
1215:state.c       **** void stateCalcAirspeed_f(void) {
 4682              		.loc 1 1215 0
 4683              		.cfi_startproc
 4684              		@ args = 0, pretend = 0, frame = 0
 4685              		@ frame_needed = 0, uses_anonymous_args = 0
 4686 0000 38B5     		push	{r3, r4, r5, lr}
 4687              	.LCFI28:
 4688              		.cfi_def_cfa_offset 16
 4689              		.cfi_offset 3, -16
 4690              		.cfi_offset 4, -12
 4691              		.cfi_offset 5, -8
 4692              		.cfi_offset 14, -4
1216:state.c       ****   if (bit_is_set(state.wind_air_status, AIRSPEED_F))
 4693              		.loc 1 1216 0
 4694 0002 0B4C     		ldr	r4, .L539
 4695 0004 94F84452 		ldrb	r5, [r4, #580]	@ zero_extendqisi2
 4696 0008 2807     		lsls	r0, r5, #28
 4697 000a 0FD4     		bmi	.L533
1217:state.c       ****     return;
1218:state.c       **** 
1219:state.c       ****   if (bit_is_set(state.wind_air_status, AIRSPEED_I)) {
 4698              		.loc 1 1219 0
 4699 000c A907     		lsls	r1, r5, #30
 4700 000e 09D5     		bpl	.L535
1220:state.c       ****     state.airspeed_f = SPEED_FLOAT_OF_BFP(state.airspeed_i);
 4701              		.loc 1 1220 0
 4702 0010 D4F85002 		ldr	r0, [r4, #592]
 4703 0014 FFF7FEFF 		bl	__aeabi_i2f
 4704              	.LVL540:
 4705 0018 4FF05851 		mov	r1, #905969664
 4706 001c FFF7FEFF 		bl	__aeabi_fmul
 4707              	.LVL541:
 4708 0020 C4F85C02 		str	r0, [r4, #604]	@ float
 4709              	.L535:
1221:state.c       ****   }
1222:state.c       ****   /* set bit to indicate this representation is computed */
1223:state.c       ****   SetBit(state.wind_air_status, AIRSPEED_F);
 4710              		.loc 1 1223 0
 4711 0024 45F00805 		orr	r5, r5, #8
 4712 0028 84F84452 		strb	r5, [r4, #580]
 4713              	.L533:
 4714 002c 38BD     		pop	{r3, r4, r5, pc}
 4715              	.L540:
 4716 002e 00BF     		.align	2
 4717              	.L539:
 4718 0030 00000000 		.word	.LANCHOR0
 4719              		.cfi_endproc
 4720              	.LFE129:
 4722              		.global	state
 4723              		.section	.bss.state,"aw",%nobits
 4724              		.align	2
 4725              		.set	.LANCHOR0,. + 0
 4728              	state:
 4729 0000 00000000 		.space	616
 4729      00000000 
 4729      00000000 
 4729      00000000 
 4729      00000000 
 4730              		.text
 4731              	.Letext0:
 4732              		.file 2 "/opt/local/bin/../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include/stdint.h"
 4733              		.file 3 "/Users/tony-yi/git/paparazzi_local/sw/include/std.h"
 4734              		.file 4 "math/pprz_algebra_int.h"
 4735              		.file 5 "math/pprz_algebra_float.h"
 4736              		.file 6 "math/pprz_geodetic_int.h"
 4737              		.file 7 "math/pprz_geodetic_float.h"
 4738              		.file 8 "math/pprz_orientation_conversion.h"
 4739              		.file 9 "state.h"
 4740              		.file 10 "/opt/local/bin/../lib/gcc/arm-none-eabi/4.7.3/../../../../arm-none-eabi/include/math.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 state.c
/var/tmp//ccp6IKBe.s:19     .text.stateInit:0000000000000000 $t
/var/tmp//ccp6IKBe.s:24     .text.stateInit:0000000000000000 stateInit
/var/tmp//ccp6IKBe.s:56     .text.stateInit:0000000000000028 $d
/var/tmp//ccp6IKBe.s:64     .text.stateCalcPositionEcef_i:0000000000000000 $t
/var/tmp//ccp6IKBe.s:69     .text.stateCalcPositionEcef_i:0000000000000000 stateCalcPositionEcef_i
/var/tmp//ccp6IKBe.s:177    .text.stateCalcPositionEcef_i:00000000000000b0 $d
/var/tmp//ccp6IKBe.s:189    .text.stateCalcPositionNed_i:0000000000000000 $t
/var/tmp//ccp6IKBe.s:194    .text.stateCalcPositionNed_i:0000000000000000 stateCalcPositionNed_i
/var/tmp//ccp6IKBe.s:527    .text.stateCalcPositionNed_i:0000000000000268 $d
/var/tmp//ccp6IKBe.s:535    .text.stateCalcPositionEnu_i:0000000000000000 $t
/var/tmp//ccp6IKBe.s:540    .text.stateCalcPositionEnu_i:0000000000000000 stateCalcPositionEnu_i
/var/tmp//ccp6IKBe.s:870    .text.stateCalcPositionEnu_i:0000000000000260 $d
/var/tmp//ccp6IKBe.s:878    .text.stateCalcPositionLla_i:0000000000000000 $t
/var/tmp//ccp6IKBe.s:883    .text.stateCalcPositionLla_i:0000000000000000 stateCalcPositionLla_i
/var/tmp//ccp6IKBe.s:1015   .text.stateCalcPositionLla_i:00000000000000e0 $d
/var/tmp//ccp6IKBe.s:1023   .text.stateCalcPositionUtm_f:0000000000000000 $t
/var/tmp//ccp6IKBe.s:1028   .text.stateCalcPositionUtm_f:0000000000000000 stateCalcPositionUtm_f
/var/tmp//ccp6IKBe.s:1109   .text.stateCalcPositionUtm_f:0000000000000080 $d
/var/tmp//ccp6IKBe.s:1117   .text.stateCalcPositionEcef_f:0000000000000000 $t
/var/tmp//ccp6IKBe.s:1122   .text.stateCalcPositionEcef_f:0000000000000000 stateCalcPositionEcef_f
/var/tmp//ccp6IKBe.s:1265   .text.stateCalcPositionEcef_f:00000000000000f8 $d
/var/tmp//ccp6IKBe.s:1275   .text.stateCalcPositionNed_f:0000000000000000 $t
/var/tmp//ccp6IKBe.s:1280   .text.stateCalcPositionNed_f:0000000000000000 stateCalcPositionNed_f
/var/tmp//ccp6IKBe.s:1534   .text.stateCalcPositionNed_f:00000000000001e0 $d
/var/tmp//ccp6IKBe.s:1542   .text.stateCalcPositionEnu_f:0000000000000000 $t
/var/tmp//ccp6IKBe.s:1547   .text.stateCalcPositionEnu_f:0000000000000000 stateCalcPositionEnu_f
/var/tmp//ccp6IKBe.s:1812   .text.stateCalcPositionEnu_f:00000000000001e8 $d
/var/tmp//ccp6IKBe.s:1821   .text.stateCalcPositionLla_f:0000000000000000 $t
/var/tmp//ccp6IKBe.s:1826   .text.stateCalcPositionLla_f:0000000000000000 stateCalcPositionLla_f
/var/tmp//ccp6IKBe.s:1989   .text.stateCalcPositionLla_f:0000000000000124 $d
/var/tmp//ccp6IKBe.s:1997   .text.stateCalcSpeedNed_i:0000000000000000 $t
/var/tmp//ccp6IKBe.s:2002   .text.stateCalcSpeedNed_i:0000000000000000 stateCalcSpeedNed_i
/var/tmp//ccp6IKBe.s:2177   .text.stateCalcSpeedNed_i:0000000000000150 $d
/var/tmp//ccp6IKBe.s:2182   .text.stateCalcSpeedEnu_i:0000000000000000 $t
/var/tmp//ccp6IKBe.s:2187   .text.stateCalcSpeedEnu_i:0000000000000000 stateCalcSpeedEnu_i
/var/tmp//ccp6IKBe.s:2372   .text.stateCalcSpeedEnu_i:0000000000000174 $d
/var/tmp//ccp6IKBe.s:2377   .text.stateCalcSpeedEcef_i:0000000000000000 $t
/var/tmp//ccp6IKBe.s:2382   .text.stateCalcSpeedEcef_i:0000000000000000 stateCalcSpeedEcef_i
/var/tmp//ccp6IKBe.s:2479   .text.stateCalcSpeedEcef_i:00000000000000bc $d
/var/tmp//ccp6IKBe.s:2485   .text.stateCalcHorizontalSpeedNorm_i:0000000000000000 $t
/var/tmp//ccp6IKBe.s:2490   .text.stateCalcHorizontalSpeedNorm_i:0000000000000000 stateCalcHorizontalSpeedNorm_i
/var/tmp//ccp6IKBe.s:2751   .text.stateCalcHorizontalSpeedNorm_i:0000000000000164 $d
/var/tmp//ccp6IKBe.s:2756   .text.stateCalcHorizontalSpeedDir_i:0000000000000000 $t
/var/tmp//ccp6IKBe.s:2761   .text.stateCalcHorizontalSpeedDir_i:0000000000000000 stateCalcHorizontalSpeedDir_i
/var/tmp//ccp6IKBe.s:3180   .text.stateCalcHorizontalSpeedDir_i:00000000000002c4 $d
/var/tmp//ccp6IKBe.s:3185   .text.stateCalcSpeedNed_f:0000000000000000 $t
/var/tmp//ccp6IKBe.s:3190   .text.stateCalcSpeedNed_f:0000000000000000 stateCalcSpeedNed_f
/var/tmp//ccp6IKBe.s:3365   .text.stateCalcSpeedNed_f:0000000000000154 $d
/var/tmp//ccp6IKBe.s:3370   .text.stateCalcSpeedEnu_f:0000000000000000 $t
/var/tmp//ccp6IKBe.s:3375   .text.stateCalcSpeedEnu_f:0000000000000000 stateCalcSpeedEnu_f
/var/tmp//ccp6IKBe.s:3549   .text.stateCalcSpeedEnu_f:0000000000000154 $d
/var/tmp//ccp6IKBe.s:3554   .text.stateCalcSpeedEcef_f:0000000000000000 $t
/var/tmp//ccp6IKBe.s:3559   .text.stateCalcSpeedEcef_f:0000000000000000 stateCalcSpeedEcef_f
/var/tmp//ccp6IKBe.s:3656   .text.stateCalcSpeedEcef_f:00000000000000bc $d
/var/tmp//ccp6IKBe.s:3661   .text.stateCalcHorizontalSpeedNorm_f:0000000000000000 $t
/var/tmp//ccp6IKBe.s:3666   .text.stateCalcHorizontalSpeedNorm_f:0000000000000000 stateCalcHorizontalSpeedNorm_f
/var/tmp//ccp6IKBe.s:3809   .text.stateCalcHorizontalSpeedNorm_f:0000000000000108 $d
/var/tmp//ccp6IKBe.s:3814   .text.stateCalcHorizontalSpeedDir_f:0000000000000000 $t
/var/tmp//ccp6IKBe.s:3819   .text.stateCalcHorizontalSpeedDir_f:0000000000000000 stateCalcHorizontalSpeedDir_f
/var/tmp//ccp6IKBe.s:3951   .text.stateCalcHorizontalSpeedDir_f:00000000000000f0 $d
/var/tmp//ccp6IKBe.s:3956   .text.stateCalcAccelNed_i:0000000000000000 $t
/var/tmp//ccp6IKBe.s:3961   .text.stateCalcAccelNed_i:0000000000000000 stateCalcAccelNed_i
/var/tmp//ccp6IKBe.s:4064   .text.stateCalcAccelNed_i:00000000000000c4 $d
/var/tmp//ccp6IKBe.s:4069   .text.stateCalcAccelEcef_i:0000000000000000 $t
/var/tmp//ccp6IKBe.s:4074   .text.stateCalcAccelEcef_i:0000000000000000 stateCalcAccelEcef_i
/var/tmp//ccp6IKBe.s:4171   .text.stateCalcAccelEcef_i:00000000000000bc $d
/var/tmp//ccp6IKBe.s:4176   .text.stateCalcAccelNed_f:0000000000000000 $t
/var/tmp//ccp6IKBe.s:4181   .text.stateCalcAccelNed_f:0000000000000000 stateCalcAccelNed_f
/var/tmp//ccp6IKBe.s:4284   .text.stateCalcAccelNed_f:00000000000000c4 $d
/var/tmp//ccp6IKBe.s:4289   .text.stateCalcAccelEcef_f:0000000000000000 $t
/var/tmp//ccp6IKBe.s:4294   .text.stateCalcAccelEcef_f:0000000000000000 stateCalcAccelEcef_f
/var/tmp//ccp6IKBe.s:4391   .text.stateCalcAccelEcef_f:00000000000000bc $d
/var/tmp//ccp6IKBe.s:4396   .text.stateCalcBodyRates_i:0000000000000000 $t
/var/tmp//ccp6IKBe.s:4401   .text.stateCalcBodyRates_i:0000000000000000 stateCalcBodyRates_i
/var/tmp//ccp6IKBe.s:4454   .text.stateCalcBodyRates_i:0000000000000058 $d
/var/tmp//ccp6IKBe.s:4459   .text.stateCalcBodyRates_f:0000000000000000 $t
/var/tmp//ccp6IKBe.s:4464   .text.stateCalcBodyRates_f:0000000000000000 stateCalcBodyRates_f
/var/tmp//ccp6IKBe.s:4517   .text.stateCalcBodyRates_f:0000000000000058 $d
/var/tmp//ccp6IKBe.s:4522   .text.stateCalcHorizontalWindspeed_i:0000000000000000 $t
/var/tmp//ccp6IKBe.s:4527   .text.stateCalcHorizontalWindspeed_i:0000000000000000 stateCalcHorizontalWindspeed_i
/var/tmp//ccp6IKBe.s:4575   .text.stateCalcHorizontalWindspeed_i:0000000000000048 $d
/var/tmp//ccp6IKBe.s:4580   .text.stateCalcAirspeed_i:0000000000000000 $t
/var/tmp//ccp6IKBe.s:4585   .text.stateCalcAirspeed_i:0000000000000000 stateCalcAirspeed_i
/var/tmp//ccp6IKBe.s:4623   .text.stateCalcAirspeed_i:0000000000000030 $d
/var/tmp//ccp6IKBe.s:4628   .text.stateCalcHorizontalWindspeed_f:0000000000000000 $t
/var/tmp//ccp6IKBe.s:4633   .text.stateCalcHorizontalWindspeed_f:0000000000000000 stateCalcHorizontalWindspeed_f
/var/tmp//ccp6IKBe.s:4670   .text.stateCalcHorizontalWindspeed_f:0000000000000034 $d
/var/tmp//ccp6IKBe.s:4675   .text.stateCalcAirspeed_f:0000000000000000 $t
/var/tmp//ccp6IKBe.s:4680   .text.stateCalcAirspeed_f:0000000000000000 stateCalcAirspeed_f
/var/tmp//ccp6IKBe.s:4718   .text.stateCalcAirspeed_f:0000000000000030 $d
/var/tmp//ccp6IKBe.s:4728   .bss.state:0000000000000000 state
/var/tmp//ccp6IKBe.s:4724   .bss.state:0000000000000000 $d
                     .debug_frame:0000000000000010 $d
/var/tmp//ccp6IKBe.s:1274   .text.stateCalcPositionEcef_f:000000000000010c $t

UNDEFINED SYMBOLS
__aeabi_f2d
__aeabi_dmul
__aeabi_d2iz
ecef_of_ned_pos_i
ecef_of_ned_point_f
ecef_of_lla_f
ecef_of_lla_i
__aeabi_fmul
__aeabi_f2iz
__aeabi_fsub
__aeabi_i2d
__aeabi_ddiv
__aeabi_d2f
ned_of_ecef_pos_i
ned_of_ecef_point_f
ned_of_lla_point_i
utm_of_lla_f
enu_of_ecef_pos_i
enu_of_ecef_point_f
enu_of_lla_point_i
lla_of_ecef_f
lla_of_ecef_i
lla_of_utm_f
__aeabi_i2f
ned_of_lla_point_f
enu_of_lla_point_f
__aeabi_fdiv
ned_of_ecef_vect_i
enu_of_ecef_vect_i
ecef_of_ned_vect_i
__aeabi_fadd
ned_of_ecef_vect_f
sqrtf
enu_of_ecef_vect_f
ecef_of_ned_vect_f
atan2f
